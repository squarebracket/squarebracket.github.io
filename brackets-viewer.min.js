/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/dom.ts":
/*!********************!*\
  !*** ./src/dom.ts ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.setupConnection = exports.getFinalConnection = exports.getBracketConnection = exports.addParticipantImage = exports.addParticipantOrigin = exports.setupLoss = exports.setupWin = exports.setupBye = exports.setupHint = exports.createRankingHeaders = exports.createCell = exports.createRow = exports.createTable = exports.createResultContainer = exports.createNameContainer = exports.createPlayersContainer = exports.createParticipantContainer = exports.createMainFeedContainer = exports.createParticipantContainerContainer = exports.createOpponentsContainer = exports.createChildCountLabel = exports.createMatchLabel = exports.createMatchContainer = exports.createMatchTimeContainer = exports.createRoundContainer = exports.createRoundsContainer = exports.createGroupContainer = exports.createBracketContainer = exports.createEliminationContainer = exports.createRoundRobinContainer = exports.createPopoverTitle = exports.createTitle = void 0;\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/helpers.ts\");\nconst lang_1 = __webpack_require__(/*! ./lang */ \"./src/lang.ts\");\n/**\n * Creates the title of the viewer.\n *\n * @param title The title to set.\n */\nfunction createTitle(title) {\n  const h1 = document.createElement('h1');\n  h1.setAttribute('id', title.replace(/ /g, '_'));\n  h1.innerText = title;\n  return h1;\n}\nexports.createTitle = createTitle;\n/**\n * Creates the title of a popover.\n *\n * @param title The title to set.\n */\nfunction createPopoverTitle(title) {\n  const h4 = document.createElement('h4');\n  h4.innerText = title;\n  return h4;\n}\nexports.createPopoverTitle = createPopoverTitle;\n/**\n * Creates a container which contains a round-robin stage.\n *\n * @param stageId ID of the stage.\n */\nfunction createRoundRobinContainer(stageId) {\n  const stage = document.createElement('div');\n  stage.classList.add('round-robin');\n  stage.setAttribute('data-stage-id', stageId.toString());\n  return stage;\n}\nexports.createRoundRobinContainer = createRoundRobinContainer;\n/**\n * Creates a container which contains an elimination stage.\n *\n * @param stageId ID of the stage.\n */\nfunction createEliminationContainer(stageId) {\n  const stage = document.createElement('div');\n  stage.classList.add('elimination');\n  stage.setAttribute('data-stage-id', stageId.toString());\n  return stage;\n}\nexports.createEliminationContainer = createEliminationContainer;\n/**\n * Creates a container which contains one bracket of a single or double elimination stage.\n *\n * @param groupId ID of the group.\n * @param title Title of the group.\n */\nfunction createBracketContainer(groupId, title) {\n  const bracket = document.createElement('section');\n  bracket.classList.add('bracket');\n  // Consolation matches are not in a group.\n  if (groupId) bracket.setAttribute('data-group-id', groupId.toString());\n  if (title) {\n    const h2 = document.createElement('h2');\n    h2.innerText = title;\n    bracket.append(h2);\n  }\n  return bracket;\n}\nexports.createBracketContainer = createBracketContainer;\n/**\n * Creates a container which contains a group for round-robin stages.\n *\n * @param groupId ID of the group.\n * @param title Title of the group.\n */\nfunction createGroupContainer(groupId, title) {\n  const h2 = document.createElement('h2');\n  h2.innerText = title;\n  const group = document.createElement('section');\n  group.classList.add('group');\n  group.setAttribute('data-group-id', groupId.toString());\n  group.append(h2);\n  return group;\n}\nexports.createGroupContainer = createGroupContainer;\n/**\n * Creates a container which contains a list of rounds.\n */\nfunction createRoundsContainer() {\n  const round = document.createElement('div');\n  round.classList.add('rounds');\n  return round;\n}\nexports.createRoundsContainer = createRoundsContainer;\n/**\n * Creates a container which contains a round.\n *\n * @param roundId ID of the round.\n * @param title Title of the round.\n */\nfunction createRoundContainer(roundId, title) {\n  const h3 = document.createElement('h3');\n  h3.innerText = title;\n  const round = document.createElement('article');\n  round.classList.add('round');\n  round.setAttribute('data-round-id', roundId.toString());\n  round.append(h3);\n  return round;\n}\nexports.createRoundContainer = createRoundContainer;\n/**\n *\n */\nfunction createMatchTimeContainer(match) {\n  const div = document.createElement('span');\n  div.classList.add('time');\n  if (match) {\n    if ((0, helpers_1.isMatchGame)(match)) div.setAttribute('data-match-game-id', match.id.toString());else div.setAttribute('data-match-id', match.id.toString());\n  }\n  if (match === null || match === void 0 ? void 0 : match.time) {\n    div.innerHTML = new Intl.DateTimeFormat('en-US', {\n      day: 'numeric',\n      month: 'short',\n      hour: 'numeric',\n      minute: 'numeric',\n      timeZoneName: 'short'\n    }).format(new Date(match.time));\n  }\n  return div;\n}\nexports.createMatchTimeContainer = createMatchTimeContainer;\n/**\n * Creates a container which contains a match.\n *\n * @param match A match or a match game.\n */\nfunction createMatchContainer(match) {\n  const div = document.createElement('div');\n  div.classList.add('match');\n  if (match) {\n    if ((0, helpers_1.isMatchGame)(match)) div.setAttribute('data-match-game-id', match.id.toString());else div.setAttribute('data-match-id', match.id.toString());\n    div.setAttribute('data-match-status', match.status.toString());\n  }\n  return div;\n}\nexports.createMatchContainer = createMatchContainer;\n/**\n * Creates a container which contains the label of a match.\n *\n * @param label The label of the match.\n * @param status The status to set as tooltip.\n * @param onClick Called when the label is clicked.\n */\nfunction createMatchLabel(label, status, onClick) {\n  const span = document.createElement('span');\n  span.innerText = label || '';\n  span.title = status;\n  onClick && span.addEventListener('click', onClick);\n  return span;\n}\nexports.createMatchLabel = createMatchLabel;\n/**\n * Creates a container which contains the child count label of a match.\n *\n * @param label The child count label of the match.\n * @param onClick Called when the label is clicked.\n */\nfunction createChildCountLabel(label, onClick) {\n  const span = document.createElement('span');\n  span.innerText = label;\n  onClick && span.addEventListener('click', onClick);\n  return span;\n}\nexports.createChildCountLabel = createChildCountLabel;\n/**\n * Creates a container which contains the opponents of a match.\n *\n * @param onClick Called when the match is clicked.\n */\nfunction createOpponentsContainer(onClick) {\n  const opponents = document.createElement('div');\n  opponents.classList.add('opponents');\n  onClick && opponents.addEventListener('click', onClick);\n  return opponents;\n}\nexports.createOpponentsContainer = createOpponentsContainer;\n/**\n * Creates a container which contains a participant.\n *\n * @param participantId ID of the participant.\n */\nfunction createParticipantContainerContainer() {\n  const participant = document.createElement('div');\n  participant.classList.add('participant-container');\n  return participant;\n}\nexports.createParticipantContainerContainer = createParticipantContainerContainer;\n/**\n * Creates a container which contains a participant.\n *\n * @param participantId ID of the participant.\n */\nfunction createMainFeedContainer(streamInfo) {\n  const mainFeed = document.createElement('div');\n  mainFeed.classList.add('main-feed');\n  mainFeed.innerHTML = `${streamInfo.type.toUpperCase()}: <a href=\"${streamInfo.url}\">HERE</a>`;\n  return mainFeed;\n}\nexports.createMainFeedContainer = createMainFeedContainer;\n/**\n * Creates a container which contains a participant.\n *\n * @param participantId ID of the participant.\n */\nfunction createParticipantContainer(participantId) {\n  const participant = document.createElement('div');\n  participant.classList.add('participant');\n  if (participantId !== null && participantId !== undefined) participant.setAttribute('data-participant-id', participantId.toString());\n  return participant;\n}\nexports.createParticipantContainer = createParticipantContainer;\n/**\n * Creates a container which contains the players for a participant.\n *\n * @param participantId ID of the participant.\n */\nfunction createPlayersContainer(participantId) {\n  const participant = document.createElement('div');\n  participant.classList.add('players');\n  if (participantId !== null && participantId !== undefined) participant.setAttribute('data-participant-id', participantId.toString());\n  return participant;\n}\nexports.createPlayersContainer = createPlayersContainer;\n/**\n * Creates a container which contains the name of a participant.\n */\nfunction createNameContainer() {\n  const name = document.createElement('div');\n  name.classList.add('name');\n  return name;\n}\nexports.createNameContainer = createNameContainer;\n/**\n * Creates a container which contains the result of a match for a participant.\n */\nfunction createResultContainer() {\n  const result = document.createElement('div');\n  result.classList.add('result');\n  return result;\n}\nexports.createResultContainer = createResultContainer;\n/**\n * Creates a table.\n */\nfunction createTable() {\n  return document.createElement('table');\n}\nexports.createTable = createTable;\n/**\n * Creates a table row.\n */\nfunction createRow() {\n  return document.createElement('tr');\n}\nexports.createRow = createRow;\n/**\n * Creates a table cell.\n *\n * @param data The data in the cell.\n */\nfunction createCell(data) {\n  const td = document.createElement('td');\n  td.innerText = String(data);\n  return td;\n}\nexports.createCell = createCell;\n/**\n * Creates the headers for a ranking table.\n *\n * @param ranking The object containing the ranking.\n */\nfunction createRankingHeaders(ranking) {\n  const headers = document.createElement('tr');\n  const firstItem = ranking[0];\n  for (const key in firstItem) {\n    const prop = key;\n    const header = (0, helpers_1.rankingHeader)(prop);\n    const th = document.createElement('th');\n    th.innerText = header.text;\n    th.setAttribute('title', header.tooltip);\n    headers.append(th);\n  }\n  return headers;\n}\nexports.createRankingHeaders = createRankingHeaders;\n/**\n * Sets a hint on a name container.\n *\n * @param nameContainer The name container.\n * @param hint The hint to set.\n */\nfunction setupHint(nameContainer, hint) {\n  nameContainer.classList.add('hint');\n  nameContainer.innerText = hint;\n  nameContainer.title = hint;\n}\nexports.setupHint = setupHint;\n/**\n * Sets a BYE on a name container.\n *\n * @param nameContainer The name container.\n */\nfunction setupBye(nameContainer) {\n  nameContainer.innerText = (0, lang_1.t)('common.bye');\n  nameContainer.classList.add('bye');\n}\nexports.setupBye = setupBye;\n/**\n * Sets a win for a participant.\n *\n * @param participantContainer The participant container.\n * @param resultContainer The result container.\n * @param participant The participant result.\n */\nfunction setupWin(participantContainer, resultContainer, participant) {\n  if (participant.result && participant.result === 'win') {\n    participantContainer.classList.add('win');\n    if (participant.score === undefined) resultContainer.innerText = (0, lang_1.t)('abbreviations.win');\n  }\n}\nexports.setupWin = setupWin;\n/**\n * Sets a loss for a participant.\n *\n * @param participantContainer The participant container.\n * @param resultContainer The result container.\n * @param participant The participant result.\n */\nfunction setupLoss(participantContainer, resultContainer, participant) {\n  if (participant.result && participant.result === 'loss' || participant.forfeit) {\n    participantContainer.classList.add('loss');\n    if (participant.forfeit) resultContainer.innerText = (0, lang_1.t)('abbreviations.forfeit');else if (participant.score === undefined) resultContainer.innerText = (0, lang_1.t)('abbreviations.loss');\n  }\n}\nexports.setupLoss = setupLoss;\n/**\n * Adds the participant origin to a name.\n *\n * @param nameContainer The name container.\n * @param text The text to set (origin).\n * @param placement The placement of the participant origin.\n */\nfunction addParticipantOrigin(nameContainer, text, placement) {\n  const span = document.createElement('span');\n  if (placement === 'before') {\n    span.innerText = `${text} `;\n    nameContainer.prepend(span);\n  } else if (placement === 'after') {\n    span.innerText = ` (${text})`;\n    nameContainer.append(span);\n  }\n}\nexports.addParticipantOrigin = addParticipantOrigin;\n/**\n * Adds the participant image to a name.\n *\n * @param nameContainer The name container.\n * @param src Source of the image.\n */\nfunction addParticipantImage(nameContainer, src) {\n  const img = document.createElement('img');\n  img.src = src;\n  nameContainer.prepend(img);\n}\nexports.addParticipantImage = addParticipantImage;\n/**\n * Returns the connection for a given round in a bracket.\n *\n * @param alwaysConnectFirstRound Whether to always connect the first round with the second round.\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n * @param match The match to connect to other matches.\n * @param matchLocation Location of the match.\n * @param connectFinal Whether to connect to the final.\n */\nfunction getBracketConnection(alwaysConnectFirstRound, roundNumber, roundCount, match, matchLocation, connectFinal) {\n  var _a, _b, _c;\n  const connection = {\n    connectPrevious: false,\n    connectNext: false\n  };\n  if (matchLocation === 'qualified') {\n    connection.connectPrevious = 'straight';\n    connection.connectNext = false;\n    return connection;\n  }\n  if (matchLocation === 'loser_bracket') {\n    connection.connectPrevious = roundNumber > 1 && (roundNumber % 2 === 1 ? 'square' : 'straight');\n    connection.connectNext = roundNumber < roundCount && (roundNumber % 2 === 0 ? 'square' : 'straight');\n  } else {\n    connection.connectPrevious = roundNumber > 1 && 'square';\n    connection.connectNext = roundNumber < roundCount ? 'square' : connectFinal ? 'straight' : false;\n  }\n  if (alwaysConnectFirstRound || roundNumber !== 2) return connection;\n  const upperBracket = matchLocation === 'single_bracket' || matchLocation === 'winner_bracket';\n  if (upperBracket && ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.position) === undefined && ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.position) === undefined) connection.connectPrevious = false;\n  if (matchLocation === 'loser_bracket' && ((_c = match.opponent2) === null || _c === void 0 ? void 0 : _c.position) === undefined) connection.connectPrevious = false;\n  return connection;\n}\nexports.getBracketConnection = getBracketConnection;\n/**\n * Returns the connection for a given round in the final.\n *\n * @param finalType Type of final.\n * @param roundNumber Number of the round.\n * @param matchCount The count of matches.\n */\nfunction getFinalConnection(finalType, roundNumber, matchCount) {\n  return {\n    connectPrevious: finalType === 'grand_final' && roundNumber === 1 && 'straight',\n    connectNext: matchCount === 2 && roundNumber === 1 && 'straight'\n  };\n}\nexports.getFinalConnection = getFinalConnection;\n/**\n * Sets the connection a match containers.\n *\n * @param opponentsContainer The opponents container.\n * @param matchContainer The match container.\n * @param connection The connection to set.\n */\nfunction setupConnection(opponentsContainer, matchContainer, connection) {\n  if (connection.connectPrevious) opponentsContainer.classList.add('connect-previous');\n  if (connection.connectNext) matchContainer.classList.add('connect-next');\n  if (connection.connectPrevious === 'straight') opponentsContainer.classList.add('straight');\n  if (connection.connectNext === 'straight') matchContainer.classList.add('straight');\n}\nexports.setupConnection = setupConnection;\n\n//# sourceURL=webpack://brackets-viewer/./src/dom.ts?");

/***/ }),

/***/ "./src/helpers.ts":
/*!************************!*\
  !*** ./src/helpers.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isMatchGame = exports.isMatch = exports.getRanking = exports.rankingHeader = exports.isMajorRound = exports.getOriginAbbreviation = exports.completeWithBlankMatches = exports.findRoot = exports.sortBy = exports.splitByWithLeftovers = exports.splitBy = void 0;\nconst lang_1 = __webpack_require__(/*! ./lang */ \"./src/lang.ts\");\n/**\n * Splits an array of objects based on their values at a given key.\n *\n * @param objects The array to split.\n * @param key The key of T.\n */\nfunction splitBy(objects, key) {\n  const map = {};\n  for (const obj of objects) {\n    const commonValue = obj[key];\n    if (!map[commonValue]) map[commonValue] = [];\n    map[commonValue].push(obj);\n  }\n  return Object.values(map);\n}\nexports.splitBy = splitBy;\n/**\n * Splits an array of objects based on their values at a given key.\n * Objects without a value at the given key will be set under a `-1` index.\n *\n * @param objects The array to split.\n * @param key The key of T.\n */\nfunction splitByWithLeftovers(objects, key) {\n  var _a;\n  const map = {};\n  for (const obj of objects) {\n    const commonValue = (_a = obj[key]) !== null && _a !== void 0 ? _a : '-1'; // Object keys are converted to a string.\n    if (!map[commonValue]) map[commonValue] = [];\n    map[commonValue].push(obj);\n  }\n  const withoutLeftovers = Object.entries(map).filter(([key]) => key !== '-1').map(([_, value]) => value);\n  const result = [...withoutLeftovers];\n  result[-1] = map[-1];\n  return result;\n}\nexports.splitByWithLeftovers = splitByWithLeftovers;\n/**\n * Sorts the objects in the given array by a given key.\n *\n * @param array The array to sort.\n * @param key The key of T.\n */\nfunction sortBy(array, key) {\n  return [...array].sort((a, b) => a[key] - b[key]);\n}\nexports.sortBy = sortBy;\n/**\n * Finds the root element\n *\n * @param selector An optional selector to select the root element.\n */\nfunction findRoot(selector) {\n  const queryResult = document.querySelectorAll(selector || '.brackets-viewer');\n  if (queryResult.length === 0) throw Error('Root not found. You must have at least one root element.');\n  if (queryResult.length > 1) throw Error('Multiple possible roots were found. Please use `config.selector` to choose a specific root.');\n  const root = queryResult[0];\n  if (!root.classList.contains('brackets-viewer')) throw Error('The selected root must have a `.brackets-viewer` class.');\n  return root;\n}\nexports.findRoot = findRoot;\n/**\n * Completes a list of matches with blank matches based on the next matches.\n *\n * Toornament can generate first rounds with an odd number of matches and the seeding is partially distributed in the second round.\n * This function adds a blank match in the first round as if it was the source match of a seeded match of the second round.\n *\n * @param bracketType Type of the bracket.\n * @param matches The list of first round matches.\n * @param nextMatches The list of second round matches.\n */\nfunction completeWithBlankMatches(bracketType, matches, nextMatches) {\n  if (!nextMatches) return {\n    matches,\n    fromToornament: false\n  };\n  let sources = [];\n  if (bracketType === 'single_bracket' || bracketType === 'winner_bracket') sources = nextMatches.map(match => {\n    var _a, _b;\n    return [((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.position) || null, ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.position) || null];\n  }).flat();\n  if (bracketType === 'loser_bracket') sources = nextMatches.map(match => {\n    var _a;\n    return ((_a = match.opponent2) === null || _a === void 0 ? void 0 : _a.position) || null;\n  });\n  // The manager does not set positions where the Toornament layer does.\n  if (sources.filter(source => source !== null).length === 0) return {\n    matches,\n    fromToornament: false\n  };\n  return {\n    matches: sources.map(source => source && matches.find(match => match.number === source) || null),\n    fromToornament: true\n  };\n}\nexports.completeWithBlankMatches = completeWithBlankMatches;\n/**\n * Returns the abbreviation for a participant origin.\n *\n * @param matchLocation Location of the match.\n * @param skipFirstRound Whether to skip the first round.\n * @param roundNumber Number of the round.\n * @param side Side of the participant.\n */\nfunction getOriginAbbreviation(matchLocation, skipFirstRound, roundNumber, side) {\n  roundNumber = roundNumber || -1;\n  if (skipFirstRound && matchLocation === 'loser_bracket' && roundNumber === 1) return (0, lang_1.t)('abbreviations.seed');\n  if (matchLocation === 'single_bracket' || matchLocation === 'winner_bracket' && roundNumber === 1) return (0, lang_1.t)('abbreviations.seed');\n  if (matchLocation === 'loser_bracket' && roundNumber % 2 === 0 && side === 'opponent1') return (0, lang_1.t)('abbreviations.position');\n  return null;\n}\nexports.getOriginAbbreviation = getOriginAbbreviation;\n/**\n * Indicates whether a round is major.\n *\n * @param roundNumber Number of the round.\n */\nfunction isMajorRound(roundNumber) {\n  return roundNumber === 1 || roundNumber % 2 === 0;\n}\nexports.isMajorRound = isMajorRound;\n/**\n * Returns the header for a ranking property.\n *\n * @param itemName Name of the ranking property.\n */\nfunction rankingHeader(itemName) {\n  return (0, lang_1.t)(`ranking.${itemName}`, {\n    returnObjects: true\n  });\n}\nexports.rankingHeader = rankingHeader;\n/**\n * Calculates the ranking based on a list of matches and a formula.\n *\n * @param matches The list of matches.\n * @param formula The points formula to apply.\n */\nfunction getRanking(matches, formula) {\n  formula = formula || (item => 3 * item.wins + 1 * item.draws + 0 * item.losses);\n  const rankingMap = {};\n  for (const match of matches) {\n    processParticipant(rankingMap, formula, match.opponent1, match.opponent2);\n    processParticipant(rankingMap, formula, match.opponent2, match.opponent1);\n  }\n  return createRanking(rankingMap);\n}\nexports.getRanking = getRanking;\n/**\n * Processes a participant and edits the ranking map.\n *\n * @param rankingMap The ranking map to edit.\n * @param formula The points formula to apply.\n * @param current The current participant.\n * @param other The opponent.\n */\nfunction processParticipant(rankingMap, formula, current, other) {\n  if (!current || current.id === null) return;\n  const state = rankingMap[current.id] || {\n    rank: 0,\n    id: 0,\n    played: 0,\n    wins: 0,\n    draws: 0,\n    losses: 0,\n    forfeits: 0,\n    scoreFor: 0,\n    scoreAgainst: 0,\n    scoreDifference: 0,\n    points: 0\n  };\n  state.id = current.id;\n  if (current.forfeit || current.result) state.played++;\n  if (current.result === 'win') state.wins++;\n  if (current.result === 'draw') state.draws++;\n  if (current.result === 'loss') state.losses++;\n  if (current.forfeit) state.forfeits++;\n  state.scoreFor += current.score || 0;\n  state.scoreAgainst += other && other.score || 0;\n  state.scoreDifference = state.scoreFor - state.scoreAgainst;\n  state.points = formula(state);\n  rankingMap[current.id] = state;\n}\n/**\n * Creates the final ranking based on a ranking map. (Sort + Total points)\n *\n * @param rankingMap The ranking map (object).\n */\nfunction createRanking(rankingMap) {\n  const ranking = Object.values(rankingMap).sort((a, b) => a.points !== b.points ? b.points - a.points : b.played - a.played);\n  const rank = {\n    value: 0,\n    lastPoints: -1\n  };\n  for (const item of ranking) {\n    item.rank = rank.lastPoints !== item.points ? ++rank.value : rank.value;\n    rank.lastPoints = item.points;\n  }\n  return ranking;\n}\n/**\n * Indicates whether the input is a match.\n *\n * @param input A match or a match game.\n */\nfunction isMatch(input) {\n  return 'child_count' in input;\n}\nexports.isMatch = isMatch;\n/**\n * Indicates whether the input is a match game.\n *\n * @param input A match or a match game.\n */\nfunction isMatchGame(input) {\n  return !isMatch(input);\n}\nexports.isMatchGame = isMatchGame;\n\n//# sourceURL=webpack://brackets-viewer/./src/helpers.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BracketsViewer = void 0;\nconst brackets_memory_db_1 = __webpack_require__(/*! brackets-memory-db */ \"./node_modules/brackets-memory-db/dist/index.js\");\nconst brackets_manager_1 = __webpack_require__(/*! brackets-manager */ \"./node_modules/brackets-manager/dist/index.js\");\nconst main_1 = __webpack_require__(/*! ./main */ \"./src/main.ts\");\nObject.defineProperty(exports, \"BracketsViewer\", ({\n  enumerable: true,\n  get: function () {\n    return main_1.BracketsViewer;\n  }\n}));\nwindow.bracketsViewer = new main_1.BracketsViewer();\nwindow.inMemoryDatabase = new brackets_memory_db_1.InMemoryDatabase();\nwindow.bracketsManager = new brackets_manager_1.BracketsManager(window.inMemoryDatabase);\n\n//# sourceURL=webpack://brackets-viewer/./src/index.ts?");

/***/ }),

/***/ "./src/lang.ts":
/*!*********************!*\
  !*** ./src/lang.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getLoserBracketRoundName = exports.getWinnerBracketRoundName = exports.getRoundName = exports.getBracketName = exports.getGroupName = exports.getMatchStatus = exports.getFinalMatchLabel = exports.getMatchLabel = exports.getFinalOriginHint = exports.getOriginHint = exports.toI18nKey = exports.t = exports.addLocale = exports.locales = void 0;\nconst i18next_1 = __importDefault(__webpack_require__(/*! i18next */ \"./node_modules/i18next/dist/cjs/i18next.js\"));\nconst i18next_browser_languagedetector_1 = __importDefault(__webpack_require__(/*! i18next-browser-languagedetector */ \"./node_modules/i18next-browser-languagedetector/dist/cjs/i18nextBrowserLanguageDetector.js\"));\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/helpers.ts\");\nconst translation_json_1 = __importDefault(__webpack_require__(/*! ./i18n/en/translation.json */ \"./src/i18n/en/translation.json\"));\nconst translation_json_2 = __importDefault(__webpack_require__(/*! ./i18n/fr/translation.json */ \"./src/i18n/fr/translation.json\"));\nexports.locales = {\n  en: translation_json_1.default,\n  fr: translation_json_2.default\n};\nvoid i18next_1.default.use(i18next_browser_languagedetector_1.default).init({\n  fallbackLng: 'en',\n  debug: false,\n  resources: {\n    en: {\n      translation: exports.locales.en\n    },\n    fr: {\n      translation: exports.locales.fr\n    }\n  }\n});\n/**\n * Adds a locale to the available i18n bundles.\n *\n * @param name Name of the locale.\n * @param locale Contents of the locale.\n */\nasync function addLocale(name, locale) {\n  i18next_1.default.addResourceBundle(name, 'translation', locale, true, true);\n  await i18next_1.default.changeLanguage();\n}\nexports.addLocale = addLocale;\n/**\n * Returns an internationalized version of a locale key.\n *\n * @param key A locale key.\n * @param options Data to pass to the i18n process.\n */\nfunction t(key, options) {\n  return i18next_1.default.t(key, options);\n}\nexports.t = t;\n/**\n * Converts a type to a valid i18n key.\n *\n * @param key The key to convert.\n */\nfunction toI18nKey(key) {\n  return key.replace('_', '-');\n}\nexports.toI18nKey = toI18nKey;\n/**\n * Returns an origin hint function based on rounds information.\n *\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n * @param skipFirstRound Whether to skip the first round.\n * @param matchLocation Location of the match.\n */\nfunction getOriginHint(roundNumber, roundCount, skipFirstRound, matchLocation) {\n  if (roundNumber === 1) {\n    if (matchLocation === 'single_bracket') return position => t('origin-hint.seed', {\n      position\n    });\n    if (matchLocation === 'winner_bracket') return position => t('origin-hint.seed', {\n      position\n    });\n    if (matchLocation === 'loser_bracket' && skipFirstRound) return position => t('origin-hint.seed', {\n      position\n    });\n  }\n  if ((0, helpers_1.isMajorRound)(roundNumber) && matchLocation === 'loser_bracket') {\n    if (roundNumber === roundCount - 2) return position => t('origin-hint.winner-bracket-semi-final', {\n      position\n    });\n    if (roundNumber === roundCount) return () => t('origin-hint.winner-bracket-final');\n    const roundNumberWB = Math.ceil((roundNumber + 1) / 2);\n    if (skipFirstRound) return position => t('origin-hint.winner-bracket', {\n      round: roundNumberWB - 1,\n      position\n    });\n    return position => t('origin-hint.winner-bracket', {\n      round: roundNumberWB,\n      position\n    });\n  }\n  return undefined;\n}\nexports.getOriginHint = getOriginHint;\n/**\n * Returns an origin hint function for a match in final.\n *\n * @param stageType Type of the stage.\n * @param finalType Type of the final.\n * @param roundNumber Number of the round.\n */\nfunction getFinalOriginHint(stageType, finalType, roundNumber) {\n  if (stageType === 'single_elimination') return position => t('origin-hint.consolation-final', {\n    position\n  });\n  // Double elimination.\n  if (finalType === 'grand_final') {\n    return roundNumber === 1 ? () => t('origin-hint.grand-final') // Grand Final round 1\n    : undefined; // Grand Final round 2 (no hint because it's obvious both participants come from the previous round)\n  }\n  // Consolation final in double elimination.\n  return position => position === 1 ? t('origin-hint.double-elimination-consolation-final-opponent-1') : t('origin-hint.double-elimination-consolation-final-opponent-2');\n}\nexports.getFinalOriginHint = getFinalOriginHint;\n/**\n * Returns the label of a match.\n *\n * @param matchNumber Number of the match.\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n * @param matchLocation Location of the match.\n */\nfunction getMatchLabel(matchNumber, roundNumber, roundCount, matchLocation) {\n  if (roundNumber === undefined || roundCount === undefined || matchLocation === undefined) return t('match-label.default', {\n    matchNumber\n  });\n  const matchPrefix = matchLocation === 'winner_bracket' ? t('match-label.winner-bracket') : matchLocation === 'loser_bracket' ? t('match-label.loser-bracket') : t('match-label.standard-bracket');\n  const inSemiFinalRound = roundNumber === roundCount - 1;\n  const inFinalRound = roundNumber === roundCount;\n  if (matchLocation === 'single_bracket') {\n    if (inSemiFinalRound) return t('match-label.standard-bracket-semi-final', {\n      matchNumber\n    });\n    if (inFinalRound) return t('match-label.standard-bracket-final');\n  }\n  if (inSemiFinalRound) return t('match-label.double-elimination-semi-final', {\n    matchPrefix,\n    matchNumber\n  });\n  if (inFinalRound) return t('match-label.double-elimination-final', {\n    matchPrefix\n  });\n  return t('match-label.double-elimination', {\n    matchPrefix,\n    roundNumber,\n    matchNumber\n  });\n}\nexports.getMatchLabel = getMatchLabel;\n/**\n * Returns the label of a match in final.\n *\n * @param finalType Type of the final.\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n */\nfunction getFinalMatchLabel(finalType, roundNumber, roundCount) {\n  // Single elimination.\n  if (finalType === 'consolation_final') return t('match-label.consolation-final');\n  // Double elimination.\n  if (roundCount === 1) return t('match-label.grand-final-single');\n  return t('match-label.grand-final', {\n    roundNumber\n  });\n}\nexports.getFinalMatchLabel = getFinalMatchLabel;\n/**\n * Returns the status of a match.\n *\n * @param status The match status.\n */\nfunction getMatchStatus(status) {\n  switch (status) {\n    case brackets_model_1.Status.Locked:\n      return t('match-status.locked');\n    case brackets_model_1.Status.Waiting:\n      return t('match-status.waiting');\n    case brackets_model_1.Status.Ready:\n      return t('match-status.ready');\n    case brackets_model_1.Status.Running:\n      return t('match-status.running');\n    case brackets_model_1.Status.Completed:\n      return t('match-status.completed');\n    case brackets_model_1.Status.Archived:\n      return t('match-status.archived');\n    default:\n      return 'Unknown status';\n  }\n}\nexports.getMatchStatus = getMatchStatus;\n/**\n * Returns the name of a group.\n *\n * @param groupNumber Number of the group.\n */\nfunction getGroupName(groupNumber) {\n  return t('common.group-name', {\n    groupNumber\n  });\n}\nexports.getGroupName = getGroupName;\n/**\n * Returns the name of the bracket.\n *\n * @param stage The current stage.\n * @param type Type of the bracket.\n */\nfunction getBracketName(stage, type) {\n  switch (type) {\n    case 'winner_bracket':\n    case 'loser_bracket':\n      return t(`common.group-name-${toI18nKey(type)}`, {\n        stage\n      });\n    default:\n      return undefined;\n  }\n}\nexports.getBracketName = getBracketName;\n// eslint-disable-next-line jsdoc/require-param\n/**\n * Returns the name of a round.\n */\nfunction getRoundName({\n  roundNumber,\n  roundCount\n}, t) {\n  return roundNumber === roundCount ? t('common.round-name-final') : t('common.round-name', {\n    roundNumber\n  });\n}\nexports.getRoundName = getRoundName;\n// eslint-disable-next-line jsdoc/require-param\n/**\n * Returns the name of a round in the winner bracket of a double elimination stage.\n */\nfunction getWinnerBracketRoundName({\n  roundNumber,\n  roundCount\n}, t) {\n  return roundNumber === roundCount ? t('common.round-name-winner-bracket-final') : t('common.round-name-winner-bracket', {\n    roundNumber\n  });\n}\nexports.getWinnerBracketRoundName = getWinnerBracketRoundName;\n// eslint-disable-next-line jsdoc/require-param\n/**\n * Returns the name of a round in the loser bracket of a double elimination stage.\n */\nfunction getLoserBracketRoundName({\n  roundNumber,\n  roundCount\n}, t) {\n  return roundNumber === roundCount ? t('common.round-name-loser-bracket-final') : t('common.round-name-loser-bracket', {\n    roundNumber\n  });\n}\nexports.getLoserBracketRoundName = getLoserBracketRoundName;\n\n//# sourceURL=webpack://brackets-viewer/./src/lang.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BracketsViewer = void 0;\n__webpack_require__(/*! ./style.scss */ \"./src/style.scss\");\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/helpers.ts\");\nconst dom = __importStar(__webpack_require__(/*! ./dom */ \"./src/dom.ts\"));\nconst lang = __importStar(__webpack_require__(/*! ./lang */ \"./src/lang.ts\"));\nconst brackets_manager_1 = __webpack_require__(/*! brackets-manager */ \"./node_modules/brackets-manager/dist/index.js\");\nclass BracketsViewer {\n  constructor() {\n    this.participantRefs = {};\n    this.participants = [];\n    this.participantImages = [];\n    this.skipFirstRound = false;\n    this.alwaysConnectFirstRound = false;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._onMatchClick = match => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._onMatchLabelClick = match => {};\n  }\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  getRoundName(info, fallbackGetter) {\n    var _a, _b;\n    return ((_b = (_a = this.config).customRoundName) === null || _b === void 0 ? void 0 : _b.call(_a, info, lang.t)) || fallbackGetter(info, lang.t);\n  }\n  /**\n   * @deprecated Use `onMatchClick` in the `config` parameter of `viewer.render()`.\n   * @param callback A callback to be called when a match is clicked.\n   */\n  set onMatchClicked(callback) {\n    this._onMatchClick = callback;\n  }\n  /**\n   * Renders data generated with `brackets-manager.js`. If multiple stages are given, they will all be displayed.\n   *\n   * Stages won't be discriminated visually based on the tournament they belong to.\n   *\n   * @param data The data to display.\n   * @param config An optional configuration for the viewer.\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await -- Keep this async for backwards compatibility.\n  async render(data, config) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    if (typeof data === 'string') throw Error('Using a CSS selector as the first argument is deprecated. Please look here: https://github.com/Drarig29/brackets-viewer.js');\n    // console.log(data);\n    const root = document.createDocumentFragment();\n    this.config = {\n      customRoundName: config === null || config === void 0 ? void 0 : config.customRoundName,\n      participantOriginPlacement: (_a = config === null || config === void 0 ? void 0 : config.participantOriginPlacement) !== null && _a !== void 0 ? _a : 'before',\n      separatedChildCountLabel: (_b = config === null || config === void 0 ? void 0 : config.separatedChildCountLabel) !== null && _b !== void 0 ? _b : false,\n      showSlotsOrigin: (_c = config === null || config === void 0 ? void 0 : config.showSlotsOrigin) !== null && _c !== void 0 ? _c : true,\n      showLowerBracketSlotsOrigin: (_d = config === null || config === void 0 ? void 0 : config.showLowerBracketSlotsOrigin) !== null && _d !== void 0 ? _d : true,\n      showPopoverOnMatchLabelClick: (_e = config === null || config === void 0 ? void 0 : config.showPopoverOnMatchLabelClick) !== null && _e !== void 0 ? _e : true,\n      highlightParticipantOnHover: (_f = config === null || config === void 0 ? void 0 : config.highlightParticipantOnHover) !== null && _f !== void 0 ? _f : true,\n      showRankingTable: (_g = config === null || config === void 0 ? void 0 : config.showRankingTable) !== null && _g !== void 0 ? _g : true\n    };\n    if (config === null || config === void 0 ? void 0 : config.onMatchClick) this._onMatchClick = config.onMatchClick;\n    if (config === null || config === void 0 ? void 0 : config.onMatchLabelClick) this._onMatchLabelClick = config.onMatchLabelClick;\n    if (!((_h = data.stages) === null || _h === void 0 ? void 0 : _h.length)) throw Error('The `data.stages` array is either empty or undefined');\n    if (!((_j = data.participants) === null || _j === void 0 ? void 0 : _j.length)) throw Error('The `data.participants` array is either empty or undefined');\n    if (!((_k = data.matches) === null || _k === void 0 ? void 0 : _k.length)) throw Error('The `data.matches` array is either empty or undefined');\n    this.participants = data.participants;\n    data.participants.forEach(participant => this.participantRefs[participant.id] = []);\n    this.popover = document.createElement('div');\n    this.popover.setAttribute('popover', 'auto');\n    this.popover.addEventListener('toggle', event => {\n      if (event.newState === 'closed') this.clearPreviousPopoverSelections();\n    });\n    root.append(this.popover);\n    data.stages.forEach(stage => this.renderStage(root, {\n      ...data,\n      stages: [stage],\n      matches: data.matches.filter(match => match.stage_id === stage.id).map(match => ({\n        ...match,\n        metadata: {\n          stageType: stage.type,\n          games: data.matchGames.filter(game => game.parent_id === match.id)\n        }\n      }))\n    }));\n    const target = (0, helpers_1.findRoot)(config === null || config === void 0 ? void 0 : config.selector);\n    if (config === null || config === void 0 ? void 0 : config.clear) target.innerHTML = '';\n    target.append(root);\n  }\n  /**\n   * Updates the results of an existing match.\n   *\n   * @param match The match to update.\n   */\n  updateMatch(match) {\n    //  TODO: finish this function (update win/loss/forfeit, scoreboard in round-robin, etc.)\n    var _a, _b, _c, _d, _e, _f;\n    const matchContainer = document.querySelector(`[data-match-id='${match.id}']`);\n    if (!matchContainer) throw Error('Match not found.');\n    matchContainer.setAttribute('data-match-status', match.status.toString());\n    const result1 = matchContainer.querySelector('.participant:nth-of-type(1) .result');\n    if (result1 && ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.score)) result1.innerHTML = (_c = (_b = match.opponent1) === null || _b === void 0 ? void 0 : _b.score) === null || _c === void 0 ? void 0 : _c.toString();\n    const result2 = matchContainer.querySelector('.participant:nth-of-type(2) .result');\n    if (result2 && ((_d = match.opponent2) === null || _d === void 0 ? void 0 : _d.score)) result2.innerHTML = (_f = (_e = match.opponent2) === null || _e === void 0 ? void 0 : _e.score) === null || _f === void 0 ? void 0 : _f.toString();\n  }\n  /**\n   * Sets the images which will be rendered for every participant.\n   *\n   * @param images The participant images.\n   */\n  setParticipantImages(images) {\n    this.participantImages = images;\n  }\n  /**\n   * Adds a locale to the available i18n bundles.\n   *\n   * @param name Name of the locale.\n   * @param locale Contents of the locale.\n   */\n  async addLocale(name, locale) {\n    await lang.addLocale(name, locale);\n  }\n  /**\n   * Renders a stage (round-robin, single or double elimination).\n   *\n   * @param root The root element.\n   * @param data The data to display.\n   */\n  renderStage(root, data) {\n    var _a;\n    const stage = data.stages[0];\n    if (!((_a = data.matches) === null || _a === void 0 ? void 0 : _a.length)) throw Error(`No matches found for stage ${stage.id}`);\n    // Consolation matches are under `-1` in the array.\n    const matchesByGroup = (0, helpers_1.splitByWithLeftovers)(data.matches, 'group_id');\n    this.stage = stage;\n    this.skipFirstRound = stage.settings.skipFirstRound || false;\n    switch (stage.type) {\n      case 'round_robin':\n        this.renderRoundRobin(root, stage, matchesByGroup);\n        break;\n      case 'single_elimination':\n      case 'double_elimination':\n        this.renderElimination(root, stage, matchesByGroup);\n        break;\n      default:\n        throw Error(`Unknown bracket type: ${stage.type}`);\n    }\n    this.renderConsolationMatches(root, stage, matchesByGroup);\n  }\n  /**\n   * Renders a round-robin stage.\n   *\n   * @param root The root element.\n   * @param stage The stage to render.\n   * @param matchesByGroup A list of matches for each group.\n   */\n  renderRoundRobin(root, stage, matchesByGroup) {\n    const container = dom.createRoundRobinContainer(stage.id);\n    container.append(dom.createTitle(stage.name));\n    let groupNumber = 1;\n    for (const groupMatches of matchesByGroup) {\n      const groupId = groupMatches[0].group_id;\n      const groupContainer = dom.createGroupContainer(groupId, lang.getGroupName(groupNumber++));\n      const matchesByRound = (0, helpers_1.splitBy)(groupMatches, 'round_id').map(matches => (0, helpers_1.sortBy)(matches, 'number'));\n      let roundNumber = 1;\n      for (const roundMatches of matchesByRound) {\n        const roundId = roundMatches[0].round_id;\n        const roundName = this.getRoundName({\n          roundNumber,\n          roundCount: 0,\n          groupType: lang.toI18nKey('round_robin')\n        }, lang.getRoundName);\n        const roundContainer = dom.createRoundContainer(roundId, roundName);\n        for (const match of roundMatches) roundContainer.append(this.createMatch(match, true));\n        groupContainer.append(roundContainer);\n        roundNumber++;\n      }\n      if (this.config.showRankingTable) groupContainer.append(this.createRanking(groupMatches));\n      container.append(groupContainer);\n    }\n    root.append(container);\n  }\n  /**\n   * Renders an elimination stage (single or double).\n   *\n   * @param root The root element.\n   * @param stage The stage to render.\n   * @param matchesByGroup A list of matches for each group.\n   */\n  renderElimination(root, stage, matchesByGroup) {\n    const container = dom.createEliminationContainer(stage.id);\n    container.append(dom.createTitle(stage.name));\n    if (stage.type === 'single_elimination') this.renderSingleElimination(container, matchesByGroup, stage.ends_in_qual);else this.renderDoubleElimination(container, matchesByGroup, stage.ends_in_qual);\n    root.append(container);\n  }\n  /**\n   * Renders a list of consolation matches.\n   *\n   * @param root The root element.\n   * @param stage The stage to render.\n   * @param matchesByGroup A list of matches for each group.\n   */\n  renderConsolationMatches(root, stage, matchesByGroup) {\n    const consolationMatches = matchesByGroup[-1];\n    if (!(consolationMatches === null || consolationMatches === void 0 ? void 0 : consolationMatches.length)) return;\n    const consolation = dom.createBracketContainer(undefined, lang.t('common.consolation'));\n    const roundsContainer = dom.createRoundsContainer();\n    let matchNumber = 0;\n    for (const match of consolationMatches) {\n      roundsContainer.append(this.createMatch({\n        ...match,\n        metadata: {\n          label: lang.t('match-label.default', {\n            matchNumber: ++matchNumber\n          }),\n          stageType: stage.type,\n          games: []\n        }\n      }, true));\n    }\n    consolation.append(roundsContainer);\n    root.append(consolation);\n  }\n  /**\n   * Renders a single elimination stage.\n   *\n   * @param container The container to render into.\n   * @param matchesByGroup A list of matches for each group.\n   */\n  renderSingleElimination(container, matchesByGroup, endsInQual) {\n    const bracketMatches = (0, helpers_1.splitBy)(matchesByGroup[0], 'round_id').map(matches => (0, helpers_1.sortBy)(matches, 'number'));\n    const {\n      hasFinal,\n      connectFinal,\n      finalMatches\n    } = this.getFinalInfoSingleElimination(matchesByGroup);\n    this.renderBracket(container, bracketMatches, lang.getRoundName, 'single_bracket', connectFinal, endsInQual);\n    if (hasFinal) this.renderFinal(container, 'consolation_final', finalMatches);\n  }\n  /**\n   * Renders a double elimination stage.\n   *\n   * @param container The container to render into.\n   * @param matchesByGroup A list of matches for each group.\n   */\n  renderDoubleElimination(container, matchesByGroup, endsInQual) {\n    const hasLoserBracket = matchesByGroup[1] !== undefined;\n    const winnerBracketMatches = (0, helpers_1.splitBy)(matchesByGroup[0], 'round_id').map(matches => (0, helpers_1.sortBy)(matches, 'number'));\n    const {\n      hasFinal,\n      connectFinal,\n      grandFinalMatches,\n      consolationFinalMatches\n    } = this.getFinalInfoDoubleElimination(matchesByGroup);\n    this.renderBracket(container, winnerBracketMatches, lang.getWinnerBracketRoundName, 'winner_bracket', connectFinal, endsInQual);\n    if (hasLoserBracket) {\n      const loserBracketMatches = (0, helpers_1.splitBy)(matchesByGroup[1], 'round_id').map(matches => (0, helpers_1.sortBy)(matches, 'number'));\n      this.renderBracket(container, loserBracketMatches, lang.getLoserBracketRoundName, 'loser_bracket', undefined, endsInQual);\n    }\n    if (hasFinal) {\n      this.renderFinal(container, 'grand_final', grandFinalMatches);\n      this.renderFinal(container, 'consolation_final', consolationFinalMatches);\n    }\n  }\n  /**\n   * Returns information about the final group in single elimination.\n   *\n   * @param matchesByGroup A list of matches for each group.\n   */\n  getFinalInfoSingleElimination(matchesByGroup) {\n    var _a;\n    const hasFinal = matchesByGroup[1] !== undefined;\n    const finalMatches = (0, helpers_1.sortBy)((_a = matchesByGroup[1]) !== null && _a !== void 0 ? _a : [], 'number');\n    // In single elimination, the only possible type of final is a consolation final,\n    // and it has to be disconnected from the bracket because it doesn't directly follows its last match.\n    const connectFinal = false;\n    return {\n      hasFinal,\n      connectFinal,\n      finalMatches\n    };\n  }\n  /**\n   * Returns information about the final group in double elimination.\n   *\n   * @param matchesByGroup A list of matches for each group.\n   */\n  getFinalInfoDoubleElimination(matchesByGroup) {\n    var _a;\n    const hasFinal = matchesByGroup[2] !== undefined;\n    const finalMatches = (0, helpers_1.sortBy)((_a = matchesByGroup[2]) !== null && _a !== void 0 ? _a : [], 'number');\n    // All grand final matches have a `number: 1` property. We can have 0, 1 or 2 of them.\n    const grandFinalMatches = finalMatches.filter(match => match.number === 1);\n    // All consolation matches have a `number: 2` property (set by the manager). We can only have 0 or 1 of them.\n    const consolationFinalMatches = finalMatches.filter(match => match.number === 2);\n    // In double elimination, we can have a grand final, a consolation final, or both.\n    // We only want to connect the upper bracket with the final group when we have at least one grand final match.\n    // The grand final will always be placed directly next to the bracket.\n    const connectFinal = grandFinalMatches.length > 0;\n    return {\n      hasFinal,\n      connectFinal,\n      grandFinalMatches,\n      consolationFinalMatches\n    };\n  }\n  /**\n   * Renders a bracket.\n   *\n   * @param container The container to render into.\n   * @param matchesByRound A list of matches for each round.\n   * @param getRoundName A function giving a round's name based on its number.\n   * @param bracketType Type of the bracket.\n   * @param connectFinal Whether to connect the last match of the bracket to the first match of the final group.\n   */\n  renderBracket(container, matchesByRound, getRoundName, bracketType, connectFinal, endsInQual) {\n    var _a, _b;\n    const groupId = matchesByRound[0][0].group_id;\n    const roundCount = endsInQual ? matchesByRound.length + 1 : matchesByRound.length;\n    // const roundCount = matchesByRound.length;\n    // console.log(endsInQual, matchesByRound.length, roundCount);\n    const bracketContainer = dom.createBracketContainer(groupId, lang.getBracketName(this.stage, bracketType));\n    const roundsContainer = dom.createRoundsContainer();\n    const {\n      matches: completedMatches,\n      fromToornament\n    } = (0, helpers_1.completeWithBlankMatches)(bracketType, matchesByRound[0], matchesByRound[1]);\n    this.alwaysConnectFirstRound = !fromToornament;\n    for (let roundIndex = 0; roundIndex < matchesByRound.length; roundIndex++) {\n      const roundId = matchesByRound[roundIndex][0].round_id;\n      const roundNumber = roundIndex + 1;\n      const roundName = this.getRoundName({\n        roundNumber,\n        roundCount,\n        fractionOfFinal: brackets_manager_1.helpers.getFractionOfFinal(roundNumber, roundCount),\n        groupType: lang.toI18nKey(bracketType)\n      }, getRoundName);\n      const roundContainer = dom.createRoundContainer(roundId, roundName);\n      const roundMatches = fromToornament && roundNumber === 1 ? completedMatches : matchesByRound[roundIndex];\n      for (const match of roundMatches) {\n        if (match === null) {\n          continue;\n        }\n        const connection = dom.getBracketConnection(this.alwaysConnectFirstRound, roundNumber, roundCount, match, bracketType, connectFinal);\n        if (endsInQual && roundIndex === matchesByRound.length - 1) {\n          connection.connectNext = 'straight';\n        }\n        roundContainer.append(match && this.createBracketMatch({\n          ...match,\n          metadata: {\n            ...match.metadata,\n            roundNumber,\n            roundCount,\n            matchLocation: bracketType,\n            connection,\n            connectFinal\n          }\n        }) || this.skipBracketMatch());\n      }\n      roundsContainer.append(roundContainer);\n      // qual round\n      if (endsInQual && roundIndex === matchesByRound.length - 1) {\n        // TODO: i18n\n        const qualContainer = dom.createRoundContainer(roundId, 'Qualified');\n        for (const match of roundMatches) {\n          if (match === null) {\n            continue;\n          }\n          let qualified = {\n            id: null\n          };\n          if (((_a = match === null || match === void 0 ? void 0 : match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === 'win') {\n            qualified = match.opponent1;\n          } else if (((_b = match === null || match === void 0 ? void 0 : match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === 'win') {\n            qualified = match.opponent2;\n          }\n          match.opponent1 = qualified;\n          match.opponent2 = null;\n          qualContainer.append(match && this.createQualified({\n            ...match,\n            metadata: {\n              ...match.metadata,\n              roundNumber,\n              roundCount,\n              matchLocation: 'qualified',\n              connectFinal: false\n            }\n          }) || this.skipBracketMatch());\n        }\n        roundsContainer.append(qualContainer);\n      }\n    }\n    bracketContainer.append(roundsContainer);\n    container.append(bracketContainer);\n  }\n  /**\n   * Renders a final group.\n   *\n   * @param container The container to render into.\n   * @param finalType Type of the final.\n   * @param matches Matches of the final.\n   */\n  renderQualified(container, matches) {\n    var _a, _b;\n    // Double elimination stages can have a grand final, or a consolation final, or both.\n    if (matches.length === 0) return;\n    const upperBracket = container.querySelector('.bracket .rounds');\n    if (!upperBracket) throw Error('Upper bracket not found.');\n    // const roundCount = finalMatches.length;\n    // TODO: i18n\n    // const defaultFinalRoundNameGetter: RoundNameGetter = ({ roundNumber, roundCount }) => lang.getFinalMatchLabel(finalType, roundNumber, roundCount);\n    const roundId = 'qual';\n    // @ts-ignore\n    const roundNumber = parseInt(matches[0].round_id);\n    const roundName = 'Qualified';\n    const roundContainer = dom.createRoundContainer(roundId, roundName);\n    for (const match of matches) {\n      let qualified = {\n        id: null\n      };\n      if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === 'win') {\n        qualified = match.opponent1;\n      } else if (((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === 'win') {\n        qualified = match.opponent2;\n      }\n      match.opponent1 = qualified;\n      match.opponent2 = null;\n      roundContainer.append(match && this.createQualified({\n        ...match,\n        metadata: {\n          ...match.metadata,\n          roundNumber,\n          roundCount: roundNumber,\n          matchLocation: 'qualified',\n          connectFinal: true\n        }\n      }) || this.skipBracketMatch());\n    }\n    upperBracket.append(roundContainer);\n    // const finalMatch: MatchWithMetadata = {\n    //     id: `${opponent.id}`,\n    //     status: 4,\n    //     opponent1: opponent,\n    // }\n    // for (let roundIndex = 0; roundIndex < finalMatches.length; roundIndex++) {\n    //     const roundNumber = roundIndex + 1;\n    //     const roundName = 'Qualified';\n    //     const finalMatch: MatchWithMetadata = {\n    //         ...finalMatches[roundIndex],\n    //         metadata: {\n    //             ...finalMatches[roundIndex].metadata,\n    //             roundNumber,\n    //             // roundCount,\n    //         // },\n    //         status: 4, // completed\n    //     // };\n    //     const roundContainer = dom.createRoundContainer(finalMatch.round_id, roundName);\n    //     roundContainer.append(this.createQualified(finalMatch));\n    //     upperBracket.append(roundContainer);\n    // }\n  }\n  /**\n   * Creates a match in a final.\n   *\n   * @param finalType Type of the final.\n   * @param match Information about the match.\n   */\n  createQualified(match) {\n    const {\n      roundNumber,\n      roundCount\n    } = match.metadata;\n    if (roundNumber === undefined || roundCount === undefined) throw Error(`The match's internal data is missing roundNumber or roundCount: ${JSON.stringify(match)}`);\n    const connection = {\n      connectNext: false,\n      connectPrevious: false\n    };\n    // TODO: i18n\n    const matchLabel = 'Qualified';\n    // const matchLabel = lang.getFinalMatchLabel(finalType, roundNumber, roundCount);\n    // const originHint = lang.getFinalOriginHint(match.metadata.stageType, finalType, roundNumber);\n    match.metadata.connection = connection;\n    match.metadata.label = matchLabel;\n    match.metadata.originHint = undefined;\n    match.child_count = 0;\n    if (match.opponent1) {\n      match.opponent1.score = undefined;\n    }\n    return this.createQBox(match, true);\n  }\n  /**\n   * Creates a match based on its results.\n   *\n   * @param match Results of the match.\n   * @param propagateHighlight Whether to highlight participants in other matches.\n   */\n  createQBox(match, propagateHighlight) {\n    const matchContainer = dom.createMatchContainer(match);\n    const opponents = dom.createOpponentsContainer();\n    const participant1 = this.createParticipant(match.opponent1, propagateHighlight, 'opponent1', undefined, 'qualified');\n    this.renderMatchLabel(opponents, match);\n    opponents.append(participant1);\n    matchContainer.append(opponents);\n    if ((0, helpers_1.isMatch)(match)) {\n      if (!match.metadata.connection) return matchContainer;\n      dom.setupConnection(opponents, matchContainer, match.metadata.connection);\n    }\n    return matchContainer;\n  }\n  /**\n   * Renders a final group.\n   *\n   * @param container The container to render into.\n   * @param finalType Type of the final.\n   * @param matches Matches of the final.\n   */\n  renderFinal(container, finalType, matches) {\n    // Double elimination stages can have a grand final, or a consolation final, or both.\n    if (matches.length === 0) return;\n    const upperBracket = container.querySelector('.bracket .rounds');\n    if (!upperBracket) throw Error('Upper bracket not found.');\n    const winnerWb = matches[0].opponent1;\n    const displayCount = (winnerWb === null || winnerWb === void 0 ? void 0 : winnerWb.id) === null || (winnerWb === null || winnerWb === void 0 ? void 0 : winnerWb.result) === 'win' ? 1 : 2;\n    const finalMatches = matches.slice(0, displayCount);\n    const roundCount = finalMatches.length;\n    const defaultFinalRoundNameGetter = ({\n      roundNumber,\n      roundCount\n    }) => lang.getFinalMatchLabel(finalType, roundNumber, roundCount);\n    for (let roundIndex = 0; roundIndex < finalMatches.length; roundIndex++) {\n      const roundNumber = roundIndex + 1;\n      const roundName = this.getRoundName({\n        roundNumber,\n        roundCount,\n        groupType: lang.toI18nKey('final_group'),\n        finalType: lang.toI18nKey(finalType)\n      }, defaultFinalRoundNameGetter);\n      const finalMatch = {\n        ...finalMatches[roundIndex],\n        metadata: {\n          ...finalMatches[roundIndex].metadata,\n          roundNumber,\n          roundCount,\n          matchLocation: 'final_group'\n        }\n      };\n      const roundContainer = dom.createRoundContainer(finalMatch.round_id, roundName);\n      roundContainer.append(this.createFinalMatch(finalType, finalMatch));\n      upperBracket.append(roundContainer);\n    }\n  }\n  /**\n   * Creates a ranking table based on matches of a round-robin stage.\n   *\n   * @param matches The list of matches.\n   */\n  createRanking(matches) {\n    const table = dom.createTable();\n    const ranking = (0, helpers_1.getRanking)(matches);\n    table.append(dom.createRankingHeaders(ranking));\n    for (const item of ranking) table.append(this.createRankingRow(item));\n    return table;\n  }\n  /**\n   * Creates a row of the ranking table.\n   *\n   * @param item Item of the ranking.\n   */\n  createRankingRow(item) {\n    const row = dom.createRow();\n    const notRanked = item.played === 0;\n    for (const key in item) {\n      const prop = key;\n      const data = item[prop];\n      if (prop === 'id') {\n        const participant = this.participants.find(participant => participant.id === data);\n        if (participant !== undefined) {\n          const cell = dom.createCell(participant.name);\n          this.setupMouseHover(participant.id, cell, true);\n          row.append(cell);\n          continue;\n        }\n      }\n      if (notRanked && (prop === 'rank' || prop === 'points')) {\n        row.append(dom.createCell('-'));\n        continue;\n      }\n      row.append(dom.createCell(data));\n    }\n    return row;\n  }\n  /**\n   * Creates a match in a bracket.\n   *\n   * @param match Information about the match.\n   */\n  createBracketMatch(match) {\n    const {\n      roundNumber,\n      roundCount,\n      matchLocation,\n      connectFinal\n    } = match.metadata;\n    if (roundNumber === undefined || roundCount === undefined || matchLocation === undefined) throw Error(`The match's internal data is missing roundNumber, roundCount or matchLocation: ${JSON.stringify(match)}`);\n    const matchLabel = lang.getMatchLabel(match.number, roundNumber, roundCount, matchLocation);\n    const originHint = lang.getOriginHint(roundNumber, roundCount, this.skipFirstRound, matchLocation);\n    if (!match.metadata.connection) {\n      match.metadata.connection = dom.getBracketConnection(this.alwaysConnectFirstRound, roundNumber, roundCount, match, matchLocation, connectFinal);\n    }\n    match.metadata.label = matchLabel;\n    match.metadata.originHint = originHint;\n    return this.createMatch(match, true);\n  }\n  /**\n   * Creates a match in a final.\n   *\n   * @param finalType Type of the final.\n   * @param match Information about the match.\n   */\n  createFinalMatch(finalType, match) {\n    const {\n      roundNumber,\n      roundCount\n    } = match.metadata;\n    if (roundNumber === undefined || roundCount === undefined) throw Error(`The match's internal data is missing roundNumber or roundCount: ${JSON.stringify(match)}`);\n    const connection = dom.getFinalConnection(finalType, roundNumber, roundCount);\n    const matchLabel = lang.getFinalMatchLabel(finalType, roundNumber, roundCount);\n    const originHint = lang.getFinalOriginHint(match.metadata.stageType, finalType, roundNumber);\n    match.metadata.connection = connection;\n    match.metadata.label = matchLabel;\n    match.metadata.originHint = originHint;\n    return this.createMatch(match, true);\n  }\n  /**\n   * Creates a hidden empty match to act as a placeholder.\n   */\n  skipBracketMatch() {\n    const matchContainer = dom.createMatchContainer();\n    const opponents = dom.createOpponentsContainer();\n    const participant1 = this.createParticipant(null, true);\n    const participant2 = this.createParticipant(null, true);\n    opponents.append(participant1, participant2);\n    matchContainer.append(opponents);\n    matchContainer.style.visibility = 'hidden';\n    return matchContainer;\n  }\n  /**\n   * Creates a match based on its results.\n   *\n   * @param match Results of the match.\n   * @param propagateHighlight Whether to highlight participants in other matches.\n   */\n  createMatch(match, propagateHighlight) {\n    const matchContainer = dom.createMatchContainer(match);\n    const opponents = (0, helpers_1.isMatch)(match) ? dom.createOpponentsContainer(() => this._onMatchClick(match)) : dom.createOpponentsContainer();\n    if ((0, helpers_1.isMatch)(match) && match.status >= brackets_model_1.Status.Completed) match.metadata.originHint = undefined;\n    if ((0, helpers_1.isMatch)(match)) {\n      const {\n        originHint,\n        matchLocation,\n        roundNumber\n      } = match.metadata;\n      const participant1 = this.createParticipant(match.opponent1, propagateHighlight, 'opponent1', originHint, matchLocation, roundNumber);\n      const participant2 = this.createParticipant(match.opponent2, propagateHighlight, 'opponent2', originHint, matchLocation, roundNumber);\n      this.renderMatchLabel(opponents, match);\n      opponents.append(participant1, participant2);\n    } else {\n      const participant1 = this.createParticipant(match.opponent1, propagateHighlight, 'opponent1');\n      const participant2 = this.createParticipant(match.opponent2, propagateHighlight, 'opponent2');\n      this.renderMatchLabel(opponents, match);\n      opponents.append(participant1, participant2);\n    }\n    // @ts-ignore\n    if (match.stream) {\n      // @ts-ignore\n      const mainStream = dom.createMainFeedContainer(match.stream);\n      console.log('GOT HERE');\n      matchContainer.append(mainStream);\n    }\n    if (match.time) {\n      const matchTime = dom.createMatchTimeContainer(match);\n      opponents.append(matchTime);\n    }\n    matchContainer.append(opponents);\n    if ((0, helpers_1.isMatch)(match)) {\n      if (!match.metadata.connection) return matchContainer;\n      dom.setupConnection(opponents, matchContainer, match.metadata.connection);\n    }\n    return matchContainer;\n  }\n  /**\n   * Creates a participant for a match.\n   *\n   * @param participant Information about the participant.\n   * @param propagateHighlight Whether to highlight the participant in other matches.\n   * @param side Side of the participant.\n   * @param originHint Origin hint for the match.\n   * @param matchLocation Location of the match.\n   * @param roundNumber Number of the round.\n   */\n  createParticipant(participant, propagateHighlight, side, originHint, matchLocation, roundNumber) {\n    const containers = {\n      container: dom.createParticipantContainerContainer(),\n      // players: dom.createPlayersContainer(participant && participant.id),\n      participant: dom.createParticipantContainer(participant && participant.id),\n      name: dom.createNameContainer(),\n      result: dom.createResultContainer()\n    };\n    if (participant === null || participant === undefined) dom.setupBye(containers.name);else this.renderParticipant(containers, participant, side, originHint, matchLocation, roundNumber);\n    // if (side === 'opponent1')\n    // containers.participant.append(containers.players, containers.name, containers.result);\n    // else\n    // containers.participant.append(containers.name, containers.result, containers.players);\n    containers.participant.append(containers.name, containers.result);\n    if (participant && participant.id !== null) this.setupMouseHover(participant.id, containers.participant, propagateHighlight);\n    return containers.participant;\n  }\n  /**\n   * Renders a participant.\n   *\n   * @param containers Containers for the participant.\n   * @param participant The participant result.\n   * @param side Side of the participant.\n   * @param originHint Origin hint for the match.\n   * @param matchLocation Location of the match.\n   * @param roundNumber Number of the round.\n   */\n  renderParticipant(containers, participant, side, originHint, matchLocation, roundNumber) {\n    const found = this.participants.find(item => item.id === participant.id);\n    if (found) {\n      // // @ts-ignore\n      // if (matchLocation !== 'qualified' && found.players) {\n      //     // @ts-ignore\n      //     const players = found.players.map((player) => {\n      //         if (player.twitch) {\n      //             return `<div class=\"player twitch\"><a href=\"https://twitch.tv/${player.twitch}\">${player.name}</a><br></div>`;\n      //         } else {\n      //             return `<div class=\"player notwitch\">${player.name}<br></div>`;\n      //         }\n      //     }).join('');\n      //     containers.players.innerHTML = players;\n      // }\n      containers.name.innerText = found.name;\n      containers.participant.setAttribute('title', found.name);\n      this.renderParticipantImage(containers.name, found.id);\n      this.renderParticipantOrigin(containers.name, participant, side, matchLocation, roundNumber);\n    } else this.renderHint(containers.name, participant, originHint, matchLocation);\n    containers.result.innerText = `${participant.score === undefined ? '-' : participant.score}`;\n    dom.setupWin(containers.participant, containers.result, participant);\n    dom.setupLoss(containers.participant, containers.result, participant);\n    if (matchLocation === 'qualified') {\n      containers.participant.classList.add('qualified');\n    }\n  }\n  /**\n   * Renders a participant image.\n   *\n   * @param nameContainer The name container.\n   * @param participantId ID of the participant.\n   */\n  renderParticipantImage(nameContainer, participantId) {\n    const found = this.participantImages.find(item => item.participantId === participantId);\n    if (found) dom.addParticipantImage(nameContainer, found.imageUrl);\n  }\n  /**\n   * Renders a match label.\n   *\n   * @param opponents The opponents container.\n   * @param match Results of the match.\n   */\n  renderMatchLabel(opponents, match) {\n    const {\n      label\n    } = match.metadata;\n    if ((0, helpers_1.isMatchGame)(match)) {\n      opponents.append(dom.createMatchLabel(label, lang.getMatchStatus(match.status)));\n      return;\n    }\n    const onClick = event => {\n      // Prevent `this._onMatchClick()` from being called.\n      event.stopPropagation();\n      this._onMatchLabelClick(match);\n      if (match.child_count > 0 && this.config.showPopoverOnMatchLabelClick) {\n        this.clearPreviousPopoverSelections();\n        opponents.classList.add('popover-selected');\n        this.showPopover(match);\n      }\n    };\n    if (this.config.separatedChildCountLabel) {\n      opponents.append(dom.createMatchLabel(label, lang.getMatchStatus(match.status), onClick));\n      if (match.child_count > 0) opponents.append(dom.createChildCountLabel(lang.t('common.best-of-x', {\n        x: match.child_count\n      }), onClick));\n      return;\n    }\n    if (match.child_count > 0) {\n      const childCountLabel = lang.t('common.best-of-x', {\n        x: match.child_count\n      });\n      const joined = label ? `${label}, ${childCountLabel}` : childCountLabel;\n      opponents.append(dom.createMatchLabel(joined, lang.getMatchStatus(match.status), onClick));\n    }\n  }\n  /**\n   * Show a popover to display the games of a match.\n   *\n   * @param match The parent match.\n   */\n  showPopover(match) {\n    this.popover.innerText = '';\n    const {\n      roundNumber,\n      roundCount,\n      matchLocation\n    } = match.metadata;\n    const matchLabel = lang.getMatchLabel(match.number, roundNumber, roundCount, matchLocation);\n    console.log('asdf', match.opponent1, match.opponent2);\n    const opp1 = this.participants.find(p => {\n      var _a;\n      return p.id === ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.id);\n    });\n    const opp2 = this.participants.find(p => {\n      var _a;\n      return p.id === ((_a = match.opponent2) === null || _a === void 0 ? void 0 : _a.id);\n    });\n    let text;\n    if (opp1 && opp2) {\n      text = `${opp1.name} vs ${opp2.name}`;\n    } else {\n      text = matchLabel;\n    }\n    const popoverTitle = dom.createPopoverTitle(text);\n    this.popover.append(popoverTitle);\n    for (const game of match.metadata.games) {\n      console.log('matchGame');\n      const matchGameLabel = lang.t('match-label.match-game', {\n        gameNumber: game.number\n      });\n      const match = this.createMatch({\n        ...game,\n        metadata: {\n          label: matchGameLabel\n        }\n      }, false);\n      this.popover.append(match);\n    }\n    try {\n      this.popover.togglePopover();\n    } catch {\n      // Keep this while Firefox doesn't support the Popover API.\n    }\n  }\n  /**\n   * Renders an origin hint for a participant.\n   *\n   * @param nameContainer The name container.\n   * @param participant The participant result.\n   * @param originHint Origin hint for the participant.\n   * @param matchLocation Location of the match.\n   */\n  renderHint(nameContainer, participant, originHint, matchLocation) {\n    if (originHint === undefined || participant.position === undefined) return;\n    if (!this.config.showSlotsOrigin) return;\n    if (!this.config.showLowerBracketSlotsOrigin && matchLocation === 'loser_bracket') return;\n    dom.setupHint(nameContainer, originHint(participant.position));\n  }\n  /**\n   * Renders a participant's origin.\n   *\n   * @param nameContainer The name container.\n   * @param participant The participant result.\n   * @param side Side of the participant.Side of the participant.\n   * @param matchLocation Location of the match.\n   * @param roundNumber Number of the round.\n   */\n  renderParticipantOrigin(nameContainer, participant, side, matchLocation, roundNumber) {\n    if (participant.position === undefined || matchLocation === undefined) return;\n    if (!this.config.participantOriginPlacement || this.config.participantOriginPlacement === 'none') return;\n    if (!this.config.showSlotsOrigin) return;\n    if (!this.config.showLowerBracketSlotsOrigin && matchLocation === 'loser_bracket') return;\n    const abbreviation = (0, helpers_1.getOriginAbbreviation)(matchLocation, this.skipFirstRound, roundNumber, side);\n    if (!abbreviation) return;\n    const origin = `${abbreviation}${participant.position}`;\n    dom.addParticipantOrigin(nameContainer, origin, this.config.participantOriginPlacement);\n  }\n  /**\n   * Sets mouse hover events for a participant.\n   *\n   * @param participantId ID of the participant.\n   * @param element The dom element to add events to.\n   * @param propagateHighlight Whether to highlight the participant in other matches.\n   */\n  setupMouseHover(participantId, element, propagateHighlight) {\n    if (!this.config.highlightParticipantOnHover) return;\n    const setupListeners = elements => {\n      element.addEventListener('mouseenter', () => {\n        elements.forEach(el => el.classList.add('hover'));\n      });\n      element.addEventListener('mouseleave', () => {\n        elements.forEach(el => el.classList.remove('hover'));\n      });\n    };\n    if (!propagateHighlight) {\n      setupListeners([element]);\n      return;\n    }\n    const refs = this.participantRefs[participantId];\n    if (!refs) throw Error(`The participant (id: ${participantId}) does not exist in the participants table.`);\n    refs.push(element);\n    setupListeners(refs);\n  }\n  /**\n   * Clears any previous popover selections.\n   */\n  clearPreviousPopoverSelections() {\n    var _a;\n    (_a = document.querySelector('.opponents.popover-selected')) === null || _a === void 0 ? void 0 : _a.classList.remove('popover-selected');\n  }\n}\nexports.BracketsViewer = BracketsViewer;\n\n//# sourceURL=webpack://brackets-viewer/./src/main.ts?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/base/getter.js":
/*!***********************************************************!*\
  !*** ./node_modules/brackets-manager/dist/base/getter.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseGetter = void 0;\nconst helpers = __webpack_require__(/*! ../helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass BaseGetter {\n    /**\n     * Creates an instance of a Storage getter.\n     *\n     * @param storage The implementation of Storage.\n     */\n    constructor(storage) {\n        this.storage = storage;\n    }\n    /**\n     * Gets all the rounds that contain ordered participants.\n     *\n     * @param stage The stage to get rounds from.\n     */\n    async getOrderedRounds(stage) {\n        if (!(stage === null || stage === void 0 ? void 0 : stage.settings.size))\n            throw Error('The stage has no size.');\n        if (stage.type === 'single_elimination')\n            return this.getOrderedRoundsSingleElimination(stage.id);\n        return this.getOrderedRoundsDoubleElimination(stage.id);\n    }\n    /**\n     * Gets all the rounds that contain ordered participants in a single elimination stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async getOrderedRoundsSingleElimination(stageId) {\n        return [await this.getUpperBracketFirstRound(stageId)];\n    }\n    /**\n     * Gets all the rounds that contain ordered participants in a double elimination stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async getOrderedRoundsDoubleElimination(stageId) {\n        // Getting all rounds instead of cherry-picking them is the least expensive.\n        const rounds = await this.storage.select('round', { stage_id: stageId });\n        if (!rounds)\n            throw Error('Error getting rounds.');\n        const loserBracket = await this.getLoserBracket(stageId);\n        if (!loserBracket)\n            throw Error('Loser bracket not found.');\n        const firstRoundWB = rounds[0];\n        const roundsLB = rounds.filter(r => r.group_id === loserBracket.id);\n        const orderedRoundsLB = roundsLB.filter(r => helpers.isOrderingSupportedLoserBracket(r.number, roundsLB.length));\n        return [firstRoundWB, ...orderedRoundsLB];\n    }\n    /**\n     * Gets the positional information (number in group and total number of rounds in group) of a round based on its id.\n     *\n     * @param roundId ID of the round.\n     */\n    async getRoundPositionalInfo(roundId) {\n        const round = await this.storage.select('round', roundId);\n        if (!round)\n            throw Error('Round not found.');\n        const rounds = await this.storage.select('round', { group_id: round.group_id });\n        if (!rounds)\n            throw Error('Error getting rounds.');\n        return {\n            roundNumber: round.number,\n            roundCount: rounds.length,\n        };\n    }\n    /**\n     * Gets the matches leading to the given match.\n     *\n     * @param match The current match.\n     * @param matchLocation Location of the current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the round.\n     */\n    async getPreviousMatches(match, matchLocation, stage, roundNumber) {\n        if (matchLocation === 'loser_bracket')\n            return this.getPreviousMatchesLB(match, stage, roundNumber);\n        if (matchLocation === 'final_group')\n            return this.getPreviousMatchesFinal(match, stage, roundNumber);\n        if (roundNumber === 1)\n            return []; // The match is in the first round of an upper bracket.\n        return this.getMatchesBeforeMajorRound(match, roundNumber);\n    }\n    /**\n     * Gets the matches leading to the given match, which is in a final group (consolation final or grand final).\n     *\n     * @param match The current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the current round.\n     */\n    async getPreviousMatchesFinal(match, stage, roundNumber) {\n        if (stage.type === 'single_elimination')\n            return this.getPreviousMatchesFinalSingleElimination(match, stage);\n        return this.getPreviousMatchesFinalDoubleElimination(match, roundNumber);\n    }\n    /**\n     * Gets the matches leading to the given match, which is in a final group (consolation final).\n     *\n     * @param match The current match.\n     * @param stage The parent stage.\n     */\n    async getPreviousMatchesFinalSingleElimination(match, stage) {\n        const upperBracket = await this.getUpperBracket(match.stage_id);\n        const upperBracketRoundCount = helpers.getUpperBracketRoundCount(stage.settings.size);\n        const semiFinalsRound = await this.storage.selectFirst('round', {\n            group_id: upperBracket.id,\n            number: upperBracketRoundCount - 1, // Second to last round\n        });\n        if (!semiFinalsRound)\n            throw Error('Semi finals round not found.');\n        const semiFinalMatches = await this.storage.select('match', {\n            round_id: semiFinalsRound.id,\n        });\n        if (!semiFinalMatches)\n            throw Error('Error getting semi final matches.');\n        // In single elimination, both the final and consolation final have the same previous matches.\n        return semiFinalMatches;\n    }\n    /**\n     * Gets the matches leading to the given match, which is in a final group (grand final).\n     *\n     * @param match The current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the current round.\n     */\n    async getPreviousMatchesFinalDoubleElimination(match, roundNumber) {\n        if (roundNumber > 1) // Double grand final\n            return [await this.findMatch(match.group_id, roundNumber - 1, 1)];\n        const winnerBracket = await this.getUpperBracket(match.stage_id);\n        const lastRoundWB = await this.getLastRound(winnerBracket.id);\n        const winnerBracketFinalMatch = await this.storage.selectFirst('match', {\n            round_id: lastRoundWB.id,\n            number: 1,\n        });\n        if (!winnerBracketFinalMatch)\n            throw Error('Match not found.');\n        const loserBracket = await this.getLoserBracket(match.stage_id);\n        if (!loserBracket)\n            throw Error('Loser bracket not found.');\n        const lastRoundLB = await this.getLastRound(loserBracket.id);\n        const loserBracketFinalMatch = await this.storage.selectFirst('match', {\n            round_id: lastRoundLB.id,\n            number: 1,\n        });\n        if (!loserBracketFinalMatch)\n            throw Error('Match not found.');\n        return [winnerBracketFinalMatch, loserBracketFinalMatch];\n    }\n    /**\n     * Gets the matches leading to a given match from the loser bracket.\n     *\n     * @param match The current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the round.\n     */\n    async getPreviousMatchesLB(match, stage, roundNumber) {\n        if (stage.settings.skipFirstRound && roundNumber === 1)\n            return [];\n        if (helpers.hasBye(match))\n            return []; // Shortcut because we are coming from propagateByes().\n        const winnerBracket = await this.getUpperBracket(match.stage_id);\n        const actualRoundNumberWB = Math.ceil((roundNumber + 1) / 2);\n        const roundNumberWB = stage.settings.skipFirstRound ? actualRoundNumberWB - 1 : actualRoundNumberWB;\n        if (roundNumber === 1)\n            return this.getMatchesBeforeFirstRoundLB(match, winnerBracket.id, roundNumberWB);\n        if (helpers.isMajorRound(roundNumber))\n            return this.getMatchesBeforeMajorRound(match, roundNumber);\n        return this.getMatchesBeforeMinorRoundLB(match, winnerBracket.id, roundNumber, roundNumberWB);\n    }\n    /**\n     * Gets the matches leading to a given match in a major round (every round of upper bracket or specific ones in lower bracket).\n     *\n     * @param match The current match.\n     * @param roundNumber Number of the round.\n     */\n    async getMatchesBeforeMajorRound(match, roundNumber) {\n        return [\n            await this.findMatch(match.group_id, roundNumber - 1, match.number * 2 - 1),\n            await this.findMatch(match.group_id, roundNumber - 1, match.number * 2),\n        ];\n    }\n    /**\n     * Gets the matches leading to a given match in the first round of the loser bracket.\n     *\n     * @param match The current match.\n     * @param winnerBracketId ID of the winner bracket.\n     * @param roundNumberWB The number of the previous round in the winner bracket.\n     */\n    async getMatchesBeforeFirstRoundLB(match, winnerBracketId, roundNumberWB) {\n        return [\n            await this.findMatch(winnerBracketId, roundNumberWB, helpers.getOriginPosition(match, 'opponent1')),\n            await this.findMatch(winnerBracketId, roundNumberWB, helpers.getOriginPosition(match, 'opponent2')),\n        ];\n    }\n    /**\n     * Gets the matches leading to a given match in a minor round of the loser bracket.\n     *\n     * @param match The current match.\n     * @param winnerBracketId ID of the winner bracket.\n     * @param roundNumber Number of the current round.\n     * @param roundNumberWB The number of the previous round in the winner bracket.\n     */\n    async getMatchesBeforeMinorRoundLB(match, winnerBracketId, roundNumber, roundNumberWB) {\n        const matchNumber = helpers.getOriginPosition(match, 'opponent1');\n        return [\n            await this.findMatch(winnerBracketId, roundNumberWB, matchNumber),\n            await this.findMatch(match.group_id, roundNumber - 1, match.number),\n        ];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match will go just after.\n     *\n     * @param match The current match.\n     * @param matchLocation Location of the current match.\n     * @param stage The parent stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatches(match, matchLocation, stage, roundNumber, roundCount) {\n        switch (matchLocation) {\n            case 'single_bracket':\n                return this.getNextMatchesUpperBracket(match, stage, roundNumber, roundCount);\n            case 'winner_bracket':\n                return this.getNextMatchesWB(match, stage, roundNumber, roundCount);\n            case 'loser_bracket':\n                return this.getNextMatchesLB(match, stage, roundNumber, roundCount);\n            case 'final_group':\n                return this.getNextMatchesFinal(match, stage, roundNumber, roundCount);\n            default:\n                throw Error('Unknown bracket kind.');\n        }\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of winner bracket will go just after.\n     *\n     * @param match The current match.\n     * @param stage The parent stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatchesWB(match, stage, roundNumber, roundCount) {\n        const loserBracket = await this.getLoserBracket(match.stage_id);\n        if (loserBracket === null) // Only one match in the stage, there is no loser bracket.\n            return [];\n        const actualRoundNumber = stage.settings.skipFirstRound ? roundNumber + 1 : roundNumber;\n        const roundNumberLB = actualRoundNumber > 1 ? (actualRoundNumber - 1) * 2 : 1;\n        const participantCount = stage.settings.size;\n        const method = helpers.getLoserOrdering(stage.settings.seedOrdering, roundNumberLB);\n        const actualMatchNumberLB = helpers.findLoserMatchNumber(participantCount, roundNumberLB, match.number, method);\n        return [\n            ...await this.getNextMatchesUpperBracket(match, stage, roundNumber, roundCount),\n            await this.findMatch(loserBracket.id, roundNumberLB, actualMatchNumberLB),\n        ];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of an upper bracket will go just after.\n     *\n     * @param match The current match.\n     * @param stage The parent stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatchesUpperBracket(match, stage, roundNumber, roundCount) {\n        if (stage.type === 'single_elimination')\n            return this.getNextMatchesUpperBracketSingleElimination(match, stage.type, roundNumber, roundCount);\n        return this.getNextMatchesUpperBracketDoubleElimination(match, stage.type, roundNumber, roundCount);\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of the unique bracket of a single elimination will go just after.\n     *\n     * @param match The current match.\n     * @param stageType Type of the stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatchesUpperBracketSingleElimination(match, stageType, roundNumber, roundCount) {\n        if (roundNumber === roundCount - 1) {\n            const finalGroupId = await this.getFinalGroupId(match.stage_id, stageType);\n            const consolationFinal = await this.getFinalGroupFirstMatch(finalGroupId);\n            return [\n                await this.getDiagonalMatch(match.group_id, roundNumber, match.number),\n                ...consolationFinal ? [consolationFinal] : [],\n            ];\n        }\n        if (roundNumber === roundCount)\n            return [];\n        return [await this.getDiagonalMatch(match.group_id, roundNumber, match.number)];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of the unique bracket of a double elimination will go just after.\n     *\n     * @param match The current match.\n     * @param stageType Type of the stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatchesUpperBracketDoubleElimination(match, stageType, roundNumber, roundCount) {\n        if (roundNumber === roundCount) {\n            const finalGroupId = await this.getFinalGroupId(match.stage_id, stageType);\n            return [await this.getFinalGroupFirstMatch(finalGroupId)];\n        }\n        return [await this.getDiagonalMatch(match.group_id, roundNumber, match.number)];\n    }\n    /**\n     * Gets the match(es) where the opponents of the current match of loser bracket will go just after.\n     *\n     * @param match The current match.\n     * @param stage The parent stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount Count of rounds.\n     */\n    async getNextMatchesLB(match, stage, roundNumber, roundCount) {\n        if (roundNumber === roundCount - 1) {\n            const finalGroupId = await this.getFinalGroupId(match.stage_id, stage.type);\n            const consolationFinal = await this.getConsolationFinalMatchDoubleElimination(finalGroupId);\n            return [\n                ...await this.getMatchAfterMajorRoundLB(match, roundNumber),\n                ...consolationFinal ? [consolationFinal] : [], // Loser goes in consolation.\n            ];\n        }\n        if (roundNumber === roundCount) {\n            const finalGroupId = await this.getFinalGroupId(match.stage_id, stage.type);\n            const grandFinal = await this.getFinalGroupFirstMatch(finalGroupId);\n            const consolationFinal = await this.getConsolationFinalMatchDoubleElimination(finalGroupId);\n            return [\n                grandFinal,\n                ...consolationFinal ? [consolationFinal] : [], // Returned array is length 1 if no consolation final.\n            ];\n        }\n        if (helpers.isMajorRound(roundNumber))\n            return this.getMatchAfterMajorRoundLB(match, roundNumber);\n        return this.getMatchAfterMinorRoundLB(match, roundNumber);\n    }\n    /**\n     * Gets the first match of the final group (consolation final or grand final).\n     *\n     * @param finalGroupId ID of the final group.\n     */\n    async getFinalGroupFirstMatch(finalGroupId) {\n        if (finalGroupId === null)\n            return null; // `null` is required for `getNextMatchesWB()` because of how `applyToNextMatches()` works.\n        return this.findMatch(finalGroupId, 1, 1);\n    }\n    /**\n     * Gets the consolation final in a double elimination tournament.\n     *\n     * @param finalGroupId ID of the final group.\n     */\n    async getConsolationFinalMatchDoubleElimination(finalGroupId) {\n        if (finalGroupId === null)\n            return null;\n        return this.storage.selectFirst('match', {\n            group_id: finalGroupId,\n            number: 2, // Used to differentiate grand final and consolation final matches in the same final group.\n        });\n    }\n    /**\n     * Gets the match following the current match, which is in the final group (consolation final or grand final).\n     *\n     * @param match The current match.\n     * @param stage The parent stage.\n     * @param roundNumber The number of the current round.\n     * @param roundCount The count of rounds.\n     */\n    async getNextMatchesFinal(match, stage, roundNumber, roundCount) {\n        if (roundNumber === roundCount)\n            return [];\n        if (stage.settings.consolationFinal && match.number === 1 && roundNumber === roundCount - 1)\n            return []; // Current match is the last grand final match.\n        return [await this.findMatch(match.group_id, roundNumber + 1, 1)];\n    }\n    /**\n     * Gets the match where the opponents of the current match of a winner bracket's major round will go just after.\n     *\n     * @param match The current match.\n     * @param roundNumber The number of the current round.\n     */\n    async getMatchAfterMajorRoundLB(match, roundNumber) {\n        return [await this.getParallelMatch(match.group_id, roundNumber, match.number)];\n    }\n    /**\n     * Gets the match where the opponents of the current match of a winner bracket's minor round will go just after.\n     *\n     * @param match The current match.\n     * @param roundNumber The number of the current round.\n     */\n    async getMatchAfterMinorRoundLB(match, roundNumber) {\n        return [await this.getDiagonalMatch(match.group_id, roundNumber, match.number)];\n    }\n    /**\n     * Returns the good seeding ordering based on the stage's type.\n     *\n     * @param stageType The type of the stage.\n     * @param create A reference to a Create instance.\n     */\n    static getSeedingOrdering(stageType, create) {\n        return stageType === 'round_robin' ? create.getRoundRobinOrdering() : create.getStandardBracketFirstRoundOrdering();\n    }\n    /**\n     * Returns the matches which contain the seeding of a stage based on its type.\n     *\n     * @param stageId ID of the stage.\n     * @param stageType The type of the stage.\n     */\n    async getSeedingMatches(stageId, stageType) {\n        if (stageType === 'round_robin')\n            return this.storage.select('match', { stage_id: stageId });\n        try {\n            const firstRound = await this.getUpperBracketFirstRound(stageId);\n            return this.storage.select('match', { round_id: firstRound.id });\n        }\n        catch {\n            return []; // The stage may have not been created yet.\n        }\n    }\n    /**\n     * Gets the first round of the upper bracket.\n     *\n     * @param stageId ID of the stage.\n     */\n    async getUpperBracketFirstRound(stageId) {\n        // Considering the database is ordered, this round will always be the first round of the upper bracket.\n        const firstRound = await this.storage.selectFirst('round', { stage_id: stageId, number: 1 }, false);\n        if (!firstRound)\n            throw Error('Round not found.');\n        return firstRound;\n    }\n    /**\n     * Gets the last round of a group.\n     *\n     * @param groupId ID of the group.\n     */\n    async getLastRound(groupId) {\n        const round = await this.storage.selectLast('round', { group_id: groupId }, false);\n        if (!round)\n            throw Error('Error getting rounds.');\n        return round;\n    }\n    /**\n     * Returns the id of the final group (containing consolation final, or grand final, or both).\n     *\n     * @param stageId ID of the stage.\n     * @param stageType Type of the stage.\n     */\n    async getFinalGroupId(stageId, stageType) {\n        const groupNumber = stageType === 'single_elimination' ? 2 /* single bracket + final */ : 3 /* winner bracket + loser bracket + final */;\n        const finalGroup = await this.storage.selectFirst('group', { stage_id: stageId, number: groupNumber });\n        if (!finalGroup)\n            return null;\n        return finalGroup.id;\n    }\n    /**\n     * Gets the upper bracket (the only bracket if single elimination or the winner bracket in double elimination).\n     *\n     * @param stageId ID of the stage.\n     */\n    async getUpperBracket(stageId) {\n        const winnerBracket = await this.storage.selectFirst('group', { stage_id: stageId, number: 1 });\n        if (!winnerBracket)\n            throw Error('Winner bracket not found.');\n        return winnerBracket;\n    }\n    /**\n     * Gets the loser bracket.\n     *\n     * @param stageId ID of the stage.\n     */\n    async getLoserBracket(stageId) {\n        return this.storage.selectFirst('group', { stage_id: stageId, number: 2 });\n    }\n    /**\n     * Gets the corresponding match in the next round (\"diagonal match\") the usual way.\n     *\n     * Just like from Round 1 to Round 2 in a single elimination stage.\n     *\n     * @param groupId ID of the group.\n     * @param roundNumber Number of the round in its parent group.\n     * @param matchNumber Number of the match in its parent round.\n     */\n    async getDiagonalMatch(groupId, roundNumber, matchNumber) {\n        return this.findMatch(groupId, roundNumber + 1, helpers.getDiagonalMatchNumber(matchNumber));\n    }\n    /**\n     * Gets the corresponding match in the next round (\"parallel match\") the \"major round to minor round\" way.\n     *\n     * Just like from Round 1 to Round 2 in the loser bracket of a double elimination stage.\n     *\n     * @param groupId ID of the group.\n     * @param roundNumber Number of the round in its parent group.\n     * @param matchNumber Number of the match in its parent round.\n     */\n    async getParallelMatch(groupId, roundNumber, matchNumber) {\n        return this.findMatch(groupId, roundNumber + 1, matchNumber);\n    }\n    /**\n     * Finds a match in a given group. The match must have the given number in a round of which the number in group is given.\n     *\n     * **Example:** In group of id 1, give me the 4th match in the 3rd round.\n     *\n     * @param groupId ID of the group.\n     * @param roundNumber Number of the round in its parent group.\n     * @param matchNumber Number of the match in its parent round.\n     */\n    async findMatch(groupId, roundNumber, matchNumber) {\n        const round = await this.storage.selectFirst('round', {\n            group_id: groupId,\n            number: roundNumber,\n        });\n        if (!round)\n            throw Error('Round not found.');\n        const match = await this.storage.selectFirst('match', {\n            round_id: round.id,\n            number: matchNumber,\n        });\n        if (!match)\n            throw Error('Match not found.');\n        return match;\n    }\n    /**\n     * Finds a match game based on its `id` or based on the combination of its `parent_id` and `number`.\n     *\n     * @param game Values to change in a match game.\n     */\n    async findMatchGame(game) {\n        if (game.id !== undefined) {\n            const stored = await this.storage.select('match_game', game.id);\n            if (!stored)\n                throw Error('Match game not found.');\n            return stored;\n        }\n        if (game.parent_id !== undefined && game.number) {\n            const stored = await this.storage.selectFirst('match_game', {\n                parent_id: game.parent_id,\n                number: game.number,\n            });\n            if (!stored)\n                throw Error('Match game not found.');\n            return stored;\n        }\n        throw Error('No match game id nor parent id and number given.');\n    }\n}\nexports.BaseGetter = BaseGetter;\n//# sourceMappingURL=getter.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/base/getter.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/base/stage/creator.js":
/*!******************************************************************!*\
  !*** ./node_modules/brackets-manager/dist/base/stage/creator.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StageCreator = exports.create = void 0;\nconst ordering_1 = __webpack_require__(/*! ../../ordering */ \"./node_modules/brackets-manager/dist/ordering.js\");\nconst helpers = __webpack_require__(/*! ../../helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\n/**\n * Creates a stage.\n *\n * @param this Instance of BracketsManager.\n * @param stage The stage to create.\n */\nasync function create(stage) {\n    const creator = new StageCreator(this.storage, stage);\n    return creator.run();\n}\nexports.create = create;\nclass StageCreator {\n    /**\n     * Creates an instance of StageCreator, which will handle the creation of the stage.\n     *\n     * @param storage The implementation of Storage.\n     * @param stage The stage to create.\n     */\n    constructor(storage, stage) {\n        this.storage = storage;\n        this.stage = stage;\n        this.stage.settings = this.stage.settings || {};\n        this.seedOrdering = [...this.stage.settings.seedOrdering || []];\n        this.updateMode = false;\n        this.enableByesInUpdate = false;\n        if (!this.stage.name)\n            throw Error('You must provide a name for the stage.');\n        if (this.stage.tournamentId === undefined)\n            throw Error('You must provide a tournament id for the stage.');\n        if (stage.type === 'round_robin')\n            this.stage.settings.roundRobinMode = this.stage.settings.roundRobinMode || 'simple';\n        if (stage.type === 'single_elimination')\n            this.stage.settings.consolationFinal = this.stage.settings.consolationFinal || false;\n        if (stage.type === 'double_elimination')\n            this.stage.settings.grandFinal = this.stage.settings.grandFinal || 'none';\n        this.stage.settings.matchesChildCount = this.stage.settings.matchesChildCount || 0;\n    }\n    /**\n     * Run the creation process.\n     */\n    async run() {\n        let stage;\n        switch (this.stage.type) {\n            case 'round_robin':\n                stage = await this.roundRobin();\n                break;\n            case 'single_elimination':\n                stage = await this.singleElimination();\n                break;\n            case 'double_elimination':\n                stage = await this.doubleElimination();\n                break;\n            default:\n                throw Error('Unknown stage type.');\n        }\n        if (stage.id === -1)\n            throw Error('Something went wrong when creating the stage.');\n        await this.ensureSeedOrdering(stage.id);\n        return stage;\n    }\n    /**\n     * Enables the update mode.\n     *\n     * @param stageId ID of the stage.\n     * @param enableByes Whether to use BYEs or TBDs for `null` values in an input seeding.\n     */\n    setExisting(stageId, enableByes) {\n        this.updateMode = true;\n        this.currentStageId = stageId;\n        this.enableByesInUpdate = enableByes;\n    }\n    /**\n     * Creates a round-robin stage.\n     *\n     * Group count must be given. It will distribute participants in groups and rounds.\n     */\n    async roundRobin() {\n        const groups = await this.getRoundRobinGroups();\n        const stage = await this.createStage();\n        for (let i = 0; i < groups.length; i++)\n            await this.createRoundRobinGroup(stage.id, i + 1, groups[i]);\n        return stage;\n    }\n    /**\n     * Creates a single elimination stage.\n     *\n     * One bracket and optionally a consolation final between semi-final losers.\n     */\n    async singleElimination() {\n        var _a, _b;\n        if (Array.isArray((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.seedOrdering) &&\n            ((_b = this.stage.settings) === null || _b === void 0 ? void 0 : _b.seedOrdering.length) !== 1)\n            throw Error('You must specify one seed ordering method.');\n        const slots = await this.getSlots();\n        const stage = await this.createStage();\n        const method = this.getStandardBracketFirstRoundOrdering();\n        const ordered = ordering_1.ordering[method](slots);\n        const { losers } = await this.createStandardBracket(stage.id, 1, ordered);\n        await this.createConsolationFinal(stage.id, losers);\n        return stage;\n    }\n    /**\n     * Creates a double elimination stage.\n     *\n     * One upper bracket (winner bracket, WB), one lower bracket (loser bracket, LB) and optionally a grand final\n     * between the winner of both bracket, which can be simple or double.\n     */\n    async doubleElimination() {\n        var _a;\n        if (this.stage.settings && Array.isArray(this.stage.settings.seedOrdering) &&\n            this.stage.settings.seedOrdering.length < 1)\n            throw Error('You must specify at least one seed ordering method.');\n        const slots = await this.getSlots();\n        const stage = await this.createStage();\n        const method = this.getStandardBracketFirstRoundOrdering();\n        const ordered = ordering_1.ordering[method](slots);\n        if ((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.skipFirstRound)\n            await this.createDoubleEliminationSkipFirstRound(stage.id, ordered);\n        else\n            await this.createDoubleElimination(stage.id, ordered);\n        return stage;\n    }\n    /**\n     * Creates a double elimination stage with skip first round option.\n     *\n     * @param stageId ID of the stage.\n     * @param slots A list of slots.\n     */\n    async createDoubleEliminationSkipFirstRound(stageId, slots) {\n        var _a;\n        const { even: directInWb, odd: directInLb } = helpers.splitByParity(slots);\n        const { losers: losersWb, winner: winnerWb } = await this.createStandardBracket(stageId, 1, directInWb);\n        if (helpers.isDoubleEliminationNecessary((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.size)) {\n            const winnerLb = await this.createLowerBracket(stageId, 2, [directInLb, ...losersWb]);\n            await this.createGrandFinal(stageId, winnerWb, winnerLb);\n        }\n    }\n    /**\n     * Creates a double elimination stage.\n     *\n     * @param stageId ID of the stage.\n     * @param slots A list of slots.\n     */\n    async createDoubleElimination(stageId, slots) {\n        var _a;\n        const { losers: losersWb, winner: winnerWb } = await this.createStandardBracket(stageId, 1, slots);\n        if (helpers.isDoubleEliminationNecessary((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.size)) {\n            const winnerLb = await this.createLowerBracket(stageId, 2, losersWb);\n            const finalGroupId = await this.createGrandFinal(stageId, winnerWb, winnerLb);\n            await this.createConsolationFinal(stageId, losersWb, {\n                existingGroupId: finalGroupId,\n                // Arbitrary way to differentiate the grand final and consolation final matches.\n                // Grand final matches always have had `number: 1`. Now, consolation final matches always have `number: 2`.\n                matchNumberStart: 2,\n            });\n        }\n    }\n    /**\n     * Creates a round-robin group.\n     *\n     * This will make as many rounds as needed to let each participant match every other once.\n     *\n     * @param stageId ID of the parent stage.\n     * @param groupNumber Number of the group in the stage.\n     * @param slots A list of slots.\n     */\n    async createRoundRobinGroup(stageId, groupNumber, slots) {\n        var _a;\n        const groupId = await this.insertGroup({\n            stage_id: stageId,\n            number: groupNumber,\n        });\n        if (groupId === -1)\n            throw Error('Could not insert the group.');\n        const rounds = helpers.makeRoundRobinMatches(slots, (_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.roundRobinMode);\n        for (let i = 0; i < rounds.length; i++)\n            await this.createRound(stageId, groupId, i + 1, rounds[0].length, rounds[i]);\n    }\n    /**\n     * Creates a standard bracket, which is the only one in single elimination and the upper one in double elimination.\n     *\n     * This will make as many rounds as needed to end with one winner.\n     *\n     * @param stageId ID of the parent stage.\n     * @param groupNumber Number of the group in the stage.\n     * @param slots A list of slots.\n     */\n    async createStandardBracket(stageId, groupNumber, slots) {\n        const roundCount = helpers.getUpperBracketRoundCount(slots.length);\n        const groupId = await this.insertGroup({\n            stage_id: stageId,\n            number: groupNumber,\n        });\n        if (groupId === -1)\n            throw Error('Could not insert the group.');\n        let duels = helpers.makePairs(slots);\n        let roundNumber = 1;\n        const losers = [];\n        for (let i = roundCount - 1; i >= 0; i--) {\n            const matchCount = Math.pow(2, i);\n            duels = this.getCurrentDuels(duels, matchCount);\n            losers.push(duels.map(helpers.byeLoser));\n            await this.createRound(stageId, groupId, roundNumber++, matchCount, duels);\n        }\n        return { losers, winner: helpers.byeWinner(duels[0]) };\n    }\n    /**\n     * Creates a lower bracket, alternating between major and minor rounds.\n     *\n     * - A major round is a regular round.\n     * - A minor round matches the previous (major) round's winners against upper bracket losers of the corresponding round.\n     *\n     * @param stageId ID of the parent stage.\n     * @param groupNumber Number of the group in the stage.\n     * @param losers One list of losers per upper bracket round.\n     */\n    async createLowerBracket(stageId, groupNumber, losers) {\n        var _a;\n        const participantCount = (_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.size;\n        const roundPairCount = helpers.getRoundPairCount(participantCount);\n        let losersId = 0;\n        const method = this.getMajorOrdering(participantCount);\n        const ordered = ordering_1.ordering[method](losers[losersId++]);\n        const groupId = await this.insertGroup({\n            stage_id: stageId,\n            number: groupNumber,\n        });\n        if (groupId === -1)\n            throw Error('Could not insert the group.');\n        let duels = helpers.makePairs(ordered);\n        let roundNumber = 1;\n        for (let i = 0; i < roundPairCount; i++) {\n            const matchCount = Math.pow(2, roundPairCount - i - 1);\n            // Major round.\n            duels = this.getCurrentDuels(duels, matchCount, true);\n            await this.createRound(stageId, groupId, roundNumber++, matchCount, duels);\n            // Minor round.\n            const minorOrdering = this.getMinorOrdering(participantCount, i, roundPairCount);\n            duels = this.getCurrentDuels(duels, matchCount, false, losers[losersId++], minorOrdering);\n            await this.createRound(stageId, groupId, roundNumber++, matchCount, duels);\n        }\n        return helpers.byeWinnerToGrandFinal(duels[0]);\n    }\n    /**\n     * Creates a bracket with rounds that only have 1 match each. Used for finals.\n     *\n     * @param stageId ID of the parent stage.\n     * @param groupNumber Number of the group in the stage.\n     * @param duels A list of duels.\n     * @param overrides Optional overrides.\n     */\n    async createUniqueMatchBracket(stageId, groupNumber, duels, overrides = {}) {\n        let groupId = overrides.existingGroupId;\n        let roundNumberStart = 1;\n        if (groupId !== undefined) {\n            const rounds = await this.storage.select('round', { group_id: groupId });\n            if (!rounds)\n                throw Error('Error getting rounds.');\n            // When we add rounds to an existing group, we resume the round numbering.\n            roundNumberStart = rounds.length + 1;\n        }\n        else {\n            groupId = await this.insertGroup({\n                stage_id: stageId,\n                number: groupNumber,\n            });\n            if (groupId === -1)\n                throw Error('Could not insert the group.');\n        }\n        for (let i = 0; i < duels.length; i++)\n            await this.createRound(stageId, groupId, roundNumberStart + i, 1, [duels[i]], overrides.matchNumberStart);\n        return groupId;\n    }\n    /**\n     * Creates a round, which contain matches.\n     *\n     * @param stageId ID of the parent stage.\n     * @param groupId ID of the parent group.\n     * @param roundNumber Number in the group.\n     * @param matchCount Duel/match count.\n     * @param duels A list of duels.\n     * @param matchNumberStart Optionally give the starting point for the match numbers. Starts at 1 by default.\n     */\n    async createRound(stageId, groupId, roundNumber, matchCount, duels, matchNumberStart = 1) {\n        const matchesChildCount = this.getMatchesChildCount();\n        const roundId = await this.insertRound({\n            number: roundNumber,\n            stage_id: stageId,\n            group_id: groupId,\n        });\n        if (roundId === -1)\n            throw Error('Could not insert the round.');\n        for (let i = 0; i < matchCount; i++)\n            await this.createMatch(stageId, groupId, roundId, matchNumberStart + i, duels[i], matchesChildCount);\n    }\n    /**\n     * Creates a match, possibly with match games.\n     *\n     * - If `childCount` is 0, then there is no children. The score of the match is directly its intrinsic score.\n     * - If `childCount` is greater than 0, then the score of the match will automatically be calculated based on its child games.\n     *\n     * @param stageId ID of the parent stage.\n     * @param groupId ID of the parent group.\n     * @param roundId ID of the parent round.\n     * @param matchNumber Number in the round.\n     * @param opponents The two opponents matching against each other.\n     * @param childCount Child count for this match (number of games).\n     */\n    async createMatch(stageId, groupId, roundId, matchNumber, opponents, childCount) {\n        const opponent1 = helpers.toResultWithPosition(opponents[0]);\n        const opponent2 = helpers.toResultWithPosition(opponents[1]);\n        // Round-robin matches can easily be removed. Prevent BYE vs. BYE matches.\n        if (this.stage.type === 'round_robin' && opponent1 === null && opponent2 === null)\n            return;\n        let existing = null;\n        let status = helpers.getMatchStatus(opponents);\n        if (this.updateMode) {\n            existing = await this.storage.selectFirst('match', {\n                round_id: roundId,\n                number: matchNumber,\n            });\n            const currentChildCount = existing === null || existing === void 0 ? void 0 : existing.child_count;\n            childCount = currentChildCount === undefined ? childCount : currentChildCount;\n            if (existing) {\n                // Keep the most advanced status when updating a match.\n                const existingStatus = helpers.getMatchStatus(existing);\n                if (existingStatus > status)\n                    status = existingStatus;\n            }\n        }\n        const parentId = await this.insertMatch({\n            number: matchNumber,\n            stage_id: stageId,\n            group_id: groupId,\n            round_id: roundId,\n            child_count: childCount,\n            status: status,\n            ...helpers.getInferredResult(opponent1, opponent2),\n        }, existing);\n        if (parentId === -1)\n            throw Error('Could not insert the match.');\n        for (let i = 0; i < childCount; i++) {\n            const id = await this.insertMatchGame({\n                number: i + 1,\n                stage_id: stageId,\n                parent_id: parentId,\n                status: status,\n                ...helpers.getInferredResult(helpers.toResult(opponents[0]), helpers.toResult(opponents[1])),\n            });\n            if (id === -1)\n                throw Error('Could not insert the match game.');\n        }\n    }\n    /**\n     * Generic implementation.\n     *\n     * @param previousDuels Always given.\n     * @param currentDuelCount Always given.\n     * @param major Only for loser bracket.\n     * @param losers Only for minor rounds of loser bracket.\n     * @param method Only for minor rounds. Ordering method for the losers.\n     */\n    getCurrentDuels(previousDuels, currentDuelCount, major, losers, method) {\n        if ((major === undefined || major) && previousDuels.length === currentDuelCount) {\n            // First round.\n            return previousDuels;\n        }\n        if (major === undefined || major) {\n            // From major to major (WB) or minor to major (LB).\n            return helpers.transitionToMajor(previousDuels);\n        }\n        // From major to minor (LB).\n        // Losers and method won't be undefined.\n        return helpers.transitionToMinor(previousDuels, losers, method);\n    }\n    /**\n     * Returns a list of slots.\n     * - If `seeding` was given, inserts them in the storage.\n     * - If `size` was given, only returns a list of empty slots.\n     *\n     * @param positions An optional list of positions (seeds) for a manual ordering.\n     */\n    async getSlots(positions) {\n        var _a;\n        let seeding = this.stage.seedingIds || this.stage.seeding;\n        const size = ((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.size) || (seeding === null || seeding === void 0 ? void 0 : seeding.length) || 0;\n        helpers.ensureValidSize(this.stage.type, size);\n        if (size && !seeding)\n            return Array.from({ length: size }, (_, i) => ({ id: null, position: i + 1 }));\n        if (!seeding)\n            throw Error('Either size or seeding must be given.');\n        this.stage.settings = {\n            ...this.stage.settings,\n            size, // Always set the size.\n        };\n        helpers.ensureNoDuplicates(seeding);\n        seeding = helpers.fixSeeding(seeding, size);\n        if (this.stage.type !== 'round_robin' && this.stage.settings.balanceByes)\n            seeding = helpers.balanceByes(seeding, this.stage.settings.size);\n        this.stage.seeding = seeding;\n        if (this.stage.seedingIds !== undefined || helpers.isSeedingWithIds(seeding))\n            return this.getSlotsUsingIds(seeding, positions);\n        return this.getSlotsUsingNames(seeding, positions);\n    }\n    /**\n     * Returns the list of slots with a seeding containing names. Participants may be added to database.\n     *\n     * @param seeding The seeding (names).\n     * @param positions An optional list of positions (seeds) for a manual ordering.\n     */\n    async getSlotsUsingNames(seeding, positions) {\n        const participants = helpers.extractParticipantsFromSeeding(this.stage.tournamentId, seeding);\n        if (!await this.registerParticipants(participants))\n            throw Error('Error registering the participants.');\n        // Get participants back with IDs.\n        const added = await this.storage.select('participant', { tournament_id: this.stage.tournamentId });\n        if (!added)\n            throw Error('Error getting registered participant.');\n        return helpers.mapParticipantsNamesToDatabase(seeding, added, positions);\n    }\n    /**\n     * Returns the list of slots with a seeding containing IDs. No database mutation.\n     *\n     * @param seeding The seeding (IDs).\n     * @param positions An optional list of positions (seeds) for a manual ordering.\n     */\n    async getSlotsUsingIds(seeding, positions) {\n        const participants = await this.storage.select('participant', { tournament_id: this.stage.tournamentId });\n        if (!participants)\n            throw Error('No available participants.');\n        return helpers.mapParticipantsIdsToDatabase(seeding, participants, positions);\n    }\n    /**\n     * Gets the current stage number based on existing stages.\n     */\n    async getStageNumber() {\n        const stages = await this.storage.select('stage', { tournament_id: this.stage.tournamentId });\n        const stageNumbers = stages === null || stages === void 0 ? void 0 : stages.map(stage => { var _a; return (_a = stage.number) !== null && _a !== void 0 ? _a : 0; });\n        if (this.stage.number !== undefined) {\n            if (stageNumbers === null || stageNumbers === void 0 ? void 0 : stageNumbers.includes(this.stage.number))\n                throw Error('The given stage number already exists.');\n            return this.stage.number;\n        }\n        if (!(stageNumbers === null || stageNumbers === void 0 ? void 0 : stageNumbers.length))\n            return 1;\n        const maxNumber = Math.max(...stageNumbers);\n        return maxNumber + 1;\n    }\n    /**\n     * Safely gets `matchesChildCount` in the stage input settings.\n     */\n    getMatchesChildCount() {\n        var _a;\n        if (!((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.matchesChildCount))\n            return 0;\n        return this.stage.settings.matchesChildCount;\n    }\n    /**\n     * Safely gets an ordering by its index in the stage input settings.\n     *\n     * @param orderingIndex Index of the ordering.\n     * @param stageType A value indicating if the method should be a group method or not.\n     * @param defaultMethod The default method to use if not given.\n     */\n    getOrdering(orderingIndex, stageType, defaultMethod) {\n        var _a;\n        if (!((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.seedOrdering)) {\n            this.seedOrdering.push(defaultMethod);\n            return defaultMethod;\n        }\n        const method = this.stage.settings.seedOrdering[orderingIndex];\n        if (!method) {\n            this.seedOrdering.push(defaultMethod);\n            return defaultMethod;\n        }\n        if (stageType === 'elimination' && method.match(/^groups\\./))\n            throw Error('You must specify a seed ordering method without a \\'groups\\' prefix');\n        if (stageType === 'groups' && method !== 'natural' && !method.match(/^groups\\./))\n            throw Error('You must specify a seed ordering method with a \\'groups\\' prefix');\n        return method;\n    }\n    /**\n     * Gets the duels in groups for a round-robin stage.\n     */\n    async getRoundRobinGroups() {\n        var _a, _b, _c, _d, _e;\n        if (((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.groupCount) === undefined || !Number.isInteger(this.stage.settings.groupCount))\n            throw Error('You must specify a group count for round-robin stages.');\n        if (this.stage.settings.groupCount <= 0)\n            throw Error('You must provide a strictly positive group count.');\n        if ((_b = this.stage.settings) === null || _b === void 0 ? void 0 : _b.manualOrdering) {\n            if (((_c = this.stage.settings) === null || _c === void 0 ? void 0 : _c.manualOrdering.length) !== ((_d = this.stage.settings) === null || _d === void 0 ? void 0 : _d.groupCount))\n                throw Error('Group count in the manual ordering does not correspond to the given group count.');\n            const positions = (_e = this.stage.settings) === null || _e === void 0 ? void 0 : _e.manualOrdering.flat();\n            const slots = await this.getSlots(positions);\n            return helpers.makeGroups(slots, this.stage.settings.groupCount);\n        }\n        if (Array.isArray(this.stage.settings.seedOrdering) && this.stage.settings.seedOrdering.length !== 1)\n            throw Error('You must specify one seed ordering method.');\n        const method = this.getRoundRobinOrdering();\n        const slots = await this.getSlots();\n        const ordered = ordering_1.ordering[method](slots, this.stage.settings.groupCount);\n        return helpers.makeGroups(ordered, this.stage.settings.groupCount);\n    }\n    /**\n     * Returns the ordering method for the groups in a round-robin stage.\n     */\n    getRoundRobinOrdering() {\n        return this.getOrdering(0, 'groups', 'groups.effort_balanced');\n    }\n    /**\n     * Returns the ordering method for the first round of the upper bracket of an elimination stage.\n     */\n    getStandardBracketFirstRoundOrdering() {\n        return this.getOrdering(0, 'elimination', 'inner_outer');\n    }\n    /**\n     * Safely gets the only major ordering for the lower bracket.\n     *\n     * @param participantCount Number of participants in the stage.\n     */\n    getMajorOrdering(participantCount) {\n        var _a;\n        return this.getOrdering(1, 'elimination', ((_a = ordering_1.defaultMinorOrdering[participantCount]) === null || _a === void 0 ? void 0 : _a[0]) || 'natural');\n    }\n    /**\n     * Safely gets a minor ordering for the lower bracket by its index.\n     *\n     * @param participantCount Number of participants in the stage.\n     * @param index Index of the minor round.\n     * @param minorRoundCount Number of minor rounds.\n     */\n    getMinorOrdering(participantCount, index, minorRoundCount) {\n        var _a;\n        // No ordering for the last minor round. There is only one participant to order.\n        if (index === minorRoundCount - 1)\n            return undefined;\n        return this.getOrdering(2 + index, 'elimination', ((_a = ordering_1.defaultMinorOrdering[participantCount]) === null || _a === void 0 ? void 0 : _a[1 + index]) || 'natural');\n    }\n    /**\n     * Inserts a stage or finds an existing one.\n     *\n     * @param stage The stage to insert.\n     */\n    async insertStage(stage) {\n        let existing = null;\n        if (this.updateMode) {\n            existing = await this.storage.select('stage', this.currentStageId);\n            if (!existing)\n                throw Error('Stage not found.');\n            const update = {\n                ...existing,\n                ...stage,\n                settings: {\n                    ...existing.settings,\n                    ...stage.settings,\n                },\n            };\n            if (!await this.storage.update('stage', this.currentStageId, update))\n                throw Error('Could not update the stage.');\n        }\n        if (!existing)\n            return this.storage.insert('stage', stage);\n        return existing.id;\n    }\n    /**\n     * Inserts a group or finds an existing one.\n     *\n     * @param group The group to insert.\n     */\n    async insertGroup(group) {\n        let existing = null;\n        if (this.updateMode) {\n            existing = await this.storage.selectFirst('group', {\n                stage_id: group.stage_id,\n                number: group.number,\n            });\n        }\n        if (!existing)\n            return this.storage.insert('group', group);\n        return existing.id;\n    }\n    /**\n     * Inserts a round or finds an existing one.\n     *\n     * @param round The round to insert.\n     */\n    async insertRound(round) {\n        let existing = null;\n        if (this.updateMode) {\n            existing = await this.storage.selectFirst('round', {\n                group_id: round.group_id,\n                number: round.number,\n            });\n        }\n        if (!existing)\n            return this.storage.insert('round', round);\n        return existing.id;\n    }\n    /**\n     * Inserts a match or updates an existing one.\n     *\n     * @param match The match to insert.\n     * @param existing An existing match corresponding to the current one.\n     */\n    async insertMatch(match, existing) {\n        if (!existing)\n            return this.storage.insert('match', match);\n        const updated = helpers.getUpdatedMatchResults(match, existing, this.enableByesInUpdate);\n        if (!await this.storage.update('match', existing.id, updated))\n            throw Error('Could not update the match.');\n        return existing.id;\n    }\n    /**\n     * Inserts a match game or finds an existing one (and updates it).\n     *\n     * @param matchGame The match game to insert.\n     */\n    async insertMatchGame(matchGame) {\n        let existing = null;\n        if (this.updateMode) {\n            existing = await this.storage.selectFirst('match_game', {\n                parent_id: matchGame.parent_id,\n                number: matchGame.number,\n            });\n        }\n        if (!existing)\n            return this.storage.insert('match_game', matchGame);\n        const updated = helpers.getUpdatedMatchResults(matchGame, existing, this.enableByesInUpdate);\n        if (!await this.storage.update('match_game', existing.id, updated))\n            throw Error('Could not update the match game.');\n        return existing.id;\n    }\n    /**\n     * Inserts missing participants.\n     *\n     * @param participants The list of participants to process.\n     */\n    async registerParticipants(participants) {\n        const existing = await this.storage.select('participant', { tournament_id: this.stage.tournamentId });\n        // Insert all if nothing.\n        if (!existing || existing.length === 0)\n            return this.storage.insert('participant', participants);\n        // Insert only missing otherwise.\n        for (const participant of participants) {\n            if (existing.some(value => value.name === participant.name))\n                continue;\n            const result = await this.storage.insert('participant', participant);\n            if (result === -1)\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Creates a new stage.\n     */\n    async createStage() {\n        const stageNumber = await this.getStageNumber();\n        const stage = {\n            tournament_id: this.stage.tournamentId,\n            name: this.stage.name,\n            type: this.stage.type,\n            number: stageNumber,\n            settings: this.stage.settings || {},\n        };\n        const stageId = await this.insertStage(stage);\n        if (stageId === -1)\n            throw Error('Could not insert the stage.');\n        return { ...stage, id: stageId };\n    }\n    /**\n     * Creates a consolation final for the semi final losers of an upper bracket (single or double elimination).\n     *\n     * @param stageId ID of the stage.\n     * @param losers The semi final losers who will play the consolation final.\n     * @param overrides Optional overrides.\n     */\n    async createConsolationFinal(stageId, losers, overrides = {}) {\n        var _a;\n        if (!((_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.consolationFinal))\n            return;\n        const semiFinalLosers = losers[losers.length - 2];\n        await this.createUniqueMatchBracket(stageId, 2, [semiFinalLosers], overrides);\n    }\n    /**\n     * Creates a grand final (none, simple or double) for winners of both bracket in a double elimination stage.\n     *\n     * @param stageId ID of the stage.\n     * @param winnerWb The winner of the winner bracket.\n     * @param winnerLb The winner of the loser bracket.\n     */\n    async createGrandFinal(stageId, winnerWb, winnerLb) {\n        var _a;\n        // No Grand Final by default.\n        const grandFinal = (_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.grandFinal;\n        if (grandFinal === 'none')\n            return;\n        // One duel by default.\n        const finalDuels = [[winnerWb, winnerLb]];\n        // Second duel.\n        if (grandFinal === 'double')\n            finalDuels.push([{ id: null }, { id: null }]);\n        const groupId = await this.createUniqueMatchBracket(stageId, 3, finalDuels);\n        return groupId;\n    }\n    /**\n     * Ensures that the seed ordering list is stored even if it was not given in the first place.\n     *\n     * @param stageId ID of the stage.\n     */\n    async ensureSeedOrdering(stageId) {\n        var _a, _b;\n        if (((_b = (_a = this.stage.settings) === null || _a === void 0 ? void 0 : _a.seedOrdering) === null || _b === void 0 ? void 0 : _b.length) === this.seedOrdering.length)\n            return;\n        const existing = await this.storage.select('stage', stageId);\n        if (!existing)\n            throw Error('Stage not found.');\n        const update = {\n            ...existing,\n            settings: {\n                ...existing.settings,\n                seedOrdering: this.seedOrdering,\n            },\n        };\n        if (!await this.storage.update('stage', stageId, update))\n            throw Error('Could not update the stage.');\n    }\n}\nexports.StageCreator = StageCreator;\n//# sourceMappingURL=creator.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/base/stage/creator.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/base/updater.js":
/*!************************************************************!*\
  !*** ./node_modules/brackets-manager/dist/base/updater.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseUpdater = void 0;\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst ordering_1 = __webpack_require__(/*! ../ordering */ \"./node_modules/brackets-manager/dist/ordering.js\");\nconst creator_1 = __webpack_require__(/*! ./stage/creator */ \"./node_modules/brackets-manager/dist/base/stage/creator.js\");\nconst getter_1 = __webpack_require__(/*! ./getter */ \"./node_modules/brackets-manager/dist/base/getter.js\");\nconst get_1 = __webpack_require__(/*! ../get */ \"./node_modules/brackets-manager/dist/get.js\");\nconst helpers = __webpack_require__(/*! ../helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass BaseUpdater extends getter_1.BaseGetter {\n    /**\n     * Updates or resets the seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     * @param seeding A new seeding or `null` to reset the existing seeding.\n     * @param seeding.seeding Can contain names, IDs or BYEs.\n     * @param seeding.seedingIds Can only contain IDs or BYEs.\n     * @param keepSameSize Whether to keep the same size as before for the stage.\n     */\n    async updateSeeding(stageId, { seeding, seedingIds }, keepSameSize) {\n        var _a, _b;\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        const newSize = keepSameSize ? stage.settings.size : (_b = (_a = (seedingIds || seeding)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;\n        const creator = new creator_1.StageCreator(this.storage, {\n            name: stage.name,\n            tournamentId: stage.tournament_id,\n            type: stage.type,\n            settings: {\n                ...stage.settings,\n                ...(newSize === 0 ? {} : { size: newSize }), // Just reset the seeding if the new size is going to be empty.\n            },\n            ...((seedingIds ? { seedingIds } : { seeding: seeding !== null && seeding !== void 0 ? seeding : undefined })),\n        });\n        creator.setExisting(stageId, false);\n        const method = getter_1.BaseGetter.getSeedingOrdering(stage.type, creator);\n        const slots = await creator.getSlots();\n        const matches = await this.getSeedingMatches(stage.id, stage.type);\n        if (!matches)\n            throw Error('Error getting matches associated to the seeding.');\n        const ordered = ordering_1.ordering[method](slots);\n        BaseUpdater.assertCanUpdateSeeding(matches, ordered);\n        await creator.run();\n    }\n    /**\n     * Confirms the current seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async confirmCurrentSeeding(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        const get = new get_1.Get(this.storage);\n        const currentSeeding = await get.seeding(stageId);\n        const newSeeding = helpers.convertSlotsToSeeding(currentSeeding.map(helpers.convertTBDtoBYE));\n        const creator = new creator_1.StageCreator(this.storage, {\n            name: stage.name,\n            tournamentId: stage.tournament_id,\n            type: stage.type,\n            settings: stage.settings,\n            seeding: newSeeding,\n        });\n        creator.setExisting(stageId, true);\n        await creator.run();\n    }\n    /**\n     * Updates a parent match based on its child games.\n     *\n     * @param parentId ID of the parent match.\n     * @param inRoundRobin Indicates whether the parent match is in a round-robin stage.\n     */\n    async updateParentMatch(parentId, inRoundRobin) {\n        const storedParent = await this.storage.select('match', parentId);\n        if (!storedParent)\n            throw Error('Parent not found.');\n        const games = await this.storage.select('match_game', { parent_id: parentId });\n        if (!games)\n            throw Error('No match games.');\n        const parentScores = helpers.getChildGamesResults(games);\n        const parent = helpers.getParentMatchResults(storedParent, parentScores);\n        helpers.setParentMatchCompleted(parent, storedParent.child_count, inRoundRobin);\n        await this.updateMatch(storedParent, parent, true);\n    }\n    /**\n     * Throws an error if a match is locked and the new seeding will change this match's participants.\n     *\n     * @param matches The matches stored in the database.\n     * @param slots The slots to check from the new seeding.\n     */\n    static assertCanUpdateSeeding(matches, slots) {\n        var _a, _b;\n        let index = 0;\n        for (const match of matches) {\n            // Changing the seeding would reset the matches of round >= 2, leaving the scores behind, with no participants.\n            if (match.status === brackets_model_1.Status.Archived)\n                throw Error('A match of round 1 is archived, which means round 2 was started.');\n            const opponent1 = slots[index++];\n            const opponent2 = slots[index++];\n            const isParticipantLocked = helpers.isMatchParticipantLocked(match);\n            // The match is participant locked, and the participants would have to change.\n            if (isParticipantLocked && (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.id) !== (opponent1 === null || opponent1 === void 0 ? void 0 : opponent1.id) || ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.id) !== (opponent2 === null || opponent2 === void 0 ? void 0 : opponent2.id)))\n                throw Error('A match is locked.');\n        }\n    }\n    /**\n     * Updates the matches related (previous and next) to a match.\n     *\n     * @param match A match.\n     * @param updatePrevious Whether to update the previous matches.\n     * @param updateNext Whether to update the next matches.\n     */\n    async updateRelatedMatches(match, updatePrevious, updateNext) {\n        // This is a consolation match (doesn't have a `group_id`, nor a `round_id`).\n        // It doesn't have any related matches from the POV of the library, because the \n        // creation of consolation matches is handled by the user.\n        if (match.round_id === undefined)\n            return;\n        const { roundNumber, roundCount } = await this.getRoundPositionalInfo(match.round_id);\n        const stage = await this.storage.select('stage', match.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const group = await this.storage.select('group', match.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const matchLocation = helpers.getMatchLocation(stage.type, group.number);\n        updatePrevious && await this.updatePrevious(match, matchLocation, stage, roundNumber);\n        updateNext && await this.updateNext(match, matchLocation, stage, roundNumber, roundCount);\n    }\n    /**\n     * Updates a match based on a partial match.\n     *\n     * @param stored A reference to what will be updated in the storage.\n     * @param match Input of the update.\n     * @param force Whether to force update locked matches.\n     */\n    async updateMatch(stored, match, force) {\n        if (!force && helpers.isMatchUpdateLocked(stored))\n            throw Error('The match is locked.');\n        const stage = await this.storage.select('stage', stored.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const inRoundRobin = helpers.isRoundRobin(stage);\n        const { statusChanged, resultChanged } = helpers.setMatchResults(stored, match, inRoundRobin);\n        await this.applyMatchUpdate(stored);\n        // Don't update related matches if it's a simple score update.\n        if (!statusChanged && !resultChanged)\n            return;\n        if (!helpers.isRoundRobin(stage))\n            await this.updateRelatedMatches(stored, statusChanged, resultChanged);\n    }\n    /**\n     * Updates a match game based on a partial match game.\n     *\n     * @param stored A reference to what will be updated in the storage.\n     * @param game Input of the update.\n     */\n    async updateMatchGame(stored, game) {\n        if (helpers.isMatchUpdateLocked(stored))\n            throw Error('The match game is locked.');\n        const stage = await this.storage.select('stage', stored.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const inRoundRobin = helpers.isRoundRobin(stage);\n        helpers.setMatchResults(stored, game, inRoundRobin);\n        if (!await this.storage.update('match_game', stored.id, stored))\n            throw Error('Could not update the match game.');\n        await this.updateParentMatch(stored.parent_id, inRoundRobin);\n    }\n    /**\n     * Updates the opponents and status of a match and its child games.\n     *\n     * @param match A match.\n     */\n    async applyMatchUpdate(match) {\n        if (!await this.storage.update('match', match.id, match))\n            throw Error('Could not update the match.');\n        if (match.child_count === 0)\n            return;\n        const updatedMatchGame = {\n            opponent1: helpers.toResult(match.opponent1),\n            opponent2: helpers.toResult(match.opponent2),\n        };\n        // Only sync the child games' status with their parent's status when changing the parent match participants\n        // (Locked, Waiting, Ready) or when archiving the parent match.\n        if (match.status <= brackets_model_1.Status.Ready || match.status === brackets_model_1.Status.Archived)\n            updatedMatchGame.status = match.status;\n        if (!await this.storage.update('match_game', { parent_id: match.id }, updatedMatchGame))\n            throw Error('Could not update the match game.');\n    }\n    /**\n     * Updates the match(es) leading to the current match based on this match results.\n     *\n     * @param match Input of the update.\n     * @param matchLocation Location of the current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the round.\n     */\n    async updatePrevious(match, matchLocation, stage, roundNumber) {\n        const previousMatches = await this.getPreviousMatches(match, matchLocation, stage, roundNumber);\n        if (previousMatches.length === 0)\n            return;\n        if (match.status >= brackets_model_1.Status.Running)\n            await this.archiveMatches(previousMatches);\n        else\n            await this.resetMatchesStatus(previousMatches);\n    }\n    /**\n     * Sets the status of a list of matches to archived.\n     *\n     * @param matches The matches to update.\n     */\n    async archiveMatches(matches) {\n        for (const match of matches) {\n            if (match.status === brackets_model_1.Status.Archived)\n                continue;\n            match.status = brackets_model_1.Status.Archived;\n            await this.applyMatchUpdate(match);\n        }\n    }\n    /**\n     * Resets the status of a list of matches to what it should currently be.\n     *\n     * @param matches The matches to update.\n     */\n    async resetMatchesStatus(matches) {\n        for (const match of matches) {\n            match.status = helpers.getMatchStatus(match);\n            await this.applyMatchUpdate(match);\n        }\n    }\n    /**\n     * Updates the match(es) following the current match based on this match results.\n     *\n     * @param match Input of the update.\n     * @param matchLocation Location of the current match.\n     * @param stage The parent stage.\n     * @param roundNumber Number of the round.\n     * @param roundCount Count of rounds.\n     */\n    async updateNext(match, matchLocation, stage, roundNumber, roundCount) {\n        const nextMatches = await this.getNextMatches(match, matchLocation, stage, roundNumber, roundCount);\n        if (nextMatches.length === 0) {\n            // Archive match if it doesn't have following matches and is completed.\n            // When the stage is fully complete, all matches should be archived.\n            if (match.status === brackets_model_1.Status.Completed)\n                await this.archiveMatches([match]);\n            return;\n        }\n        const winnerSide = helpers.getMatchResult(match);\n        const actualRoundNumber = (stage.settings.skipFirstRound && matchLocation === 'winner_bracket') ? roundNumber + 1 : roundNumber;\n        if (winnerSide)\n            await this.applyToNextMatches(helpers.setNextOpponent, match, matchLocation, actualRoundNumber, roundCount, nextMatches, winnerSide);\n        else\n            await this.applyToNextMatches(helpers.resetNextOpponent, match, matchLocation, actualRoundNumber, roundCount, nextMatches);\n    }\n    /**\n     * Applies a `SetNextOpponent` function to matches following the current match.\n     *\n     * - `nextMatches[0]` is assumed to be next match for the winner of the current match.\n     * - `nextMatches[1]` is assumed to be next match for the loser of the current match.\n     *\n     * @param setNextOpponent The `SetNextOpponent` function.\n     * @param match The current match.\n     * @param matchLocation Location of the current match.\n     * @param roundNumber Number of the current round.\n     * @param roundCount Count of rounds.\n     * @param nextMatches The matches following the current match.\n     * @param winnerSide Side of the winner in the current match.\n     */\n    async applyToNextMatches(setNextOpponent, match, matchLocation, roundNumber, roundCount, nextMatches, winnerSide) {\n        if (matchLocation === 'final_group') {\n            if (!nextMatches[0])\n                throw Error('First next match is null.');\n            setNextOpponent(nextMatches[0], 'opponent1', match, 'opponent1');\n            setNextOpponent(nextMatches[0], 'opponent2', match, 'opponent2');\n            await this.applyMatchUpdate(nextMatches[0]);\n            return;\n        }\n        const nextSide = helpers.getNextSide(match.number, roundNumber, roundCount, matchLocation);\n        // First next match\n        if (nextMatches[0]) {\n            setNextOpponent(nextMatches[0], nextSide, match, winnerSide);\n            await this.propagateByeWinners(nextMatches[0]);\n        }\n        if (nextMatches.length !== 2)\n            return;\n        if (!nextMatches[1])\n            throw Error('Second next match is null.');\n        // Second next match\n        if (matchLocation === 'single_bracket') {\n            // Going into consolation final (single elimination)\n            setNextOpponent(nextMatches[1], nextSide, match, winnerSide && helpers.getOtherSide(winnerSide));\n            await this.applyMatchUpdate(nextMatches[1]);\n        }\n        else if (matchLocation === 'winner_bracket') {\n            // Going into loser bracket match (double elimination)\n            const nextSideIntoLB = helpers.getNextSideLoserBracket(match.number, nextMatches[1], roundNumber);\n            setNextOpponent(nextMatches[1], nextSideIntoLB, match, winnerSide && helpers.getOtherSide(winnerSide));\n            await this.propagateByeWinners(nextMatches[1]);\n        }\n        else if (matchLocation === 'loser_bracket') {\n            // Going into consolation final (double elimination)\n            const nextSideIntoConsolationFinal = helpers.getNextSideConsolationFinalDoubleElimination(roundNumber);\n            setNextOpponent(nextMatches[1], nextSideIntoConsolationFinal, match, winnerSide && helpers.getOtherSide(winnerSide));\n            await this.propagateByeWinners(nextMatches[1]);\n        }\n    }\n    /**\n     * Propagates winner against BYEs in related matches.\n     *\n     * @param match The current match.\n     */\n    async propagateByeWinners(match) {\n        helpers.setMatchResults(match, match, false); // BYE propagation is only in non round-robin stages.\n        await this.applyMatchUpdate(match);\n        if (helpers.hasBye(match))\n            await this.updateRelatedMatches(match, true, true);\n    }\n}\nexports.BaseUpdater = BaseUpdater;\n//# sourceMappingURL=updater.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/base/updater.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/create.js":
/*!******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/create.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Create = void 0;\nconst creator_1 = __webpack_require__(/*! ./base/stage/creator */ \"./node_modules/brackets-manager/dist/base/stage/creator.js\");\nclass Create {\n    /**\n     * Creates an instance of Create.\n     *\n     * @param storage The implementation of Storage.\n     */\n    constructor(storage) {\n        this.storage = storage;\n    }\n    /**\n     * Creates a stage for an existing tournament. The tournament won't be created.\n     *\n     * @param data The stage to create.\n     */\n    async stage(data) {\n        const creator = new creator_1.StageCreator(this.storage, data);\n        return creator.run();\n    }\n}\nexports.Create = Create;\n//# sourceMappingURL=create.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/create.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/delete.js":
/*!******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/delete.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Delete = void 0;\nclass Delete {\n    /**\n     * Creates an instance of Delete, which will handle cleanly deleting data in the storage.\n     *\n     * @param storage The implementation of Storage.\n     */\n    constructor(storage) {\n        this.storage = storage;\n    }\n    /**\n     * Deletes a stage, and all its components:\n     *\n     * - Groups\n     * - Rounds\n     * - Matches\n     * - Match games\n     *\n     * @param stageId ID of the stage.\n     */\n    async stage(stageId) {\n        // The order is important here, because the abstract storage can possibly have foreign key checks (e.g. SQL).\n        if (!await this.storage.delete('match_game', { stage_id: stageId }))\n            throw Error('Could not delete match games.');\n        if (!await this.storage.delete('match', { stage_id: stageId }))\n            throw Error('Could not delete matches.');\n        if (!await this.storage.delete('round', { stage_id: stageId }))\n            throw Error('Could not delete rounds.');\n        if (!await this.storage.delete('group', { stage_id: stageId }))\n            throw Error('Could not delete groups.');\n        if (!await this.storage.delete('stage', { id: stageId }))\n            throw Error('Could not delete the stage.');\n    }\n    /**\n     * Deletes **the stages** of a tournament (and all their components, see {@link stage | delete.stage()}).\n     *\n     * You are responsible for deleting the tournament itself.\n     *\n     * @param tournamentId ID of the tournament.\n     */\n    async tournament(tournamentId) {\n        const stages = await this.storage.select('stage', { tournament_id: tournamentId });\n        if (!stages)\n            throw Error('Error getting the stages.');\n        // Not doing this in a `Promise.all()` since this can be a heavy operation.\n        for (const stage of stages)\n            await this.stage(stage.id);\n    }\n}\nexports.Delete = Delete;\n//# sourceMappingURL=delete.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/delete.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/find.js":
/*!****************************************************!*\
  !*** ./node_modules/brackets-manager/dist/find.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Find = void 0;\nconst getter_1 = __webpack_require__(/*! ./base/getter */ \"./node_modules/brackets-manager/dist/base/getter.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass Find extends getter_1.BaseGetter {\n    /**\n     * Gets the upper bracket (the only bracket if single elimination or the winner bracket in double elimination).\n     *\n     * @param stageId ID of the stage.\n     */\n    async upperBracket(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        switch (stage.type) {\n            case 'round_robin':\n                throw Error('Round-robin stages do not have an upper bracket.');\n            case 'single_elimination':\n            case 'double_elimination':\n                return this.getUpperBracket(stageId);\n            default:\n                throw Error('Unknown stage type.');\n        }\n    }\n    /**\n     * Gets the loser bracket.\n     *\n     * @param stageId ID of the stage.\n     */\n    async loserBracket(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        switch (stage.type) {\n            case 'round_robin':\n                throw Error('Round-robin stages do not have a loser bracket.');\n            case 'single_elimination':\n                throw Error('Single elimination stages do not have a loser bracket.');\n            case 'double_elimination':\n                const group = await this.getLoserBracket(stageId);\n                if (!group)\n                    throw Error('Loser bracket not found.');\n                return group;\n            default:\n                throw Error('Unknown stage type.');\n        }\n    }\n    /**\n     * Returns the matches leading to the given match.\n     *\n     * If a `participantId` is given, the previous match _from their point of view_ is returned.\n     *\n     * @param matchId ID of the target match.\n     * @param participantId Optional ID of the participant.\n     */\n    async previousMatches(matchId, participantId) {\n        const match = await this.storage.select('match', matchId);\n        if (!match)\n            throw Error('Match not found.');\n        const stage = await this.storage.select('stage', match.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const group = await this.storage.select('group', match.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const round = await this.storage.select('round', match.round_id);\n        if (!round)\n            throw Error('Round not found.');\n        const matchLocation = helpers.getMatchLocation(stage.type, group.number);\n        const previousMatches = await this.getPreviousMatches(match, matchLocation, stage, round.number);\n        if (participantId !== undefined)\n            return previousMatches.filter(m => helpers.isParticipantInMatch(m, participantId));\n        return previousMatches;\n    }\n    /**\n     * Returns the matches following the given match.\n     *\n     * If a `participantId` is given:\n     * - If the participant won, the next match _from their point of view_ is returned.\n     * - If the participant is eliminated, no match is returned.\n     *\n     * @param matchId ID of the target match.\n     * @param participantId Optional ID of the participant.\n     */\n    async nextMatches(matchId, participantId) {\n        const match = await this.storage.select('match', matchId);\n        if (!match)\n            throw Error('Match not found.');\n        const stage = await this.storage.select('stage', match.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const group = await this.storage.select('group', match.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const { roundNumber, roundCount } = await this.getRoundPositionalInfo(match.round_id);\n        const matchLocation = helpers.getMatchLocation(stage.type, group.number);\n        const nextMatches = helpers.getNonNull(await this.getNextMatches(match, matchLocation, stage, roundNumber, roundCount));\n        if (participantId !== undefined) {\n            if (!helpers.isParticipantInMatch(match, participantId))\n                throw Error('The participant does not belong to this match.');\n            if (!helpers.isMatchStale(match))\n                throw Error('The match is not stale yet, so it is not possible to conclude the next matches for this participant.');\n            const loser = helpers.getLoser(match);\n            if (stage.type === 'single_elimination' && (loser === null || loser === void 0 ? void 0 : loser.id) === participantId)\n                return []; // Eliminated.\n            if (stage.type === 'double_elimination') {\n                // TODO: refactor `getNextMatches()` to return 1 next match per group. Then we can get rid of `getMatchesByGroupDoubleElimination()`.\n                const { winnerBracketMatch, loserBracketMatch, finalGroupMatch } = await this.getMatchesByGroupDoubleElimination(nextMatches, new Map([[group.id, group]]));\n                const winner = helpers.getWinner(match);\n                if (matchLocation === 'loser_bracket') {\n                    if (participantId === (loser === null || loser === void 0 ? void 0 : loser.id))\n                        return []; // Eliminated from lower bracket.\n                    if (participantId === (winner === null || winner === void 0 ? void 0 : winner.id))\n                        return loserBracketMatch ? [loserBracketMatch] : [];\n                }\n                else if (matchLocation === 'winner_bracket') {\n                    if (!loserBracketMatch)\n                        throw Error('All matches of winner bracket should lead to loser bracket.');\n                    if (participantId === (loser === null || loser === void 0 ? void 0 : loser.id))\n                        return [loserBracketMatch]; // Eliminated from upper bracket, going to lower bracket.\n                    if (participantId === (winner === null || winner === void 0 ? void 0 : winner.id))\n                        return winnerBracketMatch ? [winnerBracketMatch] : [];\n                }\n                else if (matchLocation === 'final_group') {\n                    if (!finalGroupMatch)\n                        throw Error('All matches of a final group should also lead to the final group.');\n                    return [finalGroupMatch];\n                }\n            }\n        }\n        return nextMatches;\n    }\n    /**\n     * Finds a match in a given group. The match must have the given number in a round of which the number in group is given.\n     *\n     * **Example:** In group of id 1, give me the 4th match in the 3rd round.\n     *\n     * @param groupId ID of the group.\n     * @param roundNumber Number of the round in its parent group.\n     * @param matchNumber Number of the match in its parent round.\n     */\n    async match(groupId, roundNumber, matchNumber) {\n        return this.findMatch(groupId, roundNumber, matchNumber);\n    }\n    /**\n     * Finds a match game based on its `id` or based on the combination of its `parent_id` and `number`.\n     *\n     * @param game Values to change in a match game.\n     */\n    async matchGame(game) {\n        return this.findMatchGame(game);\n    }\n    /**\n     * Returns an object with 1 match per group type. Only supports double elimination.\n     *\n     * @param matches A list of matches.\n     * @param fetchedGroups A map of groups which were already fetched.\n     */\n    async getMatchesByGroupDoubleElimination(matches, fetchedGroups) {\n        var _a, _b, _c;\n        const getGroup = async (groupId) => {\n            const existing = fetchedGroups.get(groupId);\n            if (existing)\n                return existing;\n            const group = await this.storage.select('group', groupId);\n            if (!group)\n                throw Error('Group not found.');\n            fetchedGroups.set(groupId, group);\n            return group;\n        };\n        let matchByGroupType = {};\n        for (const match of matches) {\n            const group = await getGroup(match.group_id);\n            matchByGroupType = {\n                winnerBracketMatch: (_a = matchByGroupType['winnerBracketMatch']) !== null && _a !== void 0 ? _a : (helpers.isWinnerBracket('double_elimination', group.number) ? match : undefined),\n                loserBracketMatch: (_b = matchByGroupType['loserBracketMatch']) !== null && _b !== void 0 ? _b : (helpers.isLoserBracket('double_elimination', group.number) ? match : undefined),\n                finalGroupMatch: (_c = matchByGroupType['finalGroupMatch']) !== null && _c !== void 0 ? _c : (helpers.isFinalGroup('double_elimination', group.number) ? match : undefined),\n            };\n        }\n        return matchByGroupType;\n    }\n}\nexports.Find = Find;\n//# sourceMappingURL=find.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/find.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/get.js":
/*!***************************************************!*\
  !*** ./node_modules/brackets-manager/dist/get.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Get = void 0;\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst getter_1 = __webpack_require__(/*! ./base/getter */ \"./node_modules/brackets-manager/dist/base/getter.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass Get extends getter_1.BaseGetter {\n    /**\n     * Returns the data needed to display a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async stageData(stageId) {\n        const stageData = await this.getStageSpecificData(stageId);\n        const participants = await this.storage.select('participant', { tournament_id: stageData.stage.tournament_id });\n        if (!participants)\n            throw Error('Error getting participants.');\n        return {\n            stage: [stageData.stage],\n            group: stageData.groups,\n            round: stageData.rounds,\n            match: stageData.matches,\n            match_game: stageData.matchGames,\n            participant: participants,\n        };\n    }\n    /**\n     * Returns the data needed to display a whole tournament with all its stages.\n     *\n     * @param tournamentId ID of the tournament.\n     */\n    async tournamentData(tournamentId) {\n        const stages = await this.storage.select('stage', { tournament_id: tournamentId });\n        if (!stages)\n            throw Error('Error getting stages.');\n        const stagesData = await Promise.all(stages.map(stage => this.getStageSpecificData(stage.id)));\n        const participants = await this.storage.select('participant', { tournament_id: tournamentId });\n        if (!participants)\n            throw Error('Error getting participants.');\n        return {\n            stage: stages,\n            group: stagesData.reduce((acc, data) => [...acc, ...data.groups], []),\n            round: stagesData.reduce((acc, data) => [...acc, ...data.rounds], []),\n            match: stagesData.reduce((acc, data) => [...acc, ...data.matches], []),\n            match_game: stagesData.reduce((acc, data) => [...acc, ...data.matchGames], []),\n            participant: participants,\n        };\n    }\n    /**\n     * Returns the match games associated to a list of matches.\n     *\n     * @param matches A list of matches.\n     */\n    async matchGames(matches) {\n        const parentMatches = matches.filter(match => match.child_count > 0);\n        const matchGamesQueries = await Promise.all(parentMatches.map(match => this.storage.select('match_game', { parent_id: match.id })));\n        if (matchGamesQueries.some(game => game === null))\n            throw Error('Error getting match games.');\n        return helpers.getNonNull(matchGamesQueries).flat();\n    }\n    /**\n     * Returns the stage that is not completed yet, because of uncompleted matches.\n     * If all matches are completed in this tournament, there is no \"current stage\", so `null` is returned.\n     *\n     * @param tournamentId ID of the tournament.\n     */\n    async currentStage(tournamentId) {\n        const stages = await this.storage.select('stage', { tournament_id: tournamentId });\n        if (!stages)\n            throw Error('Error getting stages.');\n        for (const stage of stages) {\n            const matches = await this.storage.select('match', { stage_id: stage.id });\n            if (!matches)\n                throw Error('Error getting matches.');\n            if (matches.every(match => match.status >= brackets_model_1.Status.Completed))\n                continue;\n            return stage;\n        }\n        return null;\n    }\n    /**\n     * Returns the round that is not completed yet, because of uncompleted matches.\n     * If all matches are completed in this stage of a tournament, there is no \"current round\", so `null` is returned.\n     *\n     * Note: The consolation final of single elimination and the grand final of double elimination will be in a different `Group`.\n     *\n     * @param stageId ID of the stage.\n     * @example\n     * If you don't know the stage id, you can first get the current stage.\n     * ```js\n     * const tournamentId = 3;\n     * const currentStage = await manager.get.currentStage(tournamentId);\n     * const currentRound = await manager.get.currentRound(currentStage.id);\n     * ```\n     */\n    async currentRound(stageId) {\n        const matches = await this.storage.select('match', { stage_id: stageId });\n        if (!matches)\n            throw Error('Error getting matches.');\n        const matchesByRound = helpers.splitBy(matches, 'round_id');\n        for (const roundMatches of matchesByRound) {\n            if (roundMatches.every(match => match.status >= brackets_model_1.Status.Completed))\n                continue;\n            const round = await this.storage.select('round', roundMatches[0].round_id);\n            if (!round)\n                throw Error('Round not found.');\n            return round;\n        }\n        return null;\n    }\n    /**\n     * Returns the matches that can currently be played in parallel.\n     * If the stage doesn't contain any, an empty array is returned.\n     *\n     * Note:\n     * - Returned matches are ongoing (i.e. ready or running).\n     * - Returned matches can be from different rounds.\n     *\n     * @param stageId ID of the stage.\n     * @example\n     * If you don't know the stage id, you can first get the current stage.\n     * ```js\n     * const tournamentId = 3;\n     * const currentStage = await manager.get.currentStage(tournamentId);\n     * const currentMatches = await manager.get.currentMatches(currentStage.id);\n     * ```\n     */\n    async currentMatches(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        // TODO: Implement this for all stage types.\n        // - For round robin, 1 round per group can be played in parallel at their own pace.\n        // - For double elimination, 1 round per bracket (upper and lower) can be played in parallel at their own pace.\n        if (stage.type !== 'single_elimination')\n            throw Error('Not implemented for round robin and double elimination. Ask if needed.');\n        const matches = await this.storage.select('match', { stage_id: stageId });\n        if (!matches)\n            throw Error('Error getting matches.');\n        const matchesByRound = helpers.splitBy(matches, 'round_id');\n        const roundCount = helpers.getUpperBracketRoundCount(stage.settings.size);\n        // Save multiple queries for `round`.\n        let currentRoundIndex = -1;\n        const currentMatches = [];\n        for (const roundMatches of matchesByRound) {\n            currentRoundIndex++;\n            if (stage.settings.consolationFinal && currentRoundIndex === roundCount - 1) {\n                // We are on the final of the single elimination.\n                const [final] = roundMatches;\n                const [consolationFinal] = matchesByRound[currentRoundIndex + 1];\n                const finals = [final, consolationFinal];\n                if (finals.every(match => !helpers.isMatchOngoing(match)))\n                    return [];\n                return finals.filter(match => helpers.isMatchOngoing(match));\n            }\n            if (roundMatches.every(match => !helpers.isMatchOngoing(match)))\n                continue;\n            currentMatches.push(...roundMatches.filter(match => helpers.isMatchOngoing(match)));\n        }\n        return currentMatches;\n    }\n    /**\n     * Returns the seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async seeding(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        const pickRelevantProps = (slot) => {\n            if (slot === null)\n                return null;\n            const { id, position } = slot;\n            return { id, position };\n        };\n        if (stage.type === 'round_robin')\n            return (await this.roundRobinSeeding(stage)).map(pickRelevantProps);\n        return (await this.eliminationSeeding(stage)).map(pickRelevantProps);\n    }\n    /**\n     * Returns the final standings of a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async finalStandings(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        switch (stage.type) {\n            case 'round_robin':\n                throw Error('A round-robin stage does not have standings.');\n            case 'single_elimination':\n                return this.singleEliminationStandings(stageId);\n            case 'double_elimination':\n                return this.doubleEliminationStandings(stageId);\n            default:\n                throw Error('Unknown stage type.');\n        }\n    }\n    /**\n     * Returns the seeding of a round-robin stage.\n     *\n     * @param stage The stage.\n     */\n    async roundRobinSeeding(stage) {\n        if (stage.settings.size === undefined)\n            throw Error('The size of the seeding is undefined.');\n        const matches = await this.storage.select('match', { stage_id: stage.id });\n        if (!matches)\n            throw Error('Error getting matches.');\n        const slots = helpers.convertMatchesToSeeding(matches);\n        // BYE vs. BYE matches of a round-robin stage are removed\n        // when the stage is created. We need to add them back temporarily.\n        if (slots.length < stage.settings.size) {\n            const diff = stage.settings.size - slots.length;\n            for (let i = 0; i < diff; i++)\n                slots.push(null);\n        }\n        const unique = helpers.uniqueBy(slots, item => item && item.position);\n        const seeding = helpers.setArraySize(unique, stage.settings.size, null);\n        return seeding;\n    }\n    /**\n     * Returns the seeding of an elimination stage.\n     *\n     * @param stage The stage.\n     */\n    async eliminationSeeding(stage) {\n        const firstRound = await this.storage.selectFirst('round', { stage_id: stage.id, number: 1 }, false);\n        if (!firstRound)\n            throw Error('Error getting the first round.');\n        const matches = await this.storage.select('match', { round_id: firstRound.id });\n        if (!matches)\n            throw Error('Error getting matches.');\n        return helpers.convertMatchesToSeeding(matches);\n    }\n    /**\n     * Returns the final standings of a single elimination stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async singleEliminationStandings(stageId) {\n        var _a;\n        const grouped = [];\n        const { stage: stages, group: groups, match: matches, participant: participants } = await this.stageData(stageId);\n        const [stage] = stages;\n        const [singleBracket, finalGroup] = groups;\n        const final = matches.filter(match => match.group_id === singleBracket.id).pop();\n        if (!final)\n            throw Error('Final not found.');\n        // 1st place: Final winner.\n        grouped[0] = [helpers.findParticipant(participants, getFinalWinnerIfDefined(final))];\n        // Rest: every loser in reverse order.\n        const losers = helpers.getLosers(participants, matches.filter(match => match.group_id === singleBracket.id));\n        grouped.push(...losers.reverse());\n        if ((_a = stage.settings) === null || _a === void 0 ? void 0 : _a.consolationFinal) {\n            const consolationFinal = matches.filter(match => match.group_id === finalGroup.id).pop();\n            if (!consolationFinal)\n                throw Error('Consolation final not found.');\n            const consolationFinalWinner = helpers.findParticipant(participants, getFinalWinnerIfDefined(consolationFinal));\n            const consolationFinalLoser = helpers.findParticipant(participants, helpers.getLoser(consolationFinal));\n            // Overwrite semi-final losers with the consolation final results.\n            grouped.splice(2, 1, [consolationFinalWinner], [consolationFinalLoser]);\n        }\n        return helpers.makeFinalStandings(grouped);\n    }\n    /**\n     * Returns the final standings of a double elimination stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async doubleEliminationStandings(stageId) {\n        var _a, _b;\n        const grouped = [];\n        const { stage: stages, group: groups, match: matches, participant: participants } = await this.stageData(stageId);\n        const [stage] = stages;\n        const [winnerBracket, loserBracket, finalGroup] = groups;\n        if (((_a = stage.settings) === null || _a === void 0 ? void 0 : _a.grandFinal) === 'none') {\n            const finalWB = matches.filter(match => match.group_id === winnerBracket.id).pop();\n            if (!finalWB)\n                throw Error('WB final not found.');\n            const finalLB = matches.filter(match => match.group_id === loserBracket.id).pop();\n            if (!finalLB)\n                throw Error('LB final not found.');\n            // 1st place: WB Final winner.\n            grouped[0] = [helpers.findParticipant(participants, getFinalWinnerIfDefined(finalWB))];\n            // 2nd place: LB Final winner.\n            grouped[1] = [helpers.findParticipant(participants, getFinalWinnerIfDefined(finalLB))];\n        }\n        else {\n            const grandFinalMatches = matches.filter(match => match.group_id === finalGroup.id);\n            const decisiveMatch = helpers.getGrandFinalDecisiveMatch(((_b = stage.settings) === null || _b === void 0 ? void 0 : _b.grandFinal) || 'none', grandFinalMatches);\n            // 1st place: Grand Final winner.\n            grouped[0] = [helpers.findParticipant(participants, getFinalWinnerIfDefined(decisiveMatch))];\n            // 2nd place: Grand Final loser.\n            grouped[1] = [helpers.findParticipant(participants, helpers.getLoser(decisiveMatch))];\n        }\n        // Rest: every loser in reverse order.\n        const losers = helpers.getLosers(participants, matches.filter(match => match.group_id === loserBracket.id));\n        grouped.push(...losers.reverse());\n        return helpers.makeFinalStandings(grouped);\n    }\n    /**\n     * Returns only the data specific to the given stage (without the participants).\n     *\n     * @param stageId ID of the stage.\n     */\n    async getStageSpecificData(stageId) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        const groups = await this.storage.select('group', { stage_id: stageId });\n        if (!groups)\n            throw Error('Error getting groups.');\n        const rounds = await this.storage.select('round', { stage_id: stageId });\n        if (!rounds)\n            throw Error('Error getting rounds.');\n        const matches = await this.storage.select('match', { stage_id: stageId });\n        if (!matches)\n            throw Error('Error getting matches.');\n        const matchGames = await this.matchGames(matches);\n        return {\n            stage,\n            groups,\n            rounds,\n            matches,\n            matchGames,\n        };\n    }\n}\nexports.Get = Get;\nconst getFinalWinnerIfDefined = (match) => {\n    const winner = helpers.getWinner(match);\n    if (!winner)\n        throw Error('The final match does not have a winner.');\n    return winner;\n};\n//# sourceMappingURL=get.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/get.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/helpers.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setExtraFields = exports.resetMatchResults = exports.setMatchResults = exports.getMatchStatus = exports.hasBye = exports.isMatchParticipantLocked = exports.isMatchUpdateLocked = exports.isMatchByeCompleted = exports.isMatchWinCompleted = exports.isMatchDrawCompleted = exports.isMatchResultCompleted = exports.isMatchForfeitCompleted = exports.isMatchStale = exports.isMatchOngoing = exports.isMatchCompleted = exports.isMatchStarted = exports.isMatchPending = exports.getOtherSide = exports.getSide = exports.isParticipantInMatch = exports.findPosition = exports.getMatchResult = exports.byeLoser = exports.byeWinnerToGrandFinal = exports.byeWinner = exports.getLoser = exports.getWinner = exports.toResultWithPosition = exports.toResult = exports.convertTBDtoBYE = exports.ensureNotTied = exports.ensureValidSize = exports.isPowerOfTwo = exports.fixSeeding = exports.ensureEquallySized = exports.ensureNoDuplicates = exports.ensureEvenSized = exports.makePairs = exports.setArraySize = exports.normalizeParticipant = exports.makeNormalizedIdMapping = exports.normalizeIds = exports.balanceByes = exports.makeGroups = exports.assertRoundRobin = exports.makeRoundRobinDistribution = exports.makeRoundRobinMatches = exports.splitByParity = exports.splitBy = exports.isDefined = void 0;\nexports.getLowerBracketRoundCount = exports.getLoserOrdering = exports.getLoserCountFromWbForLbRound = exports.getLoserRoundMatchCount = exports.findLoserMatchNumber = exports.isDoubleEliminationNecessary = exports.getRoundPairCount = exports.getUpperBracketRoundCount = exports.isOrderingSupportedLoserBracket = exports.isOrderingSupportedUpperBracket = exports.ensureOrderingSupported = exports.getSeedCount = exports.getSeeds = exports.getChildGamesResults = exports.getUpdatedMatchResults = exports.getParentMatchResults = exports.setParentMatchCompleted = exports.transitionToMinor = exports.transitionToMajor = exports.isMinorRound = exports.isMajorRound = exports.uniqueBy = exports.getNonNull = exports.sortSeeding = exports.convertSlotsToSeeding = exports.convertMatchesToSeeding = exports.mapParticipantsToDatabase = exports.mapParticipantsIdsToDatabase = exports.mapParticipantsNamesToDatabase = exports.extractParticipantsFromSeeding = exports.isSeedingWithIds = exports.setForfeits = exports.setResults = exports.setCompleted = exports.getInferredResult = exports.setScores = exports.invertOpponents = exports.handleGivenStatus = exports.handleOpponentsInversion = exports.resetNextOpponent = exports.setNextOpponent = exports.getNextSideConsolationFinalDoubleElimination = exports.getNextSideLoserBracket = exports.getNextSide = exports.findParticipant = exports.getGrandFinalDecisiveMatch = exports.makeFinalStandings = exports.getLosers = exports.getOriginPosition = exports.getOpponentId = void 0;\nexports.getFractionOfFinal = exports.getMatchLocation = exports.isFinalGroup = exports.isLoserBracket = exports.isWinnerBracket = exports.isRoundCompleted = exports.ensureNotRoundRobin = exports.isRoundRobin = exports.minScoreToWinBestOfX = exports.getNearestPowerOfTwo = exports.getDiagonalMatchNumber = void 0;\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst ordering_1 = __webpack_require__(/*! ./ordering */ \"./node_modules/brackets-manager/dist/ordering.js\");\n/**\n * Checks whether a value is defined (i.e. not null nor undefined).\n *\n * @param value The value to check.\n */\nfunction isDefined(value) {\n    return value !== null && value !== undefined;\n}\nexports.isDefined = isDefined;\n/**\n * Splits an array of objects based on their values at a given key.\n *\n * @param objects The array to split.\n * @param key The key of T.\n */\nfunction splitBy(objects, key) {\n    const map = {};\n    for (const obj of objects) {\n        const commonValue = obj[key];\n        if (!map[commonValue])\n            map[commonValue] = [];\n        map[commonValue].push(obj);\n    }\n    return Object.values(map);\n}\nexports.splitBy = splitBy;\n/**\n * Splits an array in two parts: one with even indices and the other with odd indices.\n *\n * @param array The array to split.\n */\nfunction splitByParity(array) {\n    return {\n        even: array.filter((_, i) => i % 2 === 0),\n        odd: array.filter((_, i) => i % 2 === 1),\n    };\n}\nexports.splitByParity = splitByParity;\n/**\n * Makes a list of rounds containing the matches of a round-robin group.\n *\n * @param participants The participants to distribute.\n * @param mode The round-robin mode.\n */\nfunction makeRoundRobinMatches(participants, mode = 'simple') {\n    const distribution = makeRoundRobinDistribution(participants);\n    if (mode === 'simple')\n        return distribution;\n    // Reverse rounds and their content.\n    const symmetry = distribution.map(round => [...round].reverse()).reverse();\n    return [...distribution, ...symmetry];\n}\nexports.makeRoundRobinMatches = makeRoundRobinMatches;\n/**\n * Distributes participants in rounds for a round-robin group.\n *\n * Conditions:\n * - Each participant plays each other once.\n * - Each participant plays once in each round.\n *\n * @param participants The participants to distribute.\n */\nfunction makeRoundRobinDistribution(participants) {\n    const n = participants.length;\n    const n1 = n % 2 === 0 ? n : n + 1;\n    const roundCount = n1 - 1;\n    const matchPerRound = n1 / 2;\n    const rounds = [];\n    for (let roundId = 0; roundId < roundCount; roundId++) {\n        const matches = [];\n        for (let matchId = 0; matchId < matchPerRound; matchId++) {\n            if (matchId === 0 && n % 2 === 1)\n                continue;\n            const opponentsIds = [\n                (roundId - matchId - 1 + n1) % (n1 - 1),\n                matchId === 0 ? n1 - 1 : (roundId + matchId) % (n1 - 1),\n            ];\n            matches.push([\n                participants[opponentsIds[0]],\n                participants[opponentsIds[1]],\n            ]);\n        }\n        rounds.push(matches);\n    }\n    return rounds;\n}\nexports.makeRoundRobinDistribution = makeRoundRobinDistribution;\n/**\n * A helper to assert our generated round-robin is correct.\n *\n * @param input The input seeding.\n * @param output The resulting distribution of seeds in groups.\n */\nfunction assertRoundRobin(input, output) {\n    const n = input.length;\n    const matchPerRound = Math.floor(n / 2);\n    const roundCount = n % 2 === 0 ? n - 1 : n;\n    if (output.length !== roundCount)\n        throw Error('Round count is wrong');\n    if (!output.every(round => round.length === matchPerRound))\n        throw Error('Not every round has the good number of matches');\n    const checkAllOpponents = Object.fromEntries(input.map(element => [element, new Set()]));\n    for (const round of output) {\n        const checkUnique = new Set();\n        for (const match of round) {\n            if (match.length !== 2)\n                throw Error('One match is not a pair');\n            if (checkUnique.has(match[0]))\n                throw Error('This team is already playing');\n            checkUnique.add(match[0]);\n            if (checkUnique.has(match[1]))\n                throw Error('This team is already playing');\n            checkUnique.add(match[1]);\n            if (checkAllOpponents[match[0]].has(match[1]))\n                throw Error('The team has already matched this team');\n            checkAllOpponents[match[0]].add(match[1]);\n            if (checkAllOpponents[match[1]].has(match[0]))\n                throw Error('The team has already matched this team');\n            checkAllOpponents[match[1]].add(match[0]);\n        }\n    }\n}\nexports.assertRoundRobin = assertRoundRobin;\n/**\n * Distributes elements in groups of equal size.\n *\n * @param elements A list of elements to distribute in groups.\n * @param groupCount The group count.\n */\nfunction makeGroups(elements, groupCount) {\n    const groupSize = Math.ceil(elements.length / groupCount);\n    const result = [];\n    for (let i = 0; i < elements.length; i++) {\n        if (i % groupSize === 0)\n            result.push([]);\n        result[result.length - 1].push(elements[i]);\n    }\n    return result;\n}\nexports.makeGroups = makeGroups;\n/**\n * Balances BYEs to prevents having BYE against BYE in matches.\n *\n * @param seeding The seeding of the stage.\n * @param participantCount The number of participants in the stage.\n */\nfunction balanceByes(seeding, participantCount) {\n    seeding = seeding.filter(v => v !== null);\n    participantCount = participantCount || getNearestPowerOfTwo(seeding.length);\n    if (seeding.length < participantCount / 2) {\n        const flat = seeding.flatMap(v => [v, null]);\n        return setArraySize(flat, participantCount, null);\n    }\n    const nonNullCount = seeding.length;\n    const nullCount = participantCount - nonNullCount;\n    const againstEachOther = seeding.slice(0, nonNullCount - nullCount).filter((_, i) => i % 2 === 0).map((_, i) => [seeding[2 * i], seeding[2 * i + 1]]);\n    const againstNull = seeding.slice(nonNullCount - nullCount, nonNullCount).map(v => [v, null]);\n    const flat = [...againstEachOther.flat(), ...againstNull.flat()];\n    return setArraySize(flat, participantCount, null);\n}\nexports.balanceByes = balanceByes;\n/**\n * Normalizes IDs in a database.\n *\n * All IDs (and references to them) are remapped to consecutive IDs starting from 0.\n *\n * @param data Data to normalize.\n */\nfunction normalizeIds(data) {\n    const mappings = {\n        participant: makeNormalizedIdMapping(data.participant),\n        stage: makeNormalizedIdMapping(data.stage),\n        group: makeNormalizedIdMapping(data.group),\n        round: makeNormalizedIdMapping(data.round),\n        match: makeNormalizedIdMapping(data.match),\n        match_game: makeNormalizedIdMapping(data.match_game),\n    };\n    return {\n        participant: data.participant.map(value => ({\n            ...value,\n            id: mappings.participant[value.id],\n        })),\n        stage: data.stage.map(value => ({\n            ...value,\n            id: mappings.stage[value.id],\n        })),\n        group: data.group.map(value => ({\n            ...value,\n            id: mappings.group[value.id],\n            stage_id: mappings.stage[value.stage_id],\n        })),\n        round: data.round.map(value => ({\n            ...value,\n            id: mappings.round[value.id],\n            stage_id: mappings.stage[value.stage_id],\n            group_id: mappings.group[value.group_id],\n        })),\n        match: data.match.map(value => ({\n            ...value,\n            id: mappings.match[value.id],\n            stage_id: mappings.stage[value.stage_id],\n            group_id: mappings.group[value.group_id],\n            round_id: mappings.round[value.round_id],\n            opponent1: normalizeParticipant(value.opponent1, mappings.participant),\n            opponent2: normalizeParticipant(value.opponent2, mappings.participant),\n        })),\n        match_game: data.match_game.map(value => ({\n            ...value,\n            id: mappings.match_game[value.id],\n            stage_id: mappings.stage[value.stage_id],\n            parent_id: mappings.match[value.parent_id],\n            opponent1: normalizeParticipant(value.opponent1, mappings.participant),\n            opponent2: normalizeParticipant(value.opponent2, mappings.participant),\n        })),\n    };\n}\nexports.normalizeIds = normalizeIds;\n/**\n * Makes a mapping between old IDs and new normalized IDs.\n *\n * @param elements A list of elements with IDs.\n */\nfunction makeNormalizedIdMapping(elements) {\n    let currentId = 0;\n    return elements.reduce((acc, current) => ({\n        ...acc,\n        [current.id]: currentId++,\n    }), {});\n}\nexports.makeNormalizedIdMapping = makeNormalizedIdMapping;\n/**\n * Apply a normalizing mapping to a participant.\n *\n * @param participant The participant.\n * @param mapping The mapping of IDs.\n */\nfunction normalizeParticipant(participant, mapping) {\n    if (participant === null)\n        return null;\n    return {\n        ...participant,\n        id: participant.id !== null ? mapping[participant.id] : null,\n    };\n}\nexports.normalizeParticipant = normalizeParticipant;\n/**\n * Sets the size of an array with a placeholder if the size is bigger.\n *\n * @param array The original array.\n * @param length The new length.\n * @param placeholder A placeholder to use to fill the empty space.\n */\nfunction setArraySize(array, length, placeholder) {\n    return Array.from({ length }, (_, i) => array[i] || placeholder);\n}\nexports.setArraySize = setArraySize;\n/**\n * Makes pairs with each element and its next one.\n *\n * @example [1, 2, 3, 4] --> [[1, 2], [3, 4]]\n * @param array A list of elements.\n */\nfunction makePairs(array) {\n    return array.map((_, i) => (i % 2 === 0) ? [array[i], array[i + 1]] : []).filter((v) => v.length === 2);\n}\nexports.makePairs = makePairs;\n/**\n * Ensures that a list of elements has an even size.\n *\n * @param array A list of elements.\n */\nfunction ensureEvenSized(array) {\n    if (array.length % 2 === 1)\n        throw Error('Array size must be even.');\n}\nexports.ensureEvenSized = ensureEvenSized;\n/**\n * Ensures there are no duplicates in a list of elements.\n *\n * @param array A list of elements.\n */\nfunction ensureNoDuplicates(array) {\n    const nonNull = getNonNull(array);\n    const unique = nonNull.filter((item, index) => {\n        const stringifiedItem = JSON.stringify(item);\n        return nonNull.findIndex(obj => JSON.stringify(obj) === stringifiedItem) === index;\n    });\n    if (unique.length < nonNull.length)\n        throw new Error('The seeding has a duplicate participant.');\n}\nexports.ensureNoDuplicates = ensureNoDuplicates;\n/**\n * Ensures that two lists of elements have the same size.\n *\n * @param left The first list of elements.\n * @param right The second list of elements.\n */\nfunction ensureEquallySized(left, right) {\n    if (left.length !== right.length)\n        throw Error('Arrays\\' size must be equal.');\n}\nexports.ensureEquallySized = ensureEquallySized;\n/**\n * Fixes the seeding by enlarging it if it's not complete.\n *\n * @param seeding The seeding of the stage.\n * @param participantCount The number of participants in the stage.\n */\nfunction fixSeeding(seeding, participantCount) {\n    if (seeding.length > participantCount)\n        throw Error('The seeding has more participants than the size of the stage.');\n    if (seeding.length < participantCount)\n        return setArraySize(seeding, participantCount, null);\n    return seeding;\n}\nexports.fixSeeding = fixSeeding;\n/**\n * Indicates whether a number is a power of two.\n *\n * @param number The number to test.\n */\nfunction isPowerOfTwo(number) {\n    return Number.isInteger(Math.log2(number));\n}\nexports.isPowerOfTwo = isPowerOfTwo;\n/**\n * Ensures that the participant count is valid.\n *\n * @param stageType Type of the stage to test.\n * @param participantCount The number to test.\n */\nfunction ensureValidSize(stageType, participantCount) {\n    if (participantCount === 0)\n        throw Error('Impossible to create an empty stage. If you want an empty seeding, just set the size of the stage.');\n    if (participantCount < 2)\n        throw Error('Impossible to create a stage with less than 2 participants.');\n    if (stageType === 'round_robin') {\n        // Round robin supports any number of participants.\n        return;\n    }\n    if (!isPowerOfTwo(participantCount))\n        throw Error('The library only supports a participant count which is a power of two.');\n}\nexports.ensureValidSize = ensureValidSize;\n/**\n * Ensures that a match scores aren't tied.\n *\n * @param scores Two numbers which are scores.\n */\nfunction ensureNotTied(scores) {\n    if (scores[0] === scores[1])\n        throw Error(`${scores[0]} and ${scores[1]} are tied. It cannot be.`);\n}\nexports.ensureNotTied = ensureNotTied;\n/**\n * Converts a TBD to a BYE.\n *\n * @param slot The slot to convert.\n */\nfunction convertTBDtoBYE(slot) {\n    if (slot === null)\n        return null; // Already a BYE.\n    if ((slot === null || slot === void 0 ? void 0 : slot.id) === null)\n        return null; // It's a TBD: make it a BYE.\n    return slot; // It's a determined participant.\n}\nexports.convertTBDtoBYE = convertTBDtoBYE;\n/**\n * Converts a participant slot to a result stored in storage.\n *\n * @param slot A participant slot.\n */\nfunction toResult(slot) {\n    return slot && {\n        id: slot.id,\n    };\n}\nexports.toResult = toResult;\n/**\n * Converts a participant slot to a result stored in storage, with the position the participant is coming from.\n *\n * @param slot A participant slot.\n */\nfunction toResultWithPosition(slot) {\n    return slot && {\n        id: slot.id,\n        position: slot.position,\n    };\n}\nexports.toResultWithPosition = toResultWithPosition;\n/**\n * Returns the winner of a match.\n *\n * @param match The match.\n */\nfunction getWinner(match) {\n    const winnerSide = getMatchResult(match);\n    if (!winnerSide)\n        return null;\n    return match[winnerSide];\n}\nexports.getWinner = getWinner;\n/**\n * Returns the loser of a match.\n *\n * @param match The match.\n */\nfunction getLoser(match) {\n    const winnerSide = getMatchResult(match);\n    if (!winnerSide)\n        return null;\n    return match[getOtherSide(winnerSide)];\n}\nexports.getLoser = getLoser;\n/**\n * Returns the pre-computed winner for a match because of BYEs.\n *\n * @param opponents Two opponents.\n */\nfunction byeWinner(opponents) {\n    if (opponents[0] === null && opponents[1] === null) // Double BYE.\n        return null; // BYE.\n    if (opponents[0] === null && opponents[1] !== null) // opponent1 BYE.\n        return { id: opponents[1].id }; // opponent2.\n    if (opponents[0] !== null && opponents[1] === null) // opponent2 BYE.\n        return { id: opponents[0].id }; // opponent1.\n    return { id: null }; // Normal.\n}\nexports.byeWinner = byeWinner;\n/**\n * Returns the pre-computed winner for a match because of BYEs in a lower bracket.\n *\n * @param opponents Two opponents.\n */\nfunction byeWinnerToGrandFinal(opponents) {\n    const winner = byeWinner(opponents);\n    if (winner)\n        winner.position = 1;\n    return winner;\n}\nexports.byeWinnerToGrandFinal = byeWinnerToGrandFinal;\n/**\n * Returns the pre-computed loser for a match because of BYEs.\n *\n * Only used for loser bracket.\n *\n * @param opponents Two opponents.\n * @param index The index of the duel in the round.\n */\nfunction byeLoser(opponents, index) {\n    if (opponents[0] === null || opponents[1] === null) // At least one BYE.\n        return null; // BYE.\n    return { id: null, position: index + 1 }; // Normal.\n}\nexports.byeLoser = byeLoser;\n/**\n * Returns the winner side or `null` if no winner.\n *\n * @param match A match's results.\n */\nfunction getMatchResult(match) {\n    var _a, _b;\n    if (!isMatchCompleted(match))\n        return null;\n    if (isMatchDrawCompleted(match))\n        return null;\n    if (match.opponent1 === null && match.opponent2 === null)\n        return null;\n    let winner = null;\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === 'win' || match.opponent2 === null || match.opponent2.forfeit)\n        winner = 'opponent1';\n    if (((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === 'win' || match.opponent1 === null || match.opponent1.forfeit) {\n        if (winner !== null)\n            throw Error('There are two winners.');\n        winner = 'opponent2';\n    }\n    return winner;\n}\nexports.getMatchResult = getMatchResult;\n/**\n * Finds a position in a list of matches.\n *\n * @param matches A list of matches to search into.\n * @param position The position to find.\n */\nfunction findPosition(matches, position) {\n    var _a, _b;\n    for (const match of matches) {\n        if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.position) === position)\n            return match.opponent1;\n        if (((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.position) === position)\n            return match.opponent2;\n    }\n    return null;\n}\nexports.findPosition = findPosition;\n/**\n * Checks if a participant is involved in a given match.\n *\n * @param match A match.\n * @param participantId ID of a participant.\n */\nfunction isParticipantInMatch(match, participantId) {\n    return [match.opponent1, match.opponent2].some(m => (m === null || m === void 0 ? void 0 : m.id) === participantId);\n}\nexports.isParticipantInMatch = isParticipantInMatch;\n/**\n * Gets the side where the winner of the given match will go in the next match.\n *\n * @param matchNumber Number of the match.\n */\nfunction getSide(matchNumber) {\n    return matchNumber % 2 === 1 ? 'opponent1' : 'opponent2';\n}\nexports.getSide = getSide;\n/**\n * Gets the other side of a match.\n *\n * @param side The side that we don't want.\n */\nfunction getOtherSide(side) {\n    return side === 'opponent1' ? 'opponent2' : 'opponent1';\n}\nexports.getOtherSide = getOtherSide;\n/**\n * Checks if a match is pending (i.e. locked or waiting).\n *\n * [Locked > Waiting] > Ready > Running > Completed > Archived\n *\n * @param match Partial match results.\n */\nfunction isMatchPending(match) {\n    var _a, _b;\n    return !((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.id) || !((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.id); // At least one BYE or TBD\n}\nexports.isMatchPending = isMatchPending;\n/**\n * Checks if a match is started.\n *\n * Note: this is score-based. A completed or archived match is seen as \"started\" as well.\n *\n * Locked > Waiting > Ready > [Running > Completed > Archived]\n *\n * @param match Partial match results.\n */\nfunction isMatchStarted(match) {\n    var _a, _b;\n    return ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.score) !== undefined || ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.score) !== undefined;\n}\nexports.isMatchStarted = isMatchStarted;\n/**\n * Checks if a match is completed (based on BYEs, forfeit or result).\n *\n * Note: archived matches are not seen as completed by this helper.\n *\n * Locked > Waiting > Ready > Running > [Completed] > Archived\n *\n * @param match Partial match results.\n */\nfunction isMatchCompleted(match) {\n    return isMatchByeCompleted(match) || isMatchForfeitCompleted(match) || isMatchResultCompleted(match);\n}\nexports.isMatchCompleted = isMatchCompleted;\n/**\n * Checks if a match is ongoing (i.e. ready or running).\n *\n * Locked > Waiting > [Ready > Running] > Completed > Archived\n *\n * @param match Partial match results.\n */\nfunction isMatchOngoing(match) {\n    return [brackets_model_1.Status.Ready, brackets_model_1.Status.Running].includes(match.status);\n}\nexports.isMatchOngoing = isMatchOngoing;\n/**\n * Checks if a match is stale (i.e. it should not change anymore).\n *\n * [Locked - BYE] > Waiting > Ready > Running > [Completed > Archived]\n *\n * @param match Partial match results.\n */\nfunction isMatchStale(match) {\n    return match.status >= brackets_model_1.Status.Completed || isMatchByeCompleted(match);\n}\nexports.isMatchStale = isMatchStale;\n/**\n * Checks if a match is completed because of a forfeit.\n *\n * @param match Partial match results.\n */\nfunction isMatchForfeitCompleted(match) {\n    var _a, _b;\n    return ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.forfeit) !== undefined || ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.forfeit) !== undefined;\n}\nexports.isMatchForfeitCompleted = isMatchForfeitCompleted;\n/**\n * Checks if a match is completed because of a either a draw or a win.\n *\n * @param match Partial match results.\n */\nfunction isMatchResultCompleted(match) {\n    return isMatchDrawCompleted(match) || isMatchWinCompleted(match);\n}\nexports.isMatchResultCompleted = isMatchResultCompleted;\n/**\n * Checks if a match is completed because of a draw.\n *\n * @param match Partial match results.\n */\nfunction isMatchDrawCompleted(match) {\n    var _a, _b;\n    return ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === 'draw' && ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === 'draw';\n}\nexports.isMatchDrawCompleted = isMatchDrawCompleted;\n/**\n * Checks if a match is completed because of a win.\n *\n * @param match Partial match results.\n */\nfunction isMatchWinCompleted(match) {\n    var _a, _b, _c, _d;\n    return ((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === 'win' || ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === 'win'\n        || ((_c = match.opponent1) === null || _c === void 0 ? void 0 : _c.result) === 'loss' || ((_d = match.opponent2) === null || _d === void 0 ? void 0 : _d.result) === 'loss';\n}\nexports.isMatchWinCompleted = isMatchWinCompleted;\n/**\n * Checks if a match is completed because of at least one BYE.\n *\n * A match \"BYE vs. TBD\" isn't considered completed yet.\n *\n * @param match Partial match results.\n */\nfunction isMatchByeCompleted(match) {\n    var _a, _b;\n    return (match.opponent1 === null && ((_a = match.opponent2) === null || _a === void 0 ? void 0 : _a.id) !== null) // BYE vs. someone\n        || (match.opponent2 === null && ((_b = match.opponent1) === null || _b === void 0 ? void 0 : _b.id) !== null) // someone vs. BYE\n        || (match.opponent1 === null && match.opponent2 === null); // BYE vs. BYE\n}\nexports.isMatchByeCompleted = isMatchByeCompleted;\n/**\n * Checks if a match's results can't be updated.\n *\n * @param match The match to check.\n */\nfunction isMatchUpdateLocked(match) {\n    return match.status === brackets_model_1.Status.Locked || match.status === brackets_model_1.Status.Waiting || match.status === brackets_model_1.Status.Archived || isMatchByeCompleted(match);\n}\nexports.isMatchUpdateLocked = isMatchUpdateLocked;\n/**\n * Checks if a match's participants can't be updated.\n *\n * @param match The match to check.\n */\nfunction isMatchParticipantLocked(match) {\n    return match.status >= brackets_model_1.Status.Running;\n}\nexports.isMatchParticipantLocked = isMatchParticipantLocked;\n/**\n * Indicates whether a match has at least one BYE or not.\n *\n * @param match Partial match results.\n */\nfunction hasBye(match) {\n    return match.opponent1 === null || match.opponent2 === null;\n}\nexports.hasBye = hasBye;\n/**\n * Returns the status of a match based on information about it.\n *\n * @param arg The opponents or partial results of the match.\n */\nfunction getMatchStatus(arg) {\n    var _a, _b, _c, _d;\n    const match = Array.isArray(arg) ? {\n        opponent1: arg[0],\n        opponent2: arg[1],\n    } : arg;\n    if (hasBye(match)) // At least one BYE.\n        return brackets_model_1.Status.Locked;\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.id) === null && ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.id) === null) // Two TBD opponents.\n        return brackets_model_1.Status.Locked;\n    if (((_c = match.opponent1) === null || _c === void 0 ? void 0 : _c.id) === null || ((_d = match.opponent2) === null || _d === void 0 ? void 0 : _d.id) === null) // One TBD opponent.\n        return brackets_model_1.Status.Waiting;\n    if (isMatchCompleted(match))\n        return brackets_model_1.Status.Completed;\n    if (isMatchStarted(match))\n        return brackets_model_1.Status.Running;\n    return brackets_model_1.Status.Ready;\n}\nexports.getMatchStatus = getMatchStatus;\n/**\n * Updates a match results based on an input.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n * @param inRoundRobin Indicates whether the match is in a round-robin stage.\n */\nfunction setMatchResults(stored, match, inRoundRobin) {\n    var _a, _b;\n    handleGivenStatus(stored, match);\n    if (!inRoundRobin && (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === 'draw' || ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === 'draw'))\n        throw Error('Having a draw is forbidden in an elimination tournament.');\n    const completed = isMatchCompleted(match);\n    const currentlyCompleted = isMatchCompleted(stored);\n    setExtraFields(stored, match);\n    handleOpponentsInversion(stored, match);\n    const statusChanged = setScores(stored, match);\n    if (completed && currentlyCompleted) {\n        // Ensure everything is good.\n        setCompleted(stored, match, inRoundRobin);\n        return { statusChanged: false, resultChanged: true };\n    }\n    if (completed && !currentlyCompleted) {\n        setCompleted(stored, match, inRoundRobin);\n        return { statusChanged: true, resultChanged: true };\n    }\n    if (!completed && currentlyCompleted) {\n        resetMatchResults(stored);\n        return { statusChanged: true, resultChanged: true };\n    }\n    return { statusChanged, resultChanged: false };\n}\nexports.setMatchResults = setMatchResults;\n/**\n * Resets the results of a match. (status, forfeit, result)\n *\n * @param stored A reference to what will be updated in the storage.\n */\nfunction resetMatchResults(stored) {\n    if (stored.opponent1) {\n        stored.opponent1.forfeit = undefined;\n        stored.opponent1.result = undefined;\n    }\n    if (stored.opponent2) {\n        stored.opponent2.forfeit = undefined;\n        stored.opponent2.result = undefined;\n    }\n    stored.status = getMatchStatus(stored);\n}\nexports.resetMatchResults = resetMatchResults;\n/**\n * Passes user-defined extra fields to the stored match.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n */\nfunction setExtraFields(stored, match) {\n    const partialAssign = (target, update, ignoredKeys) => {\n        if (!target || !update)\n            return;\n        const retainedKeys = Object.keys(update).filter((key) => !ignoredKeys.includes(key));\n        retainedKeys.forEach(key => {\n            target[key] = update[key];\n        });\n    };\n    const ignoredKeys = [\n        'id',\n        'number',\n        'stage_id',\n        'group_id',\n        'round_id',\n        'status',\n        'opponent1',\n        'opponent2',\n        'child_count',\n        'parent_id',\n    ];\n    const ignoredOpponentKeys = [\n        'id',\n        'score',\n        'position',\n        'forfeit',\n        'result',\n    ];\n    partialAssign(stored, match, ignoredKeys);\n    partialAssign(stored.opponent1, match.opponent1, ignoredOpponentKeys);\n    partialAssign(stored.opponent2, match.opponent2, ignoredOpponentKeys);\n}\nexports.setExtraFields = setExtraFields;\n/**\n * Gets the id of the opponent at the given side of the given match.\n *\n * @param match The match to get the opponent from.\n * @param side The side where to get the opponent from.\n */\nfunction getOpponentId(match, side) {\n    const opponent = match[side];\n    return opponent && opponent.id;\n}\nexports.getOpponentId = getOpponentId;\n/**\n * Gets the origin position of a side of a match.\n *\n * @param match The match.\n * @param side The side.\n */\nfunction getOriginPosition(match, side) {\n    var _a;\n    const matchNumber = (_a = match[side]) === null || _a === void 0 ? void 0 : _a.position;\n    if (matchNumber === undefined)\n        throw Error('Position is undefined.');\n    return matchNumber;\n}\nexports.getOriginPosition = getOriginPosition;\n/**\n * Returns every loser in a list of matches.\n *\n * @param participants The list of participants.\n * @param matches A list of matches to get losers of.\n */\nfunction getLosers(participants, matches) {\n    const losers = [];\n    let currentRound = null;\n    let roundIndex = -1;\n    for (const match of matches) {\n        if (match.round_id !== currentRound) {\n            currentRound = match.round_id;\n            roundIndex++;\n            losers[roundIndex] = [];\n        }\n        const loser = getLoser(match);\n        if (loser === null)\n            continue;\n        losers[roundIndex].push(findParticipant(participants, loser));\n    }\n    return losers;\n}\nexports.getLosers = getLosers;\n/**\n * Makes final standings based on participants grouped by ranking.\n *\n * @param grouped A list of participants grouped by ranking.\n */\nfunction makeFinalStandings(grouped) {\n    const standings = [];\n    let rank = 1;\n    for (const group of grouped) {\n        for (const participant of group) {\n            standings.push({\n                id: participant.id,\n                name: participant.name,\n                rank,\n            });\n        }\n        rank++;\n    }\n    return standings;\n}\nexports.makeFinalStandings = makeFinalStandings;\n/**\n * Returns the decisive match of a Grand Final.\n *\n * @param type The type of Grand Final.\n * @param matches The matches in the Grand Final.\n */\nfunction getGrandFinalDecisiveMatch(type, matches) {\n    if (type === 'simple')\n        return matches[0];\n    if (type === 'double') {\n        const result = getMatchResult(matches[0]);\n        if (result === 'opponent2')\n            return matches[1];\n        return matches[0];\n    }\n    throw Error('The Grand Final is disabled.');\n}\nexports.getGrandFinalDecisiveMatch = getGrandFinalDecisiveMatch;\n/**\n * Finds a participant in a list.\n *\n * @param participants The list of participants.\n * @param slot The slot of the participant to find.\n */\nfunction findParticipant(participants, slot) {\n    if (!slot)\n        throw Error('Cannot find a BYE participant.');\n    const participant = participants.find(participant => participant.id === (slot === null || slot === void 0 ? void 0 : slot.id));\n    if (!participant)\n        throw Error('Participant not found.');\n    return participant;\n}\nexports.findParticipant = findParticipant;\n/**\n * Gets the side the winner of the current match will go to in the next match.\n *\n * @param matchNumber Number of the current match.\n * @param roundNumber Number of the current round.\n * @param roundCount Count of rounds.\n * @param matchLocation Location of the current match.\n */\nfunction getNextSide(matchNumber, roundNumber, roundCount, matchLocation) {\n    // The nextSide comes from the same bracket.\n    if (matchLocation === 'loser_bracket' && roundNumber % 2 === 1)\n        return 'opponent2';\n    // The nextSide comes from the loser bracket to the final group.\n    if (matchLocation === 'loser_bracket' && roundNumber === roundCount)\n        return 'opponent2';\n    return getSide(matchNumber);\n}\nexports.getNextSide = getNextSide;\n/**\n * Gets the side the winner of the current match in loser bracket will go in the next match.\n *\n * @param matchNumber Number of the match.\n * @param nextMatch The next match.\n * @param roundNumber Number of the current round.\n */\nfunction getNextSideLoserBracket(matchNumber, nextMatch, roundNumber) {\n    var _a;\n    // The nextSide comes from the WB.\n    if (roundNumber > 1)\n        return 'opponent1';\n    // The nextSide comes from the WB round 1. \n    if (((_a = nextMatch.opponent1) === null || _a === void 0 ? void 0 : _a.position) === matchNumber)\n        return 'opponent1';\n    return 'opponent2';\n}\nexports.getNextSideLoserBracket = getNextSideLoserBracket;\n/**\n * Gets the side the loser of the current match in loser bracket will go in the next match.\n *\n * @param roundNumber Number of the current round.\n */\nfunction getNextSideConsolationFinalDoubleElimination(roundNumber) {\n    return isMajorRound(roundNumber) ? 'opponent1' : 'opponent2';\n}\nexports.getNextSideConsolationFinalDoubleElimination = getNextSideConsolationFinalDoubleElimination;\n/**\n * Sets an opponent in the next match he has to go.\n *\n * @param nextMatch A match which follows the current one.\n * @param nextSide The side the opponent will be on in the next match.\n * @param match The current match.\n * @param currentSide The side the opponent is currently on.\n */\nfunction setNextOpponent(nextMatch, nextSide, match, currentSide) {\n    var _a;\n    nextMatch[nextSide] = match[currentSide] && {\n        id: getOpponentId(match, currentSide),\n        position: (_a = nextMatch[nextSide]) === null || _a === void 0 ? void 0 : _a.position, // Keep position.\n    };\n    nextMatch.status = getMatchStatus(nextMatch);\n}\nexports.setNextOpponent = setNextOpponent;\n/**\n * Resets an opponent in the match following the current one.\n *\n * @param nextMatch A match which follows the current one.\n * @param nextSide The side the opponent will be on in the next match.\n */\nfunction resetNextOpponent(nextMatch, nextSide) {\n    var _a;\n    nextMatch[nextSide] = nextMatch[nextSide] && {\n        id: null,\n        position: (_a = nextMatch[nextSide]) === null || _a === void 0 ? void 0 : _a.position, // Keep position.\n    };\n    nextMatch.status = brackets_model_1.Status.Locked;\n}\nexports.resetNextOpponent = resetNextOpponent;\n/**\n * Inverts opponents if requested by the input.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n */\nfunction handleOpponentsInversion(stored, match) {\n    var _a, _b, _c, _d;\n    const id1 = (_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.id;\n    const id2 = (_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.id;\n    const storedId1 = (_c = stored.opponent1) === null || _c === void 0 ? void 0 : _c.id;\n    const storedId2 = (_d = stored.opponent2) === null || _d === void 0 ? void 0 : _d.id;\n    if (isDefined(id1) && id1 !== storedId1 && id1 !== storedId2)\n        throw Error('The given opponent1 ID does not exist in this match.');\n    if (isDefined(id2) && id2 !== storedId1 && id2 !== storedId2)\n        throw Error('The given opponent2 ID does not exist in this match.');\n    if (isDefined(id1) && id1 === storedId2 || isDefined(id2) && id2 === storedId1)\n        invertOpponents(match);\n}\nexports.handleOpponentsInversion = handleOpponentsInversion;\n/**\n * Sets the `result` of both opponents based on their scores.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n */\nfunction handleGivenStatus(stored, match) {\n    var _a, _b, _c, _d;\n    if (match.status === brackets_model_1.Status.Running) {\n        (_a = stored.opponent1) === null || _a === void 0 ? true : delete _a.result;\n        (_b = stored.opponent2) === null || _b === void 0 ? true : delete _b.result;\n        stored.status = brackets_model_1.Status.Running;\n    }\n    else if (match.status === brackets_model_1.Status.Completed) {\n        if (((_c = match.opponent1) === null || _c === void 0 ? void 0 : _c.score) === undefined || ((_d = match.opponent2) === null || _d === void 0 ? void 0 : _d.score) === undefined)\n            return;\n        if (match.opponent1.score > match.opponent2.score)\n            match.opponent1.result = 'win';\n        else if (match.opponent2.score > match.opponent1.score)\n            match.opponent2.result = 'win';\n        else {\n            // This will throw in an elimination stage.\n            match.opponent1.result = 'draw';\n            match.opponent2.result = 'draw';\n        }\n        stored.status = brackets_model_1.Status.Completed;\n    }\n}\nexports.handleGivenStatus = handleGivenStatus;\n/**\n * Inverts `opponent1` and `opponent2` in a match.\n *\n * @param match A match to update.\n */\nfunction invertOpponents(match) {\n    [match.opponent1, match.opponent2] = [match.opponent2, match.opponent1];\n}\nexports.invertOpponents = invertOpponents;\n/**\n * Updates the scores of a match.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n * @returns `true` if the status of the match changed, `false` otherwise.\n */\nfunction setScores(stored, match) {\n    var _a, _b, _c, _d;\n    // Skip if no score update.\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.score) === ((_b = stored.opponent1) === null || _b === void 0 ? void 0 : _b.score) && ((_c = match.opponent2) === null || _c === void 0 ? void 0 : _c.score) === ((_d = stored.opponent2) === null || _d === void 0 ? void 0 : _d.score))\n        return false;\n    const oldStatus = stored.status;\n    stored.status = brackets_model_1.Status.Running;\n    if (match.opponent1 && stored.opponent1)\n        stored.opponent1.score = match.opponent1.score;\n    if (match.opponent2 && stored.opponent2)\n        stored.opponent2.score = match.opponent2.score;\n    return stored.status !== oldStatus;\n}\nexports.setScores = setScores;\n/**\n * Infers the win result based on BYEs.\n *\n * @param opponent1 Opponent 1.\n * @param opponent2 Opponent 2.\n */\nfunction getInferredResult(opponent1, opponent2) {\n    if (opponent1 && !opponent2) // someone vs. BYE\n        return { opponent1: { ...opponent1, result: 'win' }, opponent2: null };\n    if (!opponent1 && opponent2) // BYE vs. someone\n        return { opponent1: null, opponent2: { ...opponent2, result: 'win' } };\n    return { opponent1, opponent2 }; // Do nothing if both BYE or both someone\n}\nexports.getInferredResult = getInferredResult;\n/**\n * Completes a match and handles results and forfeits.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n * @param inRoundRobin Indicates whether the match is in a round-robin stage.\n */\nfunction setCompleted(stored, match, inRoundRobin) {\n    stored.status = brackets_model_1.Status.Completed;\n    setResults(stored, match, 'win', 'loss', inRoundRobin);\n    setResults(stored, match, 'loss', 'win', inRoundRobin);\n    setResults(stored, match, 'draw', 'draw', inRoundRobin);\n    const { opponent1, opponent2 } = getInferredResult(stored.opponent1, stored.opponent2);\n    stored.opponent1 = opponent1;\n    stored.opponent2 = opponent2;\n    setForfeits(stored, match);\n}\nexports.setCompleted = setCompleted;\n/**\n * Enforces the symmetry between opponents.\n *\n * Sets an opponent's result to something, based on the result on the other opponent.\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n * @param check A result to check in each opponent.\n * @param change A result to set in each other opponent if `check` is correct.\n * @param inRoundRobin Indicates whether the match is in a round-robin stage.\n */\nfunction setResults(stored, match, check, change, inRoundRobin) {\n    var _a, _b;\n    if (match.opponent1 && match.opponent2) {\n        if (match.opponent1.result === 'win' && match.opponent2.result === 'win')\n            throw Error('There are two winners.');\n        if (match.opponent1.result === 'loss' && match.opponent2.result === 'loss')\n            throw Error('There are two losers.');\n        if (!inRoundRobin && match.opponent1.forfeit === true && match.opponent2.forfeit === true)\n            throw Error('There are two forfeits.');\n    }\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.result) === check) {\n        if (stored.opponent1)\n            stored.opponent1.result = check;\n        else\n            stored.opponent1 = { id: null, result: check };\n        if (stored.opponent2)\n            stored.opponent2.result = change;\n        else\n            stored.opponent2 = { id: null, result: change };\n    }\n    if (((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.result) === check) {\n        if (stored.opponent2)\n            stored.opponent2.result = check;\n        else\n            stored.opponent2 = { id: null, result: check };\n        if (stored.opponent1)\n            stored.opponent1.result = change;\n        else\n            stored.opponent1 = { id: null, result: change };\n    }\n}\nexports.setResults = setResults;\n/**\n * Sets forfeits for each opponent (if needed).\n *\n * @param stored A reference to what will be updated in the storage.\n * @param match Input of the update.\n */\nfunction setForfeits(stored, match) {\n    var _a, _b, _c, _d;\n    if (((_a = match.opponent1) === null || _a === void 0 ? void 0 : _a.forfeit) === true && ((_b = match.opponent2) === null || _b === void 0 ? void 0 : _b.forfeit) === true) {\n        if (stored.opponent1)\n            stored.opponent1.forfeit = true;\n        if (stored.opponent2)\n            stored.opponent2.forfeit = true;\n        // Don't set any result (win/draw/loss) with a double forfeit \n        // so that it doesn't count any point in the ranking.\n        return;\n    }\n    if (((_c = match.opponent1) === null || _c === void 0 ? void 0 : _c.forfeit) === true) {\n        if (stored.opponent1)\n            stored.opponent1.forfeit = true;\n        if (stored.opponent2)\n            stored.opponent2.result = 'win';\n        else\n            stored.opponent2 = { id: null, result: 'win' };\n    }\n    if (((_d = match.opponent2) === null || _d === void 0 ? void 0 : _d.forfeit) === true) {\n        if (stored.opponent2)\n            stored.opponent2.forfeit = true;\n        if (stored.opponent1)\n            stored.opponent1.result = 'win';\n        else\n            stored.opponent1 = { id: null, result: 'win' };\n    }\n}\nexports.setForfeits = setForfeits;\n/**\n * Indicates if a seeding is filled with participants' IDs.\n *\n * @param seeding The seeding.\n */\nfunction isSeedingWithIds(seeding) {\n    return seeding.some(value => typeof value === 'number');\n}\nexports.isSeedingWithIds = isSeedingWithIds;\n/**\n * Extracts participants from a seeding, without the BYEs.\n *\n * @param tournamentId ID of the tournament.\n * @param seeding The seeding (no IDs).\n */\nfunction extractParticipantsFromSeeding(tournamentId, seeding) {\n    const withoutByes = seeding.filter((name) => name !== null);\n    const participants = withoutByes.map((item) => {\n        if (typeof item === 'string') {\n            return {\n                tournament_id: tournamentId,\n                name: item,\n            };\n        }\n        return {\n            ...item,\n            tournament_id: tournamentId,\n            name: item.name,\n        };\n    });\n    return participants;\n}\nexports.extractParticipantsFromSeeding = extractParticipantsFromSeeding;\n/**\n * Returns participant slots mapped to the instances stored in the database thanks to their name.\n *\n * @param seeding The seeding.\n * @param database The participants stored in the database.\n * @param positions An optional list of positions (seeds) for a manual ordering.\n */\nfunction mapParticipantsNamesToDatabase(seeding, database, positions) {\n    return mapParticipantsToDatabase('name', seeding, database, positions);\n}\nexports.mapParticipantsNamesToDatabase = mapParticipantsNamesToDatabase;\n/**\n * Returns participant slots mapped to the instances stored in the database thanks to their id.\n *\n * @param seeding The seeding.\n * @param database The participants stored in the database.\n * @param positions An optional list of positions (seeds) for a manual ordering.\n */\nfunction mapParticipantsIdsToDatabase(seeding, database, positions) {\n    return mapParticipantsToDatabase('id', seeding, database, positions);\n}\nexports.mapParticipantsIdsToDatabase = mapParticipantsIdsToDatabase;\n/**\n * Returns participant slots mapped to the instances stored in the database thanks to a property of theirs.\n *\n * @param prop The property to search participants with.\n * @param seeding The seeding.\n * @param database The participants stored in the database.\n * @param positions An optional list of positions (seeds) for a manual ordering.\n */\nfunction mapParticipantsToDatabase(prop, seeding, database, positions) {\n    const slots = seeding.map((slot, i) => {\n        if (slot === null)\n            return null; // BYE.\n        const found = database.find(participant => typeof slot === 'object' ? participant[prop] === slot[prop] : participant[prop] === slot);\n        if (!found)\n            throw Error(`Participant ${prop} not found in database.`);\n        return { id: found.id, position: i + 1 };\n    });\n    if (!positions)\n        return slots;\n    if (positions.length !== slots.length)\n        throw Error('Not enough seeds in at least one group of the manual ordering.');\n    return positions.map(position => slots[position - 1]); // Because `position` is `i + 1`.\n}\nexports.mapParticipantsToDatabase = mapParticipantsToDatabase;\n/**\n * Converts a list of matches to a seeding.\n *\n * @param matches The input matches.\n */\nfunction convertMatchesToSeeding(matches) {\n    const flattened = [].concat(...matches.map(match => [match.opponent1, match.opponent2]));\n    return sortSeeding(flattened);\n}\nexports.convertMatchesToSeeding = convertMatchesToSeeding;\n/**\n * Converts a list of slots to an input seeding.\n *\n * @param slots The slots to convert.\n */\nfunction convertSlotsToSeeding(slots) {\n    return slots.map(slot => {\n        if (slot === null || slot.id === null)\n            return null; // BYE or TBD.\n        return slot.id; // Let's return the ID instead of the name to be sure we keep the same reference.\n    });\n}\nexports.convertSlotsToSeeding = convertSlotsToSeeding;\n/**\n * Sorts the seeding with the BYEs in the correct position.\n *\n * @param slots A list of slots to sort.\n */\nfunction sortSeeding(slots) {\n    const withoutByes = slots.filter(v => v !== null);\n    // a and b are not null because of the filter.\n    // The slots are from seeding slots, thus they have a position.\n    withoutByes.sort((a, b) => a.position - b.position);\n    if (withoutByes.length === slots.length)\n        return withoutByes;\n    // Same for v and position.\n    const placed = Object.fromEntries(withoutByes.map(v => [v.position - 1, v]));\n    const sortedWithByes = Array.from({ length: slots.length }, (_, i) => placed[i] || null);\n    return sortedWithByes;\n}\nexports.sortSeeding = sortSeeding;\n/**\n * Returns only the non null elements.\n *\n * @param array The array to process.\n */\nfunction getNonNull(array) {\n    // Use a TS type guard to exclude null from the resulting type.\n    const nonNull = array.filter((element) => element !== null);\n    return nonNull;\n}\nexports.getNonNull = getNonNull;\n/**\n * Returns a list of objects which have unique values of a specific key.\n *\n * @param array The array to process.\n * @param key The key to filter by.\n */\nfunction uniqueBy(array, key) {\n    const seen = new Set();\n    return array.filter(item => {\n        const value = key(item);\n        if (!value)\n            return true;\n        if (seen.has(value))\n            return false;\n        seen.add(value);\n        return true;\n    });\n}\nexports.uniqueBy = uniqueBy;\n/**\n * Indicates whether the loser bracket round is major.\n *\n * @param roundNumber Number of the round.\n */\nfunction isMajorRound(roundNumber) {\n    return roundNumber % 2 === 1;\n}\nexports.isMajorRound = isMajorRound;\n/**\n * Indicates whether the loser bracket round is minor.\n *\n * @param roundNumber Number of the round.\n */\nfunction isMinorRound(roundNumber) {\n    return !isMajorRound(roundNumber);\n}\nexports.isMinorRound = isMinorRound;\n/**\n * Makes the transition to a major round for duels of the previous round. The duel count is divided by 2.\n *\n * @param previousDuels The previous duels to transition from.\n */\nfunction transitionToMajor(previousDuels) {\n    const currentDuelCount = previousDuels.length / 2;\n    const currentDuels = [];\n    for (let duelIndex = 0; duelIndex < currentDuelCount; duelIndex++) {\n        const prevDuelId = duelIndex * 2;\n        currentDuels.push([\n            byeWinner(previousDuels[prevDuelId]),\n            byeWinner(previousDuels[prevDuelId + 1]),\n        ]);\n    }\n    return currentDuels;\n}\nexports.transitionToMajor = transitionToMajor;\n/**\n * Makes the transition to a minor round for duels of the previous round. The duel count stays the same.\n *\n * @param previousDuels The previous duels to transition from.\n * @param losers Losers from the previous major round.\n * @param method The ordering method for the losers.\n */\nfunction transitionToMinor(previousDuels, losers, method) {\n    const orderedLosers = method ? ordering_1.ordering[method](losers) : losers;\n    const currentDuelCount = previousDuels.length;\n    const currentDuels = [];\n    for (let duelIndex = 0; duelIndex < currentDuelCount; duelIndex++) {\n        const prevDuelId = duelIndex;\n        currentDuels.push([\n            orderedLosers[prevDuelId],\n            byeWinner(previousDuels[prevDuelId]),\n        ]);\n    }\n    return currentDuels;\n}\nexports.transitionToMinor = transitionToMinor;\n/**\n * Sets the parent match to a completed status if all its child games are completed.\n *\n * @param parent The partial parent match to update.\n * @param childCount Child count of this parent match.\n * @param inRoundRobin Indicates whether the parent match is in a round-robin stage.\n */\nfunction setParentMatchCompleted(parent, childCount, inRoundRobin) {\n    var _a, _b;\n    if (((_a = parent.opponent1) === null || _a === void 0 ? void 0 : _a.score) === undefined || ((_b = parent.opponent2) === null || _b === void 0 ? void 0 : _b.score) === undefined)\n        throw Error('Either opponent1, opponent2 or their scores are falsy.');\n    const minToWin = minScoreToWinBestOfX(childCount);\n    if (parent.opponent1.score >= minToWin) {\n        parent.opponent1.result = 'win';\n        return;\n    }\n    if (parent.opponent2.score >= minToWin) {\n        parent.opponent2.result = 'win';\n        return;\n    }\n    if (parent.opponent1.score === parent.opponent2.score && parent.opponent1.score + parent.opponent2.score > childCount - 1) {\n        if (inRoundRobin) {\n            parent.opponent1.result = 'draw';\n            parent.opponent2.result = 'draw';\n            return;\n        }\n        throw Error('Match games result in a tie for the parent match.');\n    }\n}\nexports.setParentMatchCompleted = setParentMatchCompleted;\n/**\n * Returns a parent match results based on its child games scores.\n *\n * @param storedParent The parent match stored in the database.\n * @param scores The scores of the match child games.\n */\nfunction getParentMatchResults(storedParent, scores) {\n    return {\n        opponent1: {\n            id: storedParent.opponent1 && storedParent.opponent1.id,\n            score: scores.opponent1,\n        },\n        opponent2: {\n            id: storedParent.opponent2 && storedParent.opponent2.id,\n            score: scores.opponent2,\n        },\n    };\n}\nexports.getParentMatchResults = getParentMatchResults;\n/**\n * Gets the values which need to be updated in a match when it's updated on insertion.\n *\n * @param match The up to date match.\n * @param existing The base match.\n * @param enableByes Whether to use BYEs or TBDs for `null` values in an input seeding.\n */\nfunction getUpdatedMatchResults(match, existing, enableByes) {\n    return {\n        ...existing,\n        ...match,\n        ...(enableByes ? {\n            opponent1: match.opponent1 === null ? null : { ...existing.opponent1, ...match.opponent1 },\n            opponent2: match.opponent2 === null ? null : { ...existing.opponent2, ...match.opponent2 },\n        } : {\n            opponent1: match.opponent1 === null ? { id: null } : { ...existing.opponent1, ...match.opponent1 },\n            opponent2: match.opponent2 === null ? { id: null } : { ...existing.opponent2, ...match.opponent2 },\n        }),\n    };\n}\nexports.getUpdatedMatchResults = getUpdatedMatchResults;\n/**\n * Calculates the score of a parent match based on its child games.\n *\n * @param games The child games to process.\n */\nfunction getChildGamesResults(games) {\n    const scores = {\n        opponent1: 0,\n        opponent2: 0,\n    };\n    for (const game of games) {\n        const result = getMatchResult(game);\n        if (result === 'opponent1')\n            scores.opponent1++;\n        else if (result === 'opponent2')\n            scores.opponent2++;\n    }\n    return scores;\n}\nexports.getChildGamesResults = getChildGamesResults;\n/**\n * Gets the default list of seeds for a round's matches.\n *\n * @param inLoserBracket Whether the match is in the loser bracket.\n * @param roundNumber The number of the current round.\n * @param roundCountLB The count of rounds in loser bracket.\n * @param matchCount The count of matches in the round.\n */\nfunction getSeeds(inLoserBracket, roundNumber, roundCountLB, matchCount) {\n    const seedCount = getSeedCount(inLoserBracket, roundNumber, roundCountLB, matchCount);\n    return Array.from({ length: seedCount }, (_, i) => i + 1);\n}\nexports.getSeeds = getSeeds;\n/**\n * Gets the number of seeds for a round's matches.\n *\n * @param inLoserBracket Whether the match is in the loser bracket.\n * @param roundNumber The number of the current round.\n * @param roundCountLB The count of rounds in loser bracket.\n * @param matchCount The count of matches in the round.\n */\nfunction getSeedCount(inLoserBracket, roundNumber, roundCountLB, matchCount) {\n    ensureOrderingSupported(inLoserBracket, roundNumber, roundCountLB);\n    return roundNumber === 1 ?\n        matchCount * 2 : // Two per match for upper or lower bracket round 1.\n        matchCount; // One per match for loser bracket minor rounds.\n}\nexports.getSeedCount = getSeedCount;\n/**\n * Throws if the ordering is not supported on the given round number.\n *\n * @param inLoserBracket Whether the match is in the loser bracket.\n * @param roundNumber The number of the round.\n * @param roundCountLB The count of rounds in loser bracket.\n */\nfunction ensureOrderingSupported(inLoserBracket, roundNumber, roundCountLB) {\n    if (inLoserBracket && !isOrderingSupportedLoserBracket(roundNumber, roundCountLB))\n        throw Error('This round does not support ordering.');\n    if (!inLoserBracket && !isOrderingSupportedUpperBracket(roundNumber))\n        throw Error('This round does not support ordering.');\n}\nexports.ensureOrderingSupported = ensureOrderingSupported;\n/**\n * Indicates whether the ordering is supported in upper bracket, given the round number.\n *\n * @param roundNumber The number of the round.\n */\nfunction isOrderingSupportedUpperBracket(roundNumber) {\n    return roundNumber === 1;\n}\nexports.isOrderingSupportedUpperBracket = isOrderingSupportedUpperBracket;\n/**\n * Indicates whether the ordering is supported in loser bracket, given the round number.\n *\n * @param roundNumber The number of the round.\n * @param roundCount The count of rounds.\n */\nfunction isOrderingSupportedLoserBracket(roundNumber, roundCount) {\n    return roundNumber === 1 || (isMinorRound(roundNumber) && roundNumber < roundCount);\n}\nexports.isOrderingSupportedLoserBracket = isOrderingSupportedLoserBracket;\n/**\n * Returns the number of rounds an upper bracket has given the number of participants in the stage.\n *\n * @param participantCount The number of participants in the stage.\n */\nfunction getUpperBracketRoundCount(participantCount) {\n    return Math.log2(participantCount);\n}\nexports.getUpperBracketRoundCount = getUpperBracketRoundCount;\n/**\n * Returns the count of round pairs (major & minor) in a loser bracket.\n *\n * @param participantCount The number of participants in the stage.\n */\nfunction getRoundPairCount(participantCount) {\n    return getUpperBracketRoundCount(participantCount) - 1;\n}\nexports.getRoundPairCount = getRoundPairCount;\n/**\n * Determines whether a double elimination stage is really necessary.\n *\n * If the size is only two (less is impossible), then a lower bracket and a grand final are not necessary.\n *\n * @param participantCount The number of participants in the stage.\n */\nfunction isDoubleEliminationNecessary(participantCount) {\n    return participantCount > 2;\n}\nexports.isDoubleEliminationNecessary = isDoubleEliminationNecessary;\n/**\n * Returns the real (because of loser ordering) number of a match in a loser bracket.\n *\n * @param participantCount The number of participants in a stage.\n * @param roundNumber Number of the round.\n * @param matchNumber Number of the match.\n * @param method The method used for the round.\n */\nfunction findLoserMatchNumber(participantCount, roundNumber, matchNumber, method) {\n    const loserCount = getLoserCountFromWbForLbRound(participantCount, roundNumber);\n    const losers = Array.from({ length: loserCount }, (_, i) => i + 1);\n    const ordered = method ? ordering_1.ordering[method](losers) : losers;\n    const matchNumberLB = ordered.indexOf(matchNumber) + 1;\n    // For LB round 1, the list of losers is spread over the matches 2 by 2.\n    if (roundNumber === 1)\n        return Math.ceil(matchNumberLB / 2);\n    return matchNumberLB;\n}\nexports.findLoserMatchNumber = findLoserMatchNumber;\n/**\n * Returns the count of matches in a round of a loser bracket.\n *\n * @param participantCount The number of participants in a stage.\n * @param roundNumber Number of the round.\n */\nfunction getLoserRoundMatchCount(participantCount, roundNumber) {\n    const roundPairIndex = Math.ceil(roundNumber / 2) - 1;\n    const roundPairCount = getRoundPairCount(participantCount);\n    const matchCount = Math.pow(2, roundPairCount - roundPairIndex - 1);\n    if (roundNumber === 0)\n        throw Error('Round number must start at 1.');\n    if (matchCount < 1)\n        throw Error(`Round number ${roundNumber} is too big for a loser bracket in a stage of ${participantCount} participants.`);\n    return matchCount;\n}\nexports.getLoserRoundMatchCount = getLoserRoundMatchCount;\n/**\n * Returns the count of losers coming from the winner bracket in a round of loser bracket.\n *\n * @param participantCount The number of participants in the stage.\n * @param roundNumber Number of the round.\n */\nfunction getLoserCountFromWbForLbRound(participantCount, roundNumber) {\n    const matchCount = getLoserRoundMatchCount(participantCount, roundNumber);\n    // Two per match for LB round 1 (losers coming from WB round 1).\n    if (roundNumber === 1)\n        return matchCount * 2;\n    return matchCount; // One per match for LB minor rounds.\n}\nexports.getLoserCountFromWbForLbRound = getLoserCountFromWbForLbRound;\n/**\n * Returns the ordering method of a round of a loser bracket.\n *\n * @param seedOrdering The list of seed orderings.\n * @param roundNumber Number of the round.\n */\nfunction getLoserOrdering(seedOrdering, roundNumber) {\n    const orderingIndex = 1 + Math.floor(roundNumber / 2);\n    return seedOrdering[orderingIndex];\n}\nexports.getLoserOrdering = getLoserOrdering;\n/**\n * Returns the number of rounds a lower bracket has given the number of participants in a double elimination stage.\n *\n * @param participantCount The number of participants in the stage.\n */\nfunction getLowerBracketRoundCount(participantCount) {\n    const roundPairCount = getRoundPairCount(participantCount);\n    return roundPairCount * 2;\n}\nexports.getLowerBracketRoundCount = getLowerBracketRoundCount;\n/**\n * Returns the match number of the corresponding match in the next round by dividing by two.\n *\n * @param matchNumber The current match number.\n */\nfunction getDiagonalMatchNumber(matchNumber) {\n    return Math.ceil(matchNumber / 2);\n}\nexports.getDiagonalMatchNumber = getDiagonalMatchNumber;\n/**\n * Returns the nearest power of two **greater than** or equal to the given number.\n *\n * @param input The input number.\n */\nfunction getNearestPowerOfTwo(input) {\n    return Math.pow(2, Math.ceil(Math.log2(input)));\n}\nexports.getNearestPowerOfTwo = getNearestPowerOfTwo;\n/**\n * Returns the minimum score a participant must have to win a Best Of X series match.\n *\n * @param x The count of child games in the series.\n */\nfunction minScoreToWinBestOfX(x) {\n    return (x + 1) / 2;\n}\nexports.minScoreToWinBestOfX = minScoreToWinBestOfX;\n/**\n * Checks if a stage is a round-robin stage.\n *\n * @param stage The stage to check.\n */\nfunction isRoundRobin(stage) {\n    return stage.type === 'round_robin';\n}\nexports.isRoundRobin = isRoundRobin;\n/**\n * Throws if a stage is round-robin.\n *\n * @param stage The stage to check.\n */\nfunction ensureNotRoundRobin(stage) {\n    const inRoundRobin = isRoundRobin(stage);\n    if (inRoundRobin)\n        throw Error('Impossible to update ordering in a round-robin stage.');\n}\nexports.ensureNotRoundRobin = ensureNotRoundRobin;\n// TODO: delete this helper in a future release.\n/**\n * Checks if a round is completed based on its matches.\n *\n * @param roundMatches Matches of the round.\n * @deprecated This is both functionally and semantically incorrect because:\n * 1. A match could be completed because of BYEs.\n * 2. You could totally give a list of matches from different rounds to this function, and it wouldn't complain\n *    although the result will **not** tell you whether a _round_ is completed.\n *\n * Please do something like `matches.every(m => isMatchCompleted(m))` instead.\n */\nfunction isRoundCompleted(roundMatches) {\n    return roundMatches.every(match => match.status >= brackets_model_1.Status.Completed);\n}\nexports.isRoundCompleted = isRoundCompleted;\n/**\n * Checks if a group is a winner bracket.\n *\n * It's not always the opposite of `inLoserBracket()`: it could be the only bracket of a single elimination stage.\n *\n * @param stageType Type of the stage.\n * @param groupNumber Number of the group.\n */\nfunction isWinnerBracket(stageType, groupNumber) {\n    return stageType === 'double_elimination' && groupNumber === 1;\n}\nexports.isWinnerBracket = isWinnerBracket;\n/**\n * Checks if a group is a loser bracket.\n *\n * @param stageType Type of the stage.\n * @param groupNumber Number of the group.\n */\nfunction isLoserBracket(stageType, groupNumber) {\n    return stageType === 'double_elimination' && groupNumber === 2;\n}\nexports.isLoserBracket = isLoserBracket;\n/**\n * Checks if a group is a final group (consolation final or grand final).\n *\n * @param stageType Type of the stage.\n * @param groupNumber Number of the group.\n */\nfunction isFinalGroup(stageType, groupNumber) {\n    return stageType === 'single_elimination' && groupNumber === 2 ||\n        stageType === 'double_elimination' && groupNumber === 3;\n}\nexports.isFinalGroup = isFinalGroup;\n/**\n * Returns the type of group the match is located into.\n *\n * @param stageType Type of the stage.\n * @param groupNumber Number of the group.\n */\nfunction getMatchLocation(stageType, groupNumber) {\n    if (isWinnerBracket(stageType, groupNumber))\n        return 'winner_bracket';\n    if (isLoserBracket(stageType, groupNumber))\n        return 'loser_bracket';\n    if (isFinalGroup(stageType, groupNumber))\n        return 'final_group';\n    return 'single_bracket';\n}\nexports.getMatchLocation = getMatchLocation;\n/**\n * Returns the fraction of final for the current round (e.g. `1/2` for semi finals or `1/4` for quarter finals).\n *\n * @param roundNumber Number of the current round.\n * @param roundCount Count of rounds.\n */\nfunction getFractionOfFinal(roundNumber, roundCount) {\n    if (roundNumber > roundCount)\n        throw Error(`There are more rounds than possible. ${JSON.stringify({ roundNumber, roundCount })}`);\n    const denominator = Math.pow(2, roundCount - roundNumber);\n    return 1 / denominator;\n}\nexports.getFractionOfFinal = getFractionOfFinal;\n//# sourceMappingURL=helpers.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/helpers.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/brackets-manager/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StageCreator = exports.Delete = exports.Reset = exports.Find = exports.Update = exports.Get = exports.ordering = exports.helpers = exports.BracketsManager = void 0;\nvar manager_1 = __webpack_require__(/*! ./manager */ \"./node_modules/brackets-manager/dist/manager.js\");\nObject.defineProperty(exports, \"BracketsManager\", ({ enumerable: true, get: function () { return manager_1.BracketsManager; } }));\nexports.helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nvar ordering_1 = __webpack_require__(/*! ./ordering */ \"./node_modules/brackets-manager/dist/ordering.js\");\nObject.defineProperty(exports, \"ordering\", ({ enumerable: true, get: function () { return ordering_1.ordering; } }));\nvar get_1 = __webpack_require__(/*! ./get */ \"./node_modules/brackets-manager/dist/get.js\");\nObject.defineProperty(exports, \"Get\", ({ enumerable: true, get: function () { return get_1.Get; } }));\nvar update_1 = __webpack_require__(/*! ./update */ \"./node_modules/brackets-manager/dist/update.js\");\nObject.defineProperty(exports, \"Update\", ({ enumerable: true, get: function () { return update_1.Update; } }));\nvar find_1 = __webpack_require__(/*! ./find */ \"./node_modules/brackets-manager/dist/find.js\");\nObject.defineProperty(exports, \"Find\", ({ enumerable: true, get: function () { return find_1.Find; } }));\nvar reset_1 = __webpack_require__(/*! ./reset */ \"./node_modules/brackets-manager/dist/reset.js\");\nObject.defineProperty(exports, \"Reset\", ({ enumerable: true, get: function () { return reset_1.Reset; } }));\nvar delete_1 = __webpack_require__(/*! ./delete */ \"./node_modules/brackets-manager/dist/delete.js\");\nObject.defineProperty(exports, \"Delete\", ({ enumerable: true, get: function () { return delete_1.Delete; } }));\nvar creator_1 = __webpack_require__(/*! ./base/stage/creator */ \"./node_modules/brackets-manager/dist/base/stage/creator.js\");\nObject.defineProperty(exports, \"StageCreator\", ({ enumerable: true, get: function () { return creator_1.StageCreator; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/index.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/manager.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BracketsManager = void 0;\nconst create_1 = __webpack_require__(/*! ./create */ \"./node_modules/brackets-manager/dist/create.js\");\nconst get_1 = __webpack_require__(/*! ./get */ \"./node_modules/brackets-manager/dist/get.js\");\nconst update_1 = __webpack_require__(/*! ./update */ \"./node_modules/brackets-manager/dist/update.js\");\nconst delete_1 = __webpack_require__(/*! ./delete */ \"./node_modules/brackets-manager/dist/delete.js\");\nconst find_1 = __webpack_require__(/*! ./find */ \"./node_modules/brackets-manager/dist/find.js\");\nconst reset_1 = __webpack_require__(/*! ./reset */ \"./node_modules/brackets-manager/dist/reset.js\");\nconst uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/commonjs-browser/index.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\n/**\n * A class to handle tournament management at those levels: `stage`, `group`, `round`, `match` and `match_game`.\n */\nclass BracketsManager {\n    /**\n     * Creates an instance of BracketsManager, which will handle all the stuff from the library.\n     *\n     * @param storageInterface An implementation of CrudInterface.\n     * @param verbose Whether to log CRUD operations.\n     */\n    constructor(storageInterface, verbose) {\n        this.verbose = false;\n        this.verbose = verbose !== null && verbose !== void 0 ? verbose : false;\n        this.storage = storageInterface;\n        this.instrumentStorage();\n        // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n        this.storage.selectFirst = async (table, filter, assertUnique = true) => {\n            var _a;\n            const results = await this.storage.select(table, filter);\n            if (!results || results.length === 0)\n                return null;\n            if (assertUnique && results.length > 1)\n                throw Error(`Selecting ${JSON.stringify(filter)} on table \"${table}\" must return a unique value.`);\n            return (_a = results[0]) !== null && _a !== void 0 ? _a : null;\n        };\n        // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n        this.storage.selectLast = async (table, filter, assertUnique = true) => {\n            var _a;\n            const results = await this.storage.select(table, filter);\n            if (!results || results.length === 0)\n                return null;\n            if (assertUnique && results.length > 1)\n                throw Error(`Selecting ${JSON.stringify(filter)} on table \"${table}\" must return a unique value.`);\n            return (_a = results[results.length - 1]) !== null && _a !== void 0 ? _a : null;\n        };\n        const create = new create_1.Create(this.storage);\n        const createStageFunction = create.stage.bind(this);\n        this.create = Object.assign(createStageFunction, { stage: createStageFunction });\n        this.get = new get_1.Get(this.storage);\n        this.update = new update_1.Update(this.storage);\n        this.delete = new delete_1.Delete(this.storage);\n        this.find = new find_1.Find(this.storage);\n        this.reset = new reset_1.Reset(this.storage);\n    }\n    /**\n     * Imports data in the database.\n     *\n     * @param data Data to import.\n     * @param normalizeIds Enable ID normalization: all IDs (and references to them) are remapped to consecutive IDs starting from 0.\n     */\n    async import(data, normalizeIds = false) {\n        if (normalizeIds)\n            data = helpers.normalizeIds(data);\n        if (!await this.storage.delete('participant'))\n            throw Error('Could not empty the participant table.');\n        if (!await this.storage.insert('participant', data.participant))\n            throw Error('Could not import participants.');\n        if (!await this.storage.delete('stage'))\n            throw Error('Could not empty the stage table.');\n        if (!await this.storage.insert('stage', data.stage))\n            throw Error('Could not import stages.');\n        if (!await this.storage.delete('group'))\n            throw Error('Could not empty the group table.');\n        if (!await this.storage.insert('group', data.group))\n            throw Error('Could not import groups.');\n        if (!await this.storage.delete('round'))\n            throw Error('Could not empty the round table.');\n        if (!await this.storage.insert('round', data.round))\n            throw Error('Could not import rounds.');\n        if (!await this.storage.delete('match'))\n            throw Error('Could not empty the match table.');\n        if (!await this.storage.insert('match', data.match))\n            throw Error('Could not import matches.');\n        if (!await this.storage.delete('match_game'))\n            throw Error('Could not empty the match_game table.');\n        if (!await this.storage.insert('match_game', data.match_game))\n            throw Error('Could not import match games.');\n    }\n    /**\n     * Exports data from the database.\n     */\n    async export() {\n        const participants = await this.storage.select('participant');\n        if (!participants)\n            throw Error('Error getting participants.');\n        const stages = await this.storage.select('stage');\n        if (!stages)\n            throw Error('Error getting stages.');\n        const groups = await this.storage.select('group');\n        if (!groups)\n            throw Error('Error getting groups.');\n        const rounds = await this.storage.select('round');\n        if (!rounds)\n            throw Error('Error getting rounds.');\n        const matches = await this.storage.select('match');\n        if (!matches)\n            throw Error('Error getting matches.');\n        const matchGames = await this.get.matchGames(matches);\n        return {\n            participant: participants,\n            stage: stages,\n            group: groups,\n            round: rounds,\n            match: matches,\n            match_game: matchGames,\n        };\n    }\n    /**\n     * Add `console.log()` to storage methods in verbose mode.\n     */\n    instrumentStorage() {\n        const storage = this.storage;\n        const instrumentedMethods = ['insert', 'select', 'update', 'delete'];\n        for (const method of Object.getOwnPropertyNames(Object.getPrototypeOf(storage))) {\n            if (!instrumentedMethods.includes(method))\n                continue;\n            const originalMethod = storage[method].bind(storage);\n            storage[method] = async (table, ...args) => {\n                const verbose = this.verbose;\n                let id;\n                let start;\n                if (verbose) {\n                    id = (0, uuid_1.v4)();\n                    start = Date.now();\n                    console.log(`${id} ${method.toUpperCase()} \"${table}\" args: ${JSON.stringify(args)}`);\n                }\n                const result = await originalMethod(table, ...args);\n                if (verbose) {\n                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n                    const duration = Date.now() - start;\n                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n                    console.log(`${id} ${duration}ms - Returned ${JSON.stringify(result)}`);\n                }\n                return result;\n            };\n        }\n    }\n}\nexports.BracketsManager = BracketsManager;\n//# sourceMappingURL=manager.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/manager.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/ordering.js":
/*!********************************************************!*\
  !*** ./node_modules/brackets-manager/dist/ordering.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n// https://web.archive.org/web/20200601102344/https://tl.net/forum/sc2-tournaments/202139-superior-double-elimination-losers-bracket-seeding\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultMinorOrdering = exports.ordering = void 0;\nexports.ordering = {\n    'natural': (array) => [...array],\n    'reverse': (array) => [...array].reverse(),\n    'half_shift': (array) => [...array.slice(array.length / 2), ...array.slice(0, array.length / 2)],\n    'reverse_half_shift': (array) => [...array.slice(0, array.length / 2).reverse(), ...array.slice(array.length / 2).reverse()],\n    'pair_flip': (array) => {\n        const result = [];\n        for (let i = 0; i < array.length; i += 2)\n            result.push(array[i + 1], array[i]);\n        return result;\n    },\n    'inner_outer': (array) => {\n        if (array.length === 2)\n            return array;\n        const size = array.length / 4;\n        const innerPart = [array.slice(size, 2 * size), array.slice(2 * size, 3 * size)]; // [_, X, X, _]\n        const outerPart = [array.slice(0, size), array.slice(3 * size, 4 * size)]; // [X, _, _, X]\n        const methods = {\n            inner(part) {\n                return [part[0].pop(), part[1].shift()];\n            },\n            outer(part) {\n                return [part[0].shift(), part[1].pop()];\n            },\n        };\n        const result = [];\n        /**\n         * Adds a part (inner or outer) of a part.\n         *\n         * @param part The part to process.\n         * @param method The method to use.\n         */\n        function add(part, method) {\n            if (part[0].length > 0 && part[1].length > 0)\n                result.push(...methods[method](part));\n        }\n        for (let i = 0; i < size / 2; i++) {\n            add(outerPart, 'outer'); // Outer part's outer\n            add(innerPart, 'inner'); // Inner part's inner\n            add(outerPart, 'inner'); // Outer part's inner\n            add(innerPart, 'outer'); // Inner part's outer\n        }\n        return result;\n    },\n    'groups.effort_balanced': (array, groupCount) => {\n        const result = [];\n        let i = 0, j = 0;\n        while (result.length < array.length) {\n            result.push(array[i]);\n            i += groupCount;\n            if (i >= array.length)\n                i = ++j;\n        }\n        return result;\n    },\n    'groups.seed_optimized': (array, groupCount) => {\n        const groups = Array.from({ length: groupCount }, (_) => []);\n        for (let run = 0; run < array.length / groupCount; run++) {\n            if (run % 2 === 0) {\n                for (let group = 0; group < groupCount; group++)\n                    groups[group].push(array[run * groupCount + group]);\n            }\n            else {\n                for (let group = 0; group < groupCount; group++)\n                    groups[groupCount - group - 1].push(array[run * groupCount + group]);\n            }\n        }\n        return groups.flat();\n    },\n    'groups.bracket_optimized': () => {\n        throw Error('Not implemented.');\n    },\n};\nexports.defaultMinorOrdering = {\n    // 1 or 2: Not possible.\n    4: ['natural', 'reverse'],\n    8: ['natural', 'reverse', 'natural'],\n    16: ['natural', 'reverse_half_shift', 'reverse', 'natural'],\n    32: ['natural', 'reverse', 'half_shift', 'natural', 'natural'],\n    64: ['natural', 'reverse', 'half_shift', 'reverse', 'natural', 'natural'],\n    128: ['natural', 'reverse', 'half_shift', 'pair_flip', 'pair_flip', 'pair_flip', 'natural'],\n};\n//# sourceMappingURL=ordering.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/ordering.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/reset.js":
/*!*****************************************************!*\
  !*** ./node_modules/brackets-manager/dist/reset.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Reset = void 0;\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst updater_1 = __webpack_require__(/*! ./base/updater */ \"./node_modules/brackets-manager/dist/base/updater.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass Reset extends updater_1.BaseUpdater {\n    /**\n     * Resets the results of a match.\n     *\n     * This will update related matches accordingly.\n     *\n     * @param matchId ID of the match.\n     */\n    async matchResults(matchId) {\n        const stored = await this.storage.select('match', matchId);\n        if (!stored)\n            throw Error('Match not found.');\n        // The user can handle forfeits with matches which have child games in two possible ways:\n        //\n        // 1. Set forfeits for the parent match directly.\n        //    --> The child games will never be updated: not locked, not finished, without forfeit. They will just be ignored and never be played.\n        //    --> To reset the forfeits, the user has to reset the parent match, with `reset.matchResults()`.\n        //    --> `reset.matchResults()` will be usable **only** to reset the forfeit of the parent match. Otherwise it will throw the error below.\n        //\n        // 2. Set forfeits for each child game.\n        //    --> The parent match won't automatically have a forfeit, but will be updated with a computed score according to the forfeited match games.\n        //    --> To reset the forfeits, the user has to reset each child game on its own, with `reset.matchGameResults()`.\n        //    --> `reset.matchResults()` will throw the error below in all cases.\n        if (!helpers.isMatchForfeitCompleted(stored) && stored.child_count > 0)\n            throw Error('The parent match is controlled by its child games and its result cannot be reset.');\n        const stage = await this.storage.select('stage', stored.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const group = await this.storage.select('group', stored.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const { roundNumber, roundCount } = await this.getRoundPositionalInfo(stored.round_id);\n        const matchLocation = helpers.getMatchLocation(stage.type, group.number);\n        const nextMatches = await this.getNextMatches(stored, matchLocation, stage, roundNumber, roundCount);\n        if (nextMatches.some(match => match && match.status >= brackets_model_1.Status.Running && !helpers.isMatchByeCompleted(match)))\n            throw Error('The match is locked.');\n        helpers.resetMatchResults(stored);\n        await this.applyMatchUpdate(stored);\n        if (!helpers.isRoundRobin(stage))\n            await this.updateRelatedMatches(stored, true, true);\n    }\n    /**\n     * Resets the results of a match game.\n     *\n     * @param gameId ID of the match game.\n     */\n    async matchGameResults(gameId) {\n        const stored = await this.storage.select('match_game', gameId);\n        if (!stored)\n            throw Error('Match game not found.');\n        const stage = await this.storage.select('stage', stored.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        const inRoundRobin = helpers.isRoundRobin(stage);\n        helpers.resetMatchResults(stored);\n        if (!await this.storage.update('match_game', stored.id, stored))\n            throw Error('Could not update the match game.');\n        await this.updateParentMatch(stored.parent_id, inRoundRobin);\n    }\n    /**\n     * Resets the seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     */\n    async seeding(stageId) {\n        await this.updateSeeding(stageId, { seeding: null }, false);\n    }\n}\nexports.Reset = Reset;\n//# sourceMappingURL=reset.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/reset.js?");

/***/ }),

/***/ "./node_modules/brackets-manager/dist/update.js":
/*!******************************************************!*\
  !*** ./node_modules/brackets-manager/dist/update.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Update = void 0;\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/brackets-model/dist/index.js\");\nconst ordering_1 = __webpack_require__(/*! ./ordering */ \"./node_modules/brackets-manager/dist/ordering.js\");\nconst updater_1 = __webpack_require__(/*! ./base/updater */ \"./node_modules/brackets-manager/dist/base/updater.js\");\nconst helpers = __webpack_require__(/*! ./helpers */ \"./node_modules/brackets-manager/dist/helpers.js\");\nclass Update extends updater_1.BaseUpdater {\n    /**\n     * Updates partial information of a match. Its id must be given.\n     *\n     * This will update related matches accordingly.\n     *\n     * @param match Values to change in a match.\n     */\n    async match(match) {\n        if (match.id === undefined)\n            throw Error('No match id given.');\n        const stored = await this.storage.select('match', match.id);\n        if (!stored)\n            throw Error('Match not found.');\n        await this.updateMatch(stored, match);\n    }\n    /**\n     * Updates partial information of a match game. Its id must be given.\n     *\n     * This will update the parent match accordingly.\n     *\n     * @param game Values to change in a match game.\n     */\n    async matchGame(game) {\n        const stored = await this.findMatchGame(game);\n        await this.updateMatchGame(stored, game);\n    }\n    /**\n     * Updates the seed ordering of every ordered round in a stage.\n     *\n     * @param stageId ID of the stage.\n     * @param seedOrdering A list of ordering methods.\n     */\n    async ordering(stageId, seedOrdering) {\n        const stage = await this.storage.select('stage', stageId);\n        if (!stage)\n            throw Error('Stage not found.');\n        helpers.ensureNotRoundRobin(stage);\n        const roundsToOrder = await this.getOrderedRounds(stage);\n        if (seedOrdering.length !== roundsToOrder.length)\n            throw Error('The count of seed orderings is incorrect.');\n        for (let i = 0; i < roundsToOrder.length; i++)\n            await this.updateRoundOrdering(roundsToOrder[i], seedOrdering[i]);\n    }\n    /**\n     * Updates the seed ordering of a round.\n     *\n     * @param roundId ID of the round.\n     * @param method Seed ordering method.\n     */\n    async roundOrdering(roundId, method) {\n        const round = await this.storage.select('round', roundId);\n        if (!round)\n            throw Error('This round does not exist.');\n        const stage = await this.storage.select('stage', round.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        helpers.ensureNotRoundRobin(stage);\n        await this.updateRoundOrdering(round, method);\n    }\n    /**\n     * Updates child count of all matches of a given level.\n     *\n     * @param level The level at which to act.\n     * @param id ID of the chosen level.\n     * @param childCount The target child count.\n     */\n    async matchChildCount(level, id, childCount) {\n        switch (level) {\n            case 'stage':\n                await this.updateStageMatchChildCount(id, childCount);\n                break;\n            case 'group':\n                await this.updateGroupMatchChildCount(id, childCount);\n                break;\n            case 'round':\n                await this.updateRoundMatchChildCount(id, childCount);\n                break;\n            case 'match':\n                const match = await this.storage.select('match', id);\n                if (!match)\n                    throw Error('Match not found.');\n                await this.adjustMatchChildGames(match, childCount);\n                break;\n            default:\n                throw Error('Unknown child count level.');\n        }\n    }\n    /**\n     * Updates the seeding of a stage.\n     *\n     * @param stageId ID of the stage.\n     * @param seeding The new seeding.\n     * @param keepSameSize Whether to keep the same size as before for the stage. **Default:** false.\n     */\n    async seeding(stageId, seeding, keepSameSize = false) {\n        await this.updateSeeding(stageId, { seeding }, keepSameSize);\n    }\n    /**\n     * Updates the seeding of a stage (with a list of IDs).\n     *\n     * @param stageId ID of the stage.\n     * @param seedingIds The new seeding, containing only IDs.\n     * @param keepSameSize Whether to keep the same size as before for the stage. **Default:** false.\n     */\n    async seedingIds(stageId, seedingIds, keepSameSize = false) {\n        await this.updateSeeding(stageId, { seedingIds }, keepSameSize);\n    }\n    /**\n     * Confirms the seeding of a stage.\n     *\n     * This will convert TBDs to BYEs and propagate them.\n     *\n     * @param stageId ID of the stage.\n     */\n    async confirmSeeding(stageId) {\n        await this.confirmCurrentSeeding(stageId);\n    }\n    /**\n     * Update the seed ordering of a round.\n     *\n     * @param round The round of which to update the ordering.\n     * @param method The new ordering method.\n     */\n    async updateRoundOrdering(round, method) {\n        const matches = await this.storage.select('match', { round_id: round.id });\n        if (!matches)\n            throw Error('This round has no match.');\n        if (matches.some(match => match.status > brackets_model_1.Status.Ready))\n            throw Error('At least one match has started or is completed.');\n        const stage = await this.storage.select('stage', round.stage_id);\n        if (!stage)\n            throw Error('Stage not found.');\n        if (stage.settings.size === undefined)\n            throw Error('Undefined stage size.');\n        const group = await this.storage.select('group', round.group_id);\n        if (!group)\n            throw Error('Group not found.');\n        const inLoserBracket = helpers.isLoserBracket(stage.type, group.number);\n        const roundCountLB = helpers.getLowerBracketRoundCount(stage.settings.size);\n        const seeds = helpers.getSeeds(inLoserBracket, round.number, roundCountLB, matches.length);\n        const positions = ordering_1.ordering[method](seeds);\n        await this.applyRoundOrdering(round.number, matches, positions);\n    }\n    /**\n     * Updates child count of all matches of a stage.\n     *\n     * @param stageId ID of the stage.\n     * @param childCount The target child count.\n     */\n    async updateStageMatchChildCount(stageId, childCount) {\n        if (!await this.storage.update('match', { stage_id: stageId }, { child_count: childCount }))\n            throw Error('Could not update the match.');\n        const matches = await this.storage.select('match', { stage_id: stageId });\n        if (!matches)\n            throw Error('This stage has no match.');\n        for (const match of matches)\n            await this.adjustMatchChildGames(match, childCount);\n    }\n    /**\n     * Updates child count of all matches of a group.\n     *\n     * @param groupId ID of the group.\n     * @param childCount The target child count.\n     */\n    async updateGroupMatchChildCount(groupId, childCount) {\n        if (!await this.storage.update('match', { group_id: groupId }, { child_count: childCount }))\n            throw Error('Could not update the match.');\n        const matches = await this.storage.select('match', { group_id: groupId });\n        if (!matches)\n            throw Error('This group has no match.');\n        for (const match of matches)\n            await this.adjustMatchChildGames(match, childCount);\n    }\n    /**\n     * Updates child count of all matches of a round.\n     *\n     * @param roundId ID of the round.\n     * @param childCount The target child count.\n     */\n    async updateRoundMatchChildCount(roundId, childCount) {\n        if (!await this.storage.update('match', { round_id: roundId }, { child_count: childCount }))\n            throw Error('Could not update the match.');\n        const matches = await this.storage.select('match', { round_id: roundId });\n        if (!matches)\n            throw Error('This round has no match.');\n        for (const match of matches)\n            await this.adjustMatchChildGames(match, childCount);\n    }\n    /**\n     * Updates the ordering of participants in a round's matches.\n     *\n     * @param roundNumber The number of the round.\n     * @param matches The matches of the round.\n     * @param positions The new positions.\n     */\n    async applyRoundOrdering(roundNumber, matches, positions) {\n        for (const match of matches) {\n            const updated = { ...match };\n            updated.opponent1 = helpers.findPosition(matches, positions.shift());\n            // The only rounds where we have a second ordered participant are first rounds of brackets (upper and lower).\n            if (roundNumber === 1)\n                updated.opponent2 = helpers.findPosition(matches, positions.shift());\n            if (!await this.storage.update('match', updated.id, updated))\n                throw Error('Could not update the match.');\n        }\n    }\n    /**\n     * Adds or deletes match games of a match based on a target child count.\n     *\n     * @param match The match of which child games need to be adjusted.\n     * @param targetChildCount The target child count.\n     */\n    async adjustMatchChildGames(match, targetChildCount) {\n        const games = await this.storage.select('match_game', { parent_id: match.id });\n        let childCount = games ? games.length : 0;\n        while (childCount < targetChildCount) {\n            const id = await this.storage.insert('match_game', {\n                number: childCount + 1,\n                stage_id: match.stage_id,\n                parent_id: match.id,\n                status: match.status,\n                opponent1: { id: null },\n                opponent2: { id: null },\n            });\n            if (id === -1)\n                throw Error('Could not adjust the match games when inserting.');\n            childCount++;\n        }\n        while (childCount > targetChildCount) {\n            const deleted = await this.storage.delete('match_game', {\n                parent_id: match.id,\n                number: childCount,\n            });\n            if (!deleted)\n                throw Error('Could not adjust the match games when deleting.');\n            childCount--;\n        }\n        if (!await this.storage.update('match', match.id, { ...match, child_count: targetChildCount }))\n            throw Error('Could not update the match.');\n    }\n}\nexports.Update = Update;\n//# sourceMappingURL=update.js.map\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-manager/dist/update.js?");

/***/ }),

/***/ "./node_modules/brackets-memory-db/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/brackets-memory-db/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InMemoryDatabase = void 0;\nconst rfdc = __webpack_require__(/*! rfdc */ \"./node_modules/rfdc/index.js\");\nconst clone = rfdc();\nclass InMemoryDatabase {\n    data = {\n        participant: [],\n        stage: [],\n        group: [],\n        round: [],\n        match: [],\n        match_game: [],\n    };\n    /**\n     * @param data \"import\" data from external\n     */\n    setData(data) {\n        this.data = data;\n    }\n    /**\n     * @param partial Filter\n     */\n    makeFilter(partial) {\n        return (entry) => {\n            let result = true;\n            for (const key of Object.keys(partial))\n                result = result && entry[key] === partial[key];\n            return result;\n        };\n    }\n    /**\n     * Clearing all of the data\n     */\n    reset() {\n        this.data = {\n            participant: [],\n            stage: [],\n            group: [],\n            round: [],\n            match: [],\n            match_game: [],\n        };\n    }\n    /**\n     * Implementation of insert\n     *\n     * @param table Where to insert.\n     * @param values What to insert.\n     */\n    insert(table, values) {\n        let id = this.data[table].length > 0\n            ? (Math.max(...this.data[table].map(d => d.id)) + 1)\n            : 0;\n        if (!Array.isArray(values)) {\n            try {\n                // @ts-ignore\n                this.data[table].push({ id, ...values });\n            }\n            catch (error) {\n                return new Promise((resolve) => {\n                    resolve(-1);\n                });\n            }\n            return new Promise((resolve) => {\n                resolve(id);\n            });\n        }\n        try {\n            values.map((object) => {\n                // @ts-ignore\n                this.data[table].push({ id: id++, ...object });\n            });\n        }\n        catch (error) {\n            return new Promise((resolve) => {\n                resolve(false);\n            });\n        }\n        return new Promise((resolve) => {\n            resolve(true);\n        });\n    }\n    /**\n     * @param table Where to get from.\n     * @param arg Arg.\n     */\n    select(table, arg) {\n        try {\n            if (arg === undefined) {\n                return new Promise((resolve) => {\n                    // @ts-ignore\n                    resolve(this.data[table].map(clone));\n                });\n            }\n            if (typeof arg === 'number') {\n                return new Promise((resolve) => {\n                    // @ts-ignore\n                    resolve(clone(this.data[table].find(d => d.id === arg)));\n                });\n            }\n            return new Promise((resolve) => {\n                // @ts-ignore\n                resolve(this.data[table].filter(this.makeFilter(arg)).map(clone));\n            });\n        }\n        catch (error) {\n            return new Promise((resolve) => {\n                resolve(null);\n            });\n        }\n    }\n    /**\n     * Updates data in a table.\n     *\n     * @param table Where to update.\n     * @param arg\n     * @param value How to update.\n     */\n    update(table, arg, value) {\n        if (typeof arg === 'number') {\n            try {\n                // @ts-ignore\n                this.data[table][arg] = value;\n                return new Promise((resolve) => {\n                    resolve(true);\n                });\n            }\n            catch (error) {\n                return new Promise((resolve) => {\n                    resolve(false);\n                });\n            }\n        }\n        // @ts-ignore\n        const values = this.data[table].filter(this.makeFilter(arg));\n        if (!values) {\n            return new Promise((resolve) => {\n                resolve(false);\n            });\n        }\n        values.forEach((v) => {\n            const existing = this.data[table][v.id];\n            for (const key in value) {\n                // @ts-ignore\n                if (existing[key] && typeof existing[key] === 'object' && typeof value[key] === 'object') {\n                    // @ts-ignore\n                    Object.assign(existing[key], value[key]); // For opponent objects, this does a deep merge of level 2.\n                }\n                else {\n                    // @ts-ignore\n                    existing[key] = value[key]; // Otherwise, do a simple value assignment.\n                }\n            }\n            this.data[table][v.id] = existing;\n        });\n        return new Promise((resolve) => {\n            resolve(true);\n        });\n    }\n    /**\n     * Delete data in a table, based on a filter.\n     *\n     * @param table Where to delete in.\n     * @param filter An object to filter data.\n     */\n    delete(table, filter) {\n        const values = this.data[table];\n        if (!values) {\n            return new Promise((resolve) => {\n                resolve(false);\n            });\n        }\n        if (!filter) {\n            this.data[table] = [];\n            return new Promise((resolve) => {\n                resolve(true);\n            });\n        }\n        const predicate = this.makeFilter(filter);\n        const negativeFilter = (value) => !predicate(value);\n        // @ts-ignore\n        this.data[table] = values.filter(negativeFilter);\n        return new Promise((resolve) => {\n            resolve(true);\n        });\n    }\n}\nexports.InMemoryDatabase = InMemoryDatabase;\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-memory-db/dist/index.js?");

/***/ }),

/***/ "./node_modules/brackets-model/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/brackets-model/dist/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./unions */ \"./node_modules/brackets-model/dist/unions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./input */ \"./node_modules/brackets-model/dist/input.js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage */ \"./node_modules/brackets-model/dist/storage.js\"), exports);\n__exportStar(__webpack_require__(/*! ./other */ \"./node_modules/brackets-model/dist/other.js\"), exports);\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-model/dist/index.js?");

/***/ }),

/***/ "./node_modules/brackets-model/dist/input.js":
/*!***************************************************!*\
  !*** ./node_modules/brackets-model/dist/input.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n/*------------------------------------------------------------|\n * Contains everything which is given by the user as input.\n *-----------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-model/dist/input.js?");

/***/ }),

/***/ "./node_modules/brackets-model/dist/other.js":
/*!***************************************************!*\
  !*** ./node_modules/brackets-model/dist/other.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n/*---------------------------------------------------------------------------|\n * Contains the rest of the types which doesn't belong to the other files.\n *--------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Status = void 0;\n/**\n * The possible status for a match.\n */\nvar Status;\n(function (Status) {\n    /** The two matches leading to this one are not completed yet. */\n    Status[Status[\"Locked\"] = 0] = \"Locked\";\n    /** One participant is ready and waiting for the other one. */\n    Status[Status[\"Waiting\"] = 1] = \"Waiting\";\n    /** Both participants are ready to start. */\n    Status[Status[\"Ready\"] = 2] = \"Ready\";\n    /** The match is running. */\n    Status[Status[\"Running\"] = 3] = \"Running\";\n    /** The match is completed. */\n    Status[Status[\"Completed\"] = 4] = \"Completed\";\n    /** At least one participant completed his following match. */\n    Status[Status[\"Archived\"] = 5] = \"Archived\";\n})(Status = exports.Status || (exports.Status = {}));\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-model/dist/other.js?");

/***/ }),

/***/ "./node_modules/brackets-model/dist/storage.js":
/*!*****************************************************!*\
  !*** ./node_modules/brackets-model/dist/storage.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n/*-----------------------------------------------------------------|\n * Contains the types which are persisted in the chosen storage.\n *----------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-model/dist/storage.js?");

/***/ }),

/***/ "./node_modules/brackets-model/dist/unions.js":
/*!****************************************************!*\
  !*** ./node_modules/brackets-model/dist/unions.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n/*----------------------------------------|\n * Contains all the string union types.\n *---------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/brackets-model/dist/unions.js?");

/***/ }),

/***/ "./node_modules/i18next-browser-languagedetector/dist/cjs/i18nextBrowserLanguageDetector.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/i18next-browser-languagedetector/dist/cjs/i18nextBrowserLanguageDetector.js ***!
  \**************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\");\nvar _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);\nvar _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);\n\nvar arr = [];\nvar each = arr.forEach;\nvar slice = arr.slice;\nfunction defaults(obj) {\n  each.call(slice.call(arguments, 1), function (source) {\n    if (source) {\n      for (var prop in source) {\n        if (obj[prop] === undefined) obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n}\n\n// eslint-disable-next-line no-control-regex\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\nvar serializeCookie = function serializeCookie(name, val, options) {\n  var opt = options || {};\n  opt.path = opt.path || '/';\n  var value = encodeURIComponent(val);\n  var str = \"\".concat(name, \"=\").concat(value);\n\n  if (opt.maxAge > 0) {\n    var maxAge = opt.maxAge - 0;\n    if (Number.isNaN(maxAge)) throw new Error('maxAge should be a Number');\n    str += \"; Max-Age=\".concat(Math.floor(maxAge));\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += \"; Domain=\".concat(opt.domain);\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += \"; Path=\".concat(opt.path);\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += \"; Expires=\".concat(opt.expires.toUTCString());\n  }\n\n  if (opt.httpOnly) str += '; HttpOnly';\n  if (opt.secure) str += '; Secure';\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n\n      case 'none':\n        str += '; SameSite=None';\n        break;\n\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n};\n\nvar cookie = {\n  create: function create(name, value, minutes, domain) {\n    var cookieOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      path: '/',\n      sameSite: 'strict'\n    };\n\n    if (minutes) {\n      cookieOptions.expires = new Date();\n      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1000);\n    }\n\n    if (domain) cookieOptions.domain = domain;\n    document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);\n  },\n  read: function read(name) {\n    var nameEQ = \"\".concat(name, \"=\");\n    var ca = document.cookie.split(';');\n\n    for (var i = 0; i < ca.length; i++) {\n      var c = ca[i];\n\n      while (c.charAt(0) === ' ') {\n        c = c.substring(1, c.length);\n      }\n\n      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\n    }\n\n    return null;\n  },\n  remove: function remove(name) {\n    this.create(name, '', -1);\n  }\n};\nvar cookie$1 = {\n  name: 'cookie',\n  lookup: function lookup(options) {\n    var found;\n\n    if (options.lookupCookie && typeof document !== 'undefined') {\n      var c = cookie.read(options.lookupCookie);\n      if (c) found = c;\n    }\n\n    return found;\n  },\n  cacheUserLanguage: function cacheUserLanguage(lng, options) {\n    if (options.lookupCookie && typeof document !== 'undefined') {\n      cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain, options.cookieOptions);\n    }\n  }\n};\n\nvar querystring = {\n  name: 'querystring',\n  lookup: function lookup(options) {\n    var found;\n\n    if (typeof window !== 'undefined') {\n      var search = window.location.search;\n\n      if (!window.location.search && window.location.hash && window.location.hash.indexOf('?') > -1) {\n        search = window.location.hash.substring(window.location.hash.indexOf('?'));\n      }\n\n      var query = search.substring(1);\n      var params = query.split('&');\n\n      for (var i = 0; i < params.length; i++) {\n        var pos = params[i].indexOf('=');\n\n        if (pos > 0) {\n          var key = params[i].substring(0, pos);\n\n          if (key === options.lookupQuerystring) {\n            found = params[i].substring(pos + 1);\n          }\n        }\n      }\n    }\n\n    return found;\n  }\n};\n\nvar hasLocalStorageSupport = null;\n\nvar localStorageAvailable = function localStorageAvailable() {\n  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;\n\n  try {\n    hasLocalStorageSupport = window !== 'undefined' && window.localStorage !== null;\n    var testKey = 'i18next.translate.boo';\n    window.localStorage.setItem(testKey, 'foo');\n    window.localStorage.removeItem(testKey);\n  } catch (e) {\n    hasLocalStorageSupport = false;\n  }\n\n  return hasLocalStorageSupport;\n};\n\nvar localStorage = {\n  name: 'localStorage',\n  lookup: function lookup(options) {\n    var found;\n\n    if (options.lookupLocalStorage && localStorageAvailable()) {\n      var lng = window.localStorage.getItem(options.lookupLocalStorage);\n      if (lng) found = lng;\n    }\n\n    return found;\n  },\n  cacheUserLanguage: function cacheUserLanguage(lng, options) {\n    if (options.lookupLocalStorage && localStorageAvailable()) {\n      window.localStorage.setItem(options.lookupLocalStorage, lng);\n    }\n  }\n};\n\nvar hasSessionStorageSupport = null;\n\nvar sessionStorageAvailable = function sessionStorageAvailable() {\n  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;\n\n  try {\n    hasSessionStorageSupport = window !== 'undefined' && window.sessionStorage !== null;\n    var testKey = 'i18next.translate.boo';\n    window.sessionStorage.setItem(testKey, 'foo');\n    window.sessionStorage.removeItem(testKey);\n  } catch (e) {\n    hasSessionStorageSupport = false;\n  }\n\n  return hasSessionStorageSupport;\n};\n\nvar sessionStorage = {\n  name: 'sessionStorage',\n  lookup: function lookup(options) {\n    var found;\n\n    if (options.lookupSessionStorage && sessionStorageAvailable()) {\n      var lng = window.sessionStorage.getItem(options.lookupSessionStorage);\n      if (lng) found = lng;\n    }\n\n    return found;\n  },\n  cacheUserLanguage: function cacheUserLanguage(lng, options) {\n    if (options.lookupSessionStorage && sessionStorageAvailable()) {\n      window.sessionStorage.setItem(options.lookupSessionStorage, lng);\n    }\n  }\n};\n\nvar navigator$1 = {\n  name: 'navigator',\n  lookup: function lookup(options) {\n    var found = [];\n\n    if (typeof navigator !== 'undefined') {\n      if (navigator.languages) {\n        // chrome only; not an array, so can't use .push.apply instead of iterating\n        for (var i = 0; i < navigator.languages.length; i++) {\n          found.push(navigator.languages[i]);\n        }\n      }\n\n      if (navigator.userLanguage) {\n        found.push(navigator.userLanguage);\n      }\n\n      if (navigator.language) {\n        found.push(navigator.language);\n      }\n    }\n\n    return found.length > 0 ? found : undefined;\n  }\n};\n\nvar htmlTag = {\n  name: 'htmlTag',\n  lookup: function lookup(options) {\n    var found;\n    var htmlTag = options.htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);\n\n    if (htmlTag && typeof htmlTag.getAttribute === 'function') {\n      found = htmlTag.getAttribute('lang');\n    }\n\n    return found;\n  }\n};\n\nvar path = {\n  name: 'path',\n  lookup: function lookup(options) {\n    var found;\n\n    if (typeof window !== 'undefined') {\n      var language = window.location.pathname.match(/\\/([a-zA-Z-]*)/g);\n\n      if (language instanceof Array) {\n        if (typeof options.lookupFromPathIndex === 'number') {\n          if (typeof language[options.lookupFromPathIndex] !== 'string') {\n            return undefined;\n          }\n\n          found = language[options.lookupFromPathIndex].replace('/', '');\n        } else {\n          found = language[0].replace('/', '');\n        }\n      }\n    }\n\n    return found;\n  }\n};\n\nvar subdomain = {\n  name: 'subdomain',\n  lookup: function lookup(options) {\n    // If given get the subdomain index else 1\n    var lookupFromSubdomainIndex = typeof options.lookupFromSubdomainIndex === 'number' ? options.lookupFromSubdomainIndex + 1 : 1; // get all matches if window.location. is existing\n    // first item of match is the match itself and the second is the first group macht which sould be the first subdomain match\n    // is the hostname no public domain get the or option of localhost\n\n    var language = typeof window !== 'undefined' && window.location && window.location.hostname && window.location.hostname.match(/^(\\w{2,5})\\.(([a-z0-9-]{1,63}\\.[a-z]{2,6})|localhost)/i); // if there is no match (null) return undefined\n\n    if (!language) return undefined; // return the given group match\n\n    return language[lookupFromSubdomainIndex];\n  }\n};\n\nfunction getDefaults() {\n  return {\n    order: ['querystring', 'cookie', 'localStorage', 'sessionStorage', 'navigator', 'htmlTag'],\n    lookupQuerystring: 'lng',\n    lookupCookie: 'i18next',\n    lookupLocalStorage: 'i18nextLng',\n    lookupSessionStorage: 'i18nextLng',\n    // cache user language\n    caches: ['localStorage'],\n    excludeCacheFor: ['cimode'] // cookieMinutes: 10,\n    // cookieDomain: 'myDomain'\n\n  };\n}\n\nvar Browser = /*#__PURE__*/function () {\n  function Browser(services) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck__default[\"default\"](this, Browser);\n\n    this.type = 'languageDetector';\n    this.detectors = {};\n    this.init(services, options);\n  }\n\n  _createClass__default[\"default\"](Browser, [{\n    key: \"init\",\n    value: function init(services) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.services = services;\n      this.options = defaults(options, this.options || {}, getDefaults()); // backwards compatibility\n\n      if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;\n      this.i18nOptions = i18nOptions;\n      this.addDetector(cookie$1);\n      this.addDetector(querystring);\n      this.addDetector(localStorage);\n      this.addDetector(sessionStorage);\n      this.addDetector(navigator$1);\n      this.addDetector(htmlTag);\n      this.addDetector(path);\n      this.addDetector(subdomain);\n    }\n  }, {\n    key: \"addDetector\",\n    value: function addDetector(detector) {\n      this.detectors[detector.name] = detector;\n    }\n  }, {\n    key: \"detect\",\n    value: function detect(detectionOrder) {\n      var _this = this;\n\n      if (!detectionOrder) detectionOrder = this.options.order;\n      var detected = [];\n      detectionOrder.forEach(function (detectorName) {\n        if (_this.detectors[detectorName]) {\n          var lookup = _this.detectors[detectorName].lookup(_this.options);\n\n          if (lookup && typeof lookup === 'string') lookup = [lookup];\n          if (lookup) detected = detected.concat(lookup);\n        }\n      });\n      if (this.services.languageUtils.getBestMatchFromCodes) return detected; // new i18next v19.5.0\n\n      return detected.length > 0 ? detected[0] : null; // a little backward compatibility\n    }\n  }, {\n    key: \"cacheUserLanguage\",\n    value: function cacheUserLanguage(lng, caches) {\n      var _this2 = this;\n\n      if (!caches) caches = this.options.caches;\n      if (!caches) return;\n      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;\n      caches.forEach(function (cacheName) {\n        if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);\n      });\n    }\n  }]);\n\n  return Browser;\n}();\n\nBrowser.type = 'languageDetector';\n\nmodule.exports = Browser;\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/i18next-browser-languagedetector/dist/cjs/i18nextBrowserLanguageDetector.js?");

/***/ }),

/***/ "./node_modules/i18next/dist/cjs/i18next.js":
/*!**************************************************!*\
  !*** ./node_modules/i18next/dist/cjs/i18next.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\nvar _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\");\nvar _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\");\nvar _assertThisInitialized = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\nvar _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\");\nvar _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\");\nvar _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\nvar _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\");\nvar _toArray = __webpack_require__(/*! @babel/runtime/helpers/toArray */ \"./node_modules/@babel/runtime/helpers/toArray.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);\nvar _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);\nvar _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);\nvar _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);\nvar _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);\nvar _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);\nvar _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);\nvar _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);\nvar _toArray__default = /*#__PURE__*/_interopDefaultLegacy(_toArray);\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar consoleLogger = {\n  type: 'logger',\n  log: function log(args) {\n    this.output('log', args);\n  },\n  warn: function warn(args) {\n    this.output('warn', args);\n  },\n  error: function error(args) {\n    this.output('error', args);\n  },\n  output: function output(type, args) {\n    if (console && console[type]) console[type].apply(console, args);\n  }\n};\n\nvar Logger = function () {\n  function Logger(concreteLogger) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck__default['default'](this, Logger);\n\n    this.init(concreteLogger, options);\n  }\n\n  _createClass__default['default'](Logger, [{\n    key: \"init\",\n    value: function init(concreteLogger) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.prefix = options.prefix || 'i18next:';\n      this.logger = concreteLogger || consoleLogger;\n      this.options = options;\n      this.debug = options.debug;\n    }\n  }, {\n    key: \"setDebug\",\n    value: function setDebug(bool) {\n      this.debug = bool;\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.forward(args, 'log', '', true);\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return this.forward(args, 'warn', '', true);\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return this.forward(args, 'error', '');\n    }\n  }, {\n    key: \"deprecate\",\n    value: function deprecate() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);\n    }\n  }, {\n    key: \"forward\",\n    value: function forward(args, lvl, prefix, debugOnly) {\n      if (debugOnly && !this.debug) return null;\n      if (typeof args[0] === 'string') args[0] = \"\".concat(prefix).concat(this.prefix, \" \").concat(args[0]);\n      return this.logger[lvl](args);\n    }\n  }, {\n    key: \"create\",\n    value: function create(moduleName) {\n      return new Logger(this.logger, _objectSpread(_objectSpread({}, {\n        prefix: \"\".concat(this.prefix, \":\").concat(moduleName, \":\")\n      }), this.options));\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(options) {\n      options = options || this.options;\n      options.prefix = options.prefix || this.prefix;\n      return new Logger(this.logger, options);\n    }\n  }]);\n\n  return Logger;\n}();\n\nvar baseLogger = new Logger();\n\nvar EventEmitter = function () {\n  function EventEmitter() {\n    _classCallCheck__default['default'](this, EventEmitter);\n\n    this.observers = {};\n  }\n\n  _createClass__default['default'](EventEmitter, [{\n    key: \"on\",\n    value: function on(events, listener) {\n      var _this = this;\n\n      events.split(' ').forEach(function (event) {\n        _this.observers[event] = _this.observers[event] || [];\n\n        _this.observers[event].push(listener);\n      });\n      return this;\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      if (!this.observers[event]) return;\n\n      if (!listener) {\n        delete this.observers[event];\n        return;\n      }\n\n      this.observers[event] = this.observers[event].filter(function (l) {\n        return l !== listener;\n      });\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (this.observers[event]) {\n        var cloned = [].concat(this.observers[event]);\n        cloned.forEach(function (observer) {\n          observer.apply(void 0, args);\n        });\n      }\n\n      if (this.observers['*']) {\n        var _cloned = [].concat(this.observers['*']);\n\n        _cloned.forEach(function (observer) {\n          observer.apply(observer, [event].concat(args));\n        });\n      }\n    }\n  }]);\n\n  return EventEmitter;\n}();\n\nfunction defer() {\n  var res;\n  var rej;\n  var promise = new Promise(function (resolve, reject) {\n    res = resolve;\n    rej = reject;\n  });\n  promise.resolve = res;\n  promise.reject = rej;\n  return promise;\n}\nfunction makeString(object) {\n  if (object == null) return '';\n  return '' + object;\n}\nfunction copy(a, s, t) {\n  a.forEach(function (m) {\n    if (s[m]) t[m] = s[m];\n  });\n}\n\nfunction getLastOfPath(object, path, Empty) {\n  function cleanKey(key) {\n    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;\n  }\n\n  function canNotTraverseDeeper() {\n    return !object || typeof object === 'string';\n  }\n\n  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');\n\n  while (stack.length > 1) {\n    if (canNotTraverseDeeper()) return {};\n    var key = cleanKey(stack.shift());\n    if (!object[key] && Empty) object[key] = new Empty();\n\n    if (Object.prototype.hasOwnProperty.call(object, key)) {\n      object = object[key];\n    } else {\n      object = {};\n    }\n  }\n\n  if (canNotTraverseDeeper()) return {};\n  return {\n    obj: object,\n    k: cleanKey(stack.shift())\n  };\n}\n\nfunction setPath(object, path, newValue) {\n  var _getLastOfPath = getLastOfPath(object, path, Object),\n      obj = _getLastOfPath.obj,\n      k = _getLastOfPath.k;\n\n  obj[k] = newValue;\n}\nfunction pushPath(object, path, newValue, concat) {\n  var _getLastOfPath2 = getLastOfPath(object, path, Object),\n      obj = _getLastOfPath2.obj,\n      k = _getLastOfPath2.k;\n\n  obj[k] = obj[k] || [];\n  if (concat) obj[k] = obj[k].concat(newValue);\n  if (!concat) obj[k].push(newValue);\n}\nfunction getPath(object, path) {\n  var _getLastOfPath3 = getLastOfPath(object, path),\n      obj = _getLastOfPath3.obj,\n      k = _getLastOfPath3.k;\n\n  if (!obj) return undefined;\n  return obj[k];\n}\nfunction getPathWithDefaults(data, defaultData, key) {\n  var value = getPath(data, key);\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  return getPath(defaultData, key);\n}\nfunction deepExtend(target, source, overwrite) {\n  for (var prop in source) {\n    if (prop !== '__proto__' && prop !== 'constructor') {\n      if (prop in target) {\n        if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {\n          if (overwrite) target[prop] = source[prop];\n        } else {\n          deepExtend(target[prop], source[prop], overwrite);\n        }\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n  }\n\n  return target;\n}\nfunction regexEscape(str) {\n  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\nvar _entityMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;'\n};\nfunction escape(data) {\n  if (typeof data === 'string') {\n    return data.replace(/[&<>\"'\\/]/g, function (s) {\n      return _entityMap[s];\n    });\n  }\n\n  return data;\n}\nvar isIE10 = typeof window !== 'undefined' && window.navigator && typeof window.navigator.userAgentData === 'undefined' && window.navigator.userAgent && window.navigator.userAgent.indexOf('MSIE') > -1;\nvar chars = [' ', ',', '?', '!', ';'];\nfunction looksLikeObjectPath(key, nsSeparator, keySeparator) {\n  nsSeparator = nsSeparator || '';\n  keySeparator = keySeparator || '';\n  var possibleChars = chars.filter(function (c) {\n    return nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0;\n  });\n  if (possibleChars.length === 0) return true;\n  var r = new RegExp(\"(\".concat(possibleChars.map(function (c) {\n    return c === '?' ? '\\\\?' : c;\n  }).join('|'), \")\"));\n  var matched = !r.test(key);\n\n  if (!matched) {\n    var ki = key.indexOf(keySeparator);\n\n    if (ki > 0 && !r.test(key.substring(0, ki))) {\n      matched = true;\n    }\n  }\n\n  return matched;\n}\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction deepFind(obj, path) {\n  var keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n  if (!obj) return undefined;\n  if (obj[path]) return obj[path];\n  var paths = path.split(keySeparator);\n  var current = obj;\n\n  for (var i = 0; i < paths.length; ++i) {\n    if (!current) return undefined;\n\n    if (typeof current[paths[i]] === 'string' && i + 1 < paths.length) {\n      return undefined;\n    }\n\n    if (current[paths[i]] === undefined) {\n      var j = 2;\n      var p = paths.slice(i, i + j).join(keySeparator);\n      var mix = current[p];\n\n      while (mix === undefined && paths.length > i + j) {\n        j++;\n        p = paths.slice(i, i + j).join(keySeparator);\n        mix = current[p];\n      }\n\n      if (mix === undefined) return undefined;\n      if (mix === null) return null;\n\n      if (path.endsWith(p)) {\n        if (typeof mix === 'string') return mix;\n        if (p && typeof mix[p] === 'string') return mix[p];\n      }\n\n      var joinedPath = paths.slice(i + j).join(keySeparator);\n      if (joinedPath) return deepFind(mix, joinedPath, keySeparator);\n      return undefined;\n    }\n\n    current = current[paths[i]];\n  }\n\n  return current;\n}\n\nvar ResourceStore = function (_EventEmitter) {\n  _inherits__default['default'](ResourceStore, _EventEmitter);\n\n  var _super = _createSuper(ResourceStore);\n\n  function ResourceStore(data) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      ns: ['translation'],\n      defaultNS: 'translation'\n    };\n\n    _classCallCheck__default['default'](this, ResourceStore);\n\n    _this = _super.call(this);\n\n    if (isIE10) {\n      EventEmitter.call(_assertThisInitialized__default['default'](_this));\n    }\n\n    _this.data = data || {};\n    _this.options = options;\n\n    if (_this.options.keySeparator === undefined) {\n      _this.options.keySeparator = '.';\n    }\n\n    if (_this.options.ignoreJSONStructure === undefined) {\n      _this.options.ignoreJSONStructure = true;\n    }\n\n    return _this;\n  }\n\n  _createClass__default['default'](ResourceStore, [{\n    key: \"addNamespaces\",\n    value: function addNamespaces(ns) {\n      if (this.options.ns.indexOf(ns) < 0) {\n        this.options.ns.push(ns);\n      }\n    }\n  }, {\n    key: \"removeNamespaces\",\n    value: function removeNamespaces(ns) {\n      var index = this.options.ns.indexOf(ns);\n\n      if (index > -1) {\n        this.options.ns.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"getResource\",\n    value: function getResource(lng, ns, key) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n      var ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n      var path = [lng, ns];\n      if (key && typeof key !== 'string') path = path.concat(key);\n      if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);\n\n      if (lng.indexOf('.') > -1) {\n        path = lng.split('.');\n      }\n\n      var result = getPath(this.data, path);\n      if (result || !ignoreJSONStructure || typeof key !== 'string') return result;\n      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);\n    }\n  }, {\n    key: \"addResource\",\n    value: function addResource(lng, ns, key, value) {\n      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n        silent: false\n      };\n      var keySeparator = this.options.keySeparator;\n      if (keySeparator === undefined) keySeparator = '.';\n      var path = [lng, ns];\n      if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n\n      if (lng.indexOf('.') > -1) {\n        path = lng.split('.');\n        value = ns;\n        ns = path[1];\n      }\n\n      this.addNamespaces(ns);\n      setPath(this.data, path, value);\n      if (!options.silent) this.emit('added', lng, ns, key, value);\n    }\n  }, {\n    key: \"addResources\",\n    value: function addResources(lng, ns, resources) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        silent: false\n      };\n\n      for (var m in resources) {\n        if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {\n          silent: true\n        });\n      }\n\n      if (!options.silent) this.emit('added', lng, ns, resources);\n    }\n  }, {\n    key: \"addResourceBundle\",\n    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {\n      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n        silent: false\n      };\n      var path = [lng, ns];\n\n      if (lng.indexOf('.') > -1) {\n        path = lng.split('.');\n        deep = resources;\n        resources = ns;\n        ns = path[1];\n      }\n\n      this.addNamespaces(ns);\n      var pack = getPath(this.data, path) || {};\n\n      if (deep) {\n        deepExtend(pack, resources, overwrite);\n      } else {\n        pack = _objectSpread$1(_objectSpread$1({}, pack), resources);\n      }\n\n      setPath(this.data, path, pack);\n      if (!options.silent) this.emit('added', lng, ns, resources);\n    }\n  }, {\n    key: \"removeResourceBundle\",\n    value: function removeResourceBundle(lng, ns) {\n      if (this.hasResourceBundle(lng, ns)) {\n        delete this.data[lng][ns];\n      }\n\n      this.removeNamespaces(ns);\n      this.emit('removed', lng, ns);\n    }\n  }, {\n    key: \"hasResourceBundle\",\n    value: function hasResourceBundle(lng, ns) {\n      return this.getResource(lng, ns) !== undefined;\n    }\n  }, {\n    key: \"getResourceBundle\",\n    value: function getResourceBundle(lng, ns) {\n      if (!ns) ns = this.options.defaultNS;\n      if (this.options.compatibilityAPI === 'v1') return _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns));\n      return this.getResource(lng, ns);\n    }\n  }, {\n    key: \"getDataByLanguage\",\n    value: function getDataByLanguage(lng) {\n      return this.data[lng];\n    }\n  }, {\n    key: \"hasLanguageSomeTranslations\",\n    value: function hasLanguageSomeTranslations(lng) {\n      var data = this.getDataByLanguage(lng);\n      var n = data && Object.keys(data) || [];\n      return !!n.find(function (v) {\n        return data[v] && Object.keys(data[v]).length > 0;\n      });\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.data;\n    }\n  }]);\n\n  return ResourceStore;\n}(EventEmitter);\n\nvar postProcessor = {\n  processors: {},\n  addPostProcessor: function addPostProcessor(module) {\n    this.processors[module.name] = module;\n  },\n  handle: function handle(processors, value, key, options, translator) {\n    var _this = this;\n\n    processors.forEach(function (processor) {\n      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);\n    });\n    return value;\n  }\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }\n\nfunction _isNativeReflectConstruct$1() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar checkedLoadedFor = {};\n\nvar Translator = function (_EventEmitter) {\n  _inherits__default['default'](Translator, _EventEmitter);\n\n  var _super = _createSuper$1(Translator);\n\n  function Translator(services) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck__default['default'](this, Translator);\n\n    _this = _super.call(this);\n\n    if (isIE10) {\n      EventEmitter.call(_assertThisInitialized__default['default'](_this));\n    }\n\n    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, _assertThisInitialized__default['default'](_this));\n    _this.options = options;\n\n    if (_this.options.keySeparator === undefined) {\n      _this.options.keySeparator = '.';\n    }\n\n    _this.logger = baseLogger.create('translator');\n    return _this;\n  }\n\n  _createClass__default['default'](Translator, [{\n    key: \"changeLanguage\",\n    value: function changeLanguage(lng) {\n      if (lng) this.language = lng;\n    }\n  }, {\n    key: \"exists\",\n    value: function exists(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        interpolation: {}\n      };\n\n      if (key === undefined || key === null) {\n        return false;\n      }\n\n      var resolved = this.resolve(key, options);\n      return resolved && resolved.res !== undefined;\n    }\n  }, {\n    key: \"extractFromKey\",\n    value: function extractFromKey(key, options) {\n      var nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;\n      if (nsSeparator === undefined) nsSeparator = ':';\n      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n      var namespaces = options.ns || this.options.defaultNS || [];\n      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n\n      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n        var m = key.match(this.interpolator.nestingRegexp);\n\n        if (m && m.length > 0) {\n          return {\n            key: key,\n            namespaces: namespaces\n          };\n        }\n\n        var parts = key.split(nsSeparator);\n        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n        key = parts.join(keySeparator);\n      }\n\n      if (typeof namespaces === 'string') namespaces = [namespaces];\n      return {\n        key: key,\n        namespaces: namespaces\n      };\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(keys, options, lastKey) {\n      var _this2 = this;\n\n      if (_typeof__default['default'](options) !== 'object' && this.options.overloadTranslationOptionHandler) {\n        options = this.options.overloadTranslationOptionHandler(arguments);\n      }\n\n      if (!options) options = {};\n      if (keys === undefined || keys === null) return '';\n      if (!Array.isArray(keys)) keys = [String(keys)];\n      var returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;\n      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n\n      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),\n          key = _this$extractFromKey.key,\n          namespaces = _this$extractFromKey.namespaces;\n\n      var namespace = namespaces[namespaces.length - 1];\n      var lng = options.lng || this.language;\n      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n\n      if (lng && lng.toLowerCase() === 'cimode') {\n        if (appendNamespaceToCIMode) {\n          var nsSeparator = options.nsSeparator || this.options.nsSeparator;\n\n          if (returnDetails) {\n            resolved.res = \"\".concat(namespace).concat(nsSeparator).concat(key);\n            return resolved;\n          }\n\n          return \"\".concat(namespace).concat(nsSeparator).concat(key);\n        }\n\n        if (returnDetails) {\n          resolved.res = key;\n          return resolved;\n        }\n\n        return key;\n      }\n\n      var resolved = this.resolve(keys, options);\n      var res = resolved && resolved.res;\n      var resUsedKey = resolved && resolved.usedKey || key;\n      var resExactUsedKey = resolved && resolved.exactUsedKey || key;\n      var resType = Object.prototype.toString.apply(res);\n      var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];\n      var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;\n      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n      var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';\n\n      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {\n        if (!options.returnObjects && !this.options.returnObjects) {\n          if (!this.options.returnedObjectHandler) {\n            this.logger.warn('accessing an object - but returnObjects options is not enabled!');\n          }\n\n          var r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options), {}, {\n            ns: namespaces\n          })) : \"key '\".concat(key, \" (\").concat(this.language, \")' returned an object instead of string.\");\n\n          if (returnDetails) {\n            resolved.res = r;\n            return resolved;\n          }\n\n          return r;\n        }\n\n        if (keySeparator) {\n          var resTypeIsArray = resType === '[object Array]';\n          var copy = resTypeIsArray ? [] : {};\n          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n\n          for (var m in res) {\n            if (Object.prototype.hasOwnProperty.call(res, m)) {\n              var deepKey = \"\".concat(newKeyToUse).concat(keySeparator).concat(m);\n              copy[m] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options), {\n                joinArrays: false,\n                ns: namespaces\n              }));\n              if (copy[m] === deepKey) copy[m] = res[m];\n            }\n          }\n\n          res = copy;\n        }\n      } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {\n        res = res.join(joinArrays);\n        if (res) res = this.extendTranslation(res, keys, options, lastKey);\n      } else {\n        var usedDefault = false;\n        var usedKey = false;\n        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';\n        var hasDefaultValue = Translator.hasDefaultValue(options);\n        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';\n        var defaultValue = options[\"defaultValue\".concat(defaultValueSuffix)] || options.defaultValue;\n\n        if (!this.isValidLookup(res) && hasDefaultValue) {\n          usedDefault = true;\n          res = defaultValue;\n        }\n\n        if (!this.isValidLookup(res)) {\n          usedKey = true;\n          res = key;\n        }\n\n        var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n\n        if (usedKey || usedDefault || updateMissing) {\n          this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);\n\n          if (keySeparator) {\n            var fk = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options), {}, {\n              keySeparator: false\n            }));\n            if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');\n          }\n\n          var lngs = [];\n          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);\n\n          if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {\n            for (var i = 0; i < fallbackLngs.length; i++) {\n              lngs.push(fallbackLngs[i]);\n            }\n          } else if (this.options.saveMissingTo === 'all') {\n            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);\n          } else {\n            lngs.push(options.lng || this.language);\n          }\n\n          var send = function send(l, k, specificDefaultValue) {\n            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n\n            if (_this2.options.missingKeyHandler) {\n              _this2.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);\n            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {\n              _this2.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);\n            }\n\n            _this2.emit('missingKey', l, namespace, k, res);\n          };\n\n          if (this.options.saveMissing) {\n            if (this.options.saveMissingPlurals && needsPluralHandling) {\n              lngs.forEach(function (language) {\n                _this2.pluralResolver.getSuffixes(language, options).forEach(function (suffix) {\n                  send([language], key + suffix, options[\"defaultValue\".concat(suffix)] || defaultValue);\n                });\n              });\n            } else {\n              send(lngs, key, defaultValue);\n            }\n          }\n        }\n\n        res = this.extendTranslation(res, keys, options, resolved, lastKey);\n        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = \"\".concat(namespace, \":\").concat(key);\n\n        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n          if (this.options.compatibilityAPI !== 'v1') {\n            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? \"\".concat(namespace, \":\").concat(key) : key, usedDefault ? res : undefined);\n          } else {\n            res = this.options.parseMissingKeyHandler(res);\n          }\n        }\n      }\n\n      if (returnDetails) {\n        resolved.res = res;\n        return resolved;\n      }\n\n      return res;\n    }\n  }, {\n    key: \"extendTranslation\",\n    value: function extendTranslation(res, key, options, resolved, lastKey) {\n      var _this3 = this;\n\n      if (this.i18nFormat && this.i18nFormat.parse) {\n        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n          resolved: resolved\n        });\n      } else if (!options.skipInterpolation) {\n        if (options.interpolation) this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options), {\n          interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options.interpolation)\n        }));\n        var skipOnVariables = typeof res === 'string' && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n        var nestBef;\n\n        if (skipOnVariables) {\n          var nb = res.match(this.interpolator.nestingRegexp);\n          nestBef = nb && nb.length;\n        }\n\n        var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;\n        if (this.options.interpolation.defaultVariables) data = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data);\n        res = this.interpolator.interpolate(res, data, options.lng || this.language, options);\n\n        if (skipOnVariables) {\n          var na = res.match(this.interpolator.nestingRegexp);\n          var nestAft = na && na.length;\n          if (nestBef < nestAft) options.nest = false;\n        }\n\n        if (options.nest !== false) res = this.interpolator.nest(res, function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          if (lastKey && lastKey[0] === args[0] && !options.context) {\n            _this3.logger.warn(\"It seems you are nesting recursively key: \".concat(args[0], \" in key: \").concat(key[0]));\n\n            return null;\n          }\n\n          return _this3.translate.apply(_this3, args.concat([key]));\n        }, options);\n        if (options.interpolation) this.interpolator.reset();\n      }\n\n      var postProcess = options.postProcess || this.options.postProcess;\n      var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;\n\n      if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {\n        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({\n          i18nResolved: resolved\n        }, options) : options, this);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(keys) {\n      var _this4 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var found;\n      var usedKey;\n      var exactUsedKey;\n      var usedLng;\n      var usedNS;\n      if (typeof keys === 'string') keys = [keys];\n      keys.forEach(function (k) {\n        if (_this4.isValidLookup(found)) return;\n\n        var extracted = _this4.extractFromKey(k, options);\n\n        var key = extracted.key;\n        usedKey = key;\n        var namespaces = extracted.namespaces;\n        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);\n        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';\n\n        var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();\n\n        var needsContextHandling = options.context !== undefined && (typeof options.context === 'string' || typeof options.context === 'number') && options.context !== '';\n        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);\n        namespaces.forEach(function (ns) {\n          if (_this4.isValidLookup(found)) return;\n          usedNS = ns;\n\n          if (!checkedLoadedFor[\"\".concat(codes[0], \"-\").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {\n            checkedLoadedFor[\"\".concat(codes[0], \"-\").concat(ns)] = true;\n\n            _this4.logger.warn(\"key \\\"\".concat(usedKey, \"\\\" for languages \\\"\").concat(codes.join(', '), \"\\\" won't get resolved as namespace \\\"\").concat(usedNS, \"\\\" was not yet loaded\"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n          }\n\n          codes.forEach(function (code) {\n            if (_this4.isValidLookup(found)) return;\n            usedLng = code;\n            var finalKeys = [key];\n\n            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {\n              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);\n            } else {\n              var pluralSuffix;\n              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);\n              var zeroSuffix = \"\".concat(_this4.options.pluralSeparator, \"zero\");\n\n              if (needsPluralHandling) {\n                finalKeys.push(key + pluralSuffix);\n\n                if (needsZeroSuffixLookup) {\n                  finalKeys.push(key + zeroSuffix);\n                }\n              }\n\n              if (needsContextHandling) {\n                var contextKey = \"\".concat(key).concat(_this4.options.contextSeparator).concat(options.context);\n                finalKeys.push(contextKey);\n\n                if (needsPluralHandling) {\n                  finalKeys.push(contextKey + pluralSuffix);\n\n                  if (needsZeroSuffixLookup) {\n                    finalKeys.push(contextKey + zeroSuffix);\n                  }\n                }\n              }\n            }\n\n            var possibleKey;\n\n            while (possibleKey = finalKeys.pop()) {\n              if (!_this4.isValidLookup(found)) {\n                exactUsedKey = possibleKey;\n                found = _this4.getResource(code, ns, possibleKey, options);\n              }\n            }\n          });\n        });\n      });\n      return {\n        res: found,\n        usedKey: usedKey,\n        exactUsedKey: exactUsedKey,\n        usedLng: usedLng,\n        usedNS: usedNS\n      };\n    }\n  }, {\n    key: \"isValidLookup\",\n    value: function isValidLookup(res) {\n      return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');\n    }\n  }, {\n    key: \"getResource\",\n    value: function getResource(code, ns, key) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n      return this.resourceStore.getResource(code, ns, key, options);\n    }\n  }], [{\n    key: \"hasDefaultValue\",\n    value: function hasDefaultValue(options) {\n      var prefix = 'defaultValue';\n\n      for (var option in options) {\n        if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }]);\n\n  return Translator;\n}(EventEmitter);\n\nfunction capitalize(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nvar LanguageUtil = function () {\n  function LanguageUtil(options) {\n    _classCallCheck__default['default'](this, LanguageUtil);\n\n    this.options = options;\n    this.supportedLngs = this.options.supportedLngs || false;\n    this.logger = baseLogger.create('languageUtils');\n  }\n\n  _createClass__default['default'](LanguageUtil, [{\n    key: \"getScriptPartFromCode\",\n    value: function getScriptPartFromCode(code) {\n      if (!code || code.indexOf('-') < 0) return null;\n      var p = code.split('-');\n      if (p.length === 2) return null;\n      p.pop();\n      if (p[p.length - 1].toLowerCase() === 'x') return null;\n      return this.formatLanguageCode(p.join('-'));\n    }\n  }, {\n    key: \"getLanguagePartFromCode\",\n    value: function getLanguagePartFromCode(code) {\n      if (!code || code.indexOf('-') < 0) return code;\n      var p = code.split('-');\n      return this.formatLanguageCode(p[0]);\n    }\n  }, {\n    key: \"formatLanguageCode\",\n    value: function formatLanguageCode(code) {\n      if (typeof code === 'string' && code.indexOf('-') > -1) {\n        var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];\n        var p = code.split('-');\n\n        if (this.options.lowerCaseLng) {\n          p = p.map(function (part) {\n            return part.toLowerCase();\n          });\n        } else if (p.length === 2) {\n          p[0] = p[0].toLowerCase();\n          p[1] = p[1].toUpperCase();\n          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n        } else if (p.length === 3) {\n          p[0] = p[0].toLowerCase();\n          if (p[1].length === 2) p[1] = p[1].toUpperCase();\n          if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();\n          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n          if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());\n        }\n\n        return p.join('-');\n      }\n\n      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n    }\n  }, {\n    key: \"isSupportedCode\",\n    value: function isSupportedCode(code) {\n      if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {\n        code = this.getLanguagePartFromCode(code);\n      }\n\n      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n    }\n  }, {\n    key: \"getBestMatchFromCodes\",\n    value: function getBestMatchFromCodes(codes) {\n      var _this = this;\n\n      if (!codes) return null;\n      var found;\n      codes.forEach(function (code) {\n        if (found) return;\n\n        var cleanedLng = _this.formatLanguageCode(code);\n\n        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;\n      });\n\n      if (!found && this.options.supportedLngs) {\n        codes.forEach(function (code) {\n          if (found) return;\n\n          var lngOnly = _this.getLanguagePartFromCode(code);\n\n          if (_this.isSupportedCode(lngOnly)) return found = lngOnly;\n          found = _this.options.supportedLngs.find(function (supportedLng) {\n            if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;\n          });\n        });\n      }\n\n      if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n      return found;\n    }\n  }, {\n    key: \"getFallbackCodes\",\n    value: function getFallbackCodes(fallbacks, code) {\n      if (!fallbacks) return [];\n      if (typeof fallbacks === 'function') fallbacks = fallbacks(code);\n      if (typeof fallbacks === 'string') fallbacks = [fallbacks];\n      if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;\n      if (!code) return fallbacks[\"default\"] || [];\n      var found = fallbacks[code];\n      if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n      if (!found) found = fallbacks[this.formatLanguageCode(code)];\n      if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n      if (!found) found = fallbacks[\"default\"];\n      return found || [];\n    }\n  }, {\n    key: \"toResolveHierarchy\",\n    value: function toResolveHierarchy(code, fallbackCode) {\n      var _this2 = this;\n\n      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);\n      var codes = [];\n\n      var addCode = function addCode(c) {\n        if (!c) return;\n\n        if (_this2.isSupportedCode(c)) {\n          codes.push(c);\n        } else {\n          _this2.logger.warn(\"rejecting language code not found in supportedLngs: \".concat(c));\n        }\n      };\n\n      if (typeof code === 'string' && code.indexOf('-') > -1) {\n        if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));\n        if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));\n        if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));\n      } else if (typeof code === 'string') {\n        addCode(this.formatLanguageCode(code));\n      }\n\n      fallbackCodes.forEach(function (fc) {\n        if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));\n      });\n      return codes;\n    }\n  }]);\n\n  return LanguageUtil;\n}();\n\nvar sets = [{\n  lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'tl', 'ti', 'tr', 'uz', 'wa'],\n  nr: [1, 2],\n  fc: 1\n}, {\n  lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kk', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],\n  nr: [1, 2],\n  fc: 2\n}, {\n  lngs: ['ay', 'bo', 'cgg', 'fa', 'ht', 'id', 'ja', 'jbo', 'ka', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],\n  nr: [1],\n  fc: 3\n}, {\n  lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],\n  nr: [1, 2, 5],\n  fc: 4\n}, {\n  lngs: ['ar'],\n  nr: [0, 1, 2, 3, 11, 100],\n  fc: 5\n}, {\n  lngs: ['cs', 'sk'],\n  nr: [1, 2, 5],\n  fc: 6\n}, {\n  lngs: ['csb', 'pl'],\n  nr: [1, 2, 5],\n  fc: 7\n}, {\n  lngs: ['cy'],\n  nr: [1, 2, 3, 8],\n  fc: 8\n}, {\n  lngs: ['fr'],\n  nr: [1, 2],\n  fc: 9\n}, {\n  lngs: ['ga'],\n  nr: [1, 2, 3, 7, 11],\n  fc: 10\n}, {\n  lngs: ['gd'],\n  nr: [1, 2, 3, 20],\n  fc: 11\n}, {\n  lngs: ['is'],\n  nr: [1, 2],\n  fc: 12\n}, {\n  lngs: ['jv'],\n  nr: [0, 1],\n  fc: 13\n}, {\n  lngs: ['kw'],\n  nr: [1, 2, 3, 4],\n  fc: 14\n}, {\n  lngs: ['lt'],\n  nr: [1, 2, 10],\n  fc: 15\n}, {\n  lngs: ['lv'],\n  nr: [1, 2, 0],\n  fc: 16\n}, {\n  lngs: ['mk'],\n  nr: [1, 2],\n  fc: 17\n}, {\n  lngs: ['mnk'],\n  nr: [0, 1, 2],\n  fc: 18\n}, {\n  lngs: ['mt'],\n  nr: [1, 2, 11, 20],\n  fc: 19\n}, {\n  lngs: ['or'],\n  nr: [2, 1],\n  fc: 2\n}, {\n  lngs: ['ro'],\n  nr: [1, 2, 20],\n  fc: 20\n}, {\n  lngs: ['sl'],\n  nr: [5, 1, 2, 3],\n  fc: 21\n}, {\n  lngs: ['he', 'iw'],\n  nr: [1, 2, 20, 21],\n  fc: 22\n}];\nvar _rulesPluralsTypes = {\n  1: function _(n) {\n    return Number(n > 1);\n  },\n  2: function _(n) {\n    return Number(n != 1);\n  },\n  3: function _(n) {\n    return 0;\n  },\n  4: function _(n) {\n    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n  },\n  5: function _(n) {\n    return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);\n  },\n  6: function _(n) {\n    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);\n  },\n  7: function _(n) {\n    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n  },\n  8: function _(n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);\n  },\n  9: function _(n) {\n    return Number(n >= 2);\n  },\n  10: function _(n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);\n  },\n  11: function _(n) {\n    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);\n  },\n  12: function _(n) {\n    return Number(n % 10 != 1 || n % 100 == 11);\n  },\n  13: function _(n) {\n    return Number(n !== 0);\n  },\n  14: function _(n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);\n  },\n  15: function _(n) {\n    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n  },\n  16: function _(n) {\n    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);\n  },\n  17: function _(n) {\n    return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);\n  },\n  18: function _(n) {\n    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);\n  },\n  19: function _(n) {\n    return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);\n  },\n  20: function _(n) {\n    return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);\n  },\n  21: function _(n) {\n    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);\n  },\n  22: function _(n) {\n    return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);\n  }\n};\nvar deprecatedJsonVersions = ['v1', 'v2', 'v3'];\nvar suffixesOrder = {\n  zero: 0,\n  one: 1,\n  two: 2,\n  few: 3,\n  many: 4,\n  other: 5\n};\n\nfunction createRules() {\n  var rules = {};\n  sets.forEach(function (set) {\n    set.lngs.forEach(function (l) {\n      rules[l] = {\n        numbers: set.nr,\n        plurals: _rulesPluralsTypes[set.fc]\n      };\n    });\n  });\n  return rules;\n}\n\nvar PluralResolver = function () {\n  function PluralResolver(languageUtils) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck__default['default'](this, PluralResolver);\n\n    this.languageUtils = languageUtils;\n    this.options = options;\n    this.logger = baseLogger.create('pluralResolver');\n\n    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === 'v4') && (typeof Intl === 'undefined' || !Intl.PluralRules)) {\n      this.options.compatibilityJSON = 'v3';\n      this.logger.error('Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.');\n    }\n\n    this.rules = createRules();\n  }\n\n  _createClass__default['default'](PluralResolver, [{\n    key: \"addRule\",\n    value: function addRule(lng, obj) {\n      this.rules[lng] = obj;\n    }\n  }, {\n    key: \"getRule\",\n    value: function getRule(code) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.shouldUseIntlApi()) {\n        try {\n          return new Intl.PluralRules(code, {\n            type: options.ordinal ? 'ordinal' : 'cardinal'\n          });\n        } catch (_unused) {\n          return;\n        }\n      }\n\n      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];\n    }\n  }, {\n    key: \"needsPlural\",\n    value: function needsPlural(code) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var rule = this.getRule(code, options);\n\n      if (this.shouldUseIntlApi()) {\n        return rule && rule.resolvedOptions().pluralCategories.length > 1;\n      }\n\n      return rule && rule.numbers.length > 1;\n    }\n  }, {\n    key: \"getPluralFormsOfKey\",\n    value: function getPluralFormsOfKey(code, key) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.getSuffixes(code, options).map(function (suffix) {\n        return \"\".concat(key).concat(suffix);\n      });\n    }\n  }, {\n    key: \"getSuffixes\",\n    value: function getSuffixes(code) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var rule = this.getRule(code, options);\n\n      if (!rule) {\n        return [];\n      }\n\n      if (this.shouldUseIntlApi()) {\n        return rule.resolvedOptions().pluralCategories.sort(function (pluralCategory1, pluralCategory2) {\n          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];\n        }).map(function (pluralCategory) {\n          return \"\".concat(_this.options.prepend).concat(pluralCategory);\n        });\n      }\n\n      return rule.numbers.map(function (number) {\n        return _this.getSuffix(code, number, options);\n      });\n    }\n  }, {\n    key: \"getSuffix\",\n    value: function getSuffix(code, count) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var rule = this.getRule(code, options);\n\n      if (rule) {\n        if (this.shouldUseIntlApi()) {\n          return \"\".concat(this.options.prepend).concat(rule.select(count));\n        }\n\n        return this.getSuffixRetroCompatible(rule, count);\n      }\n\n      this.logger.warn(\"no plural rule found for: \".concat(code));\n      return '';\n    }\n  }, {\n    key: \"getSuffixRetroCompatible\",\n    value: function getSuffixRetroCompatible(rule, count) {\n      var _this2 = this;\n\n      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));\n      var suffix = rule.numbers[idx];\n\n      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n        if (suffix === 2) {\n          suffix = 'plural';\n        } else if (suffix === 1) {\n          suffix = '';\n        }\n      }\n\n      var returnSuffix = function returnSuffix() {\n        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();\n      };\n\n      if (this.options.compatibilityJSON === 'v1') {\n        if (suffix === 1) return '';\n        if (typeof suffix === 'number') return \"_plural_\".concat(suffix.toString());\n        return returnSuffix();\n      } else if (this.options.compatibilityJSON === 'v2') {\n        return returnSuffix();\n      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n        return returnSuffix();\n      }\n\n      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();\n    }\n  }, {\n    key: \"shouldUseIntlApi\",\n    value: function shouldUseIntlApi() {\n      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);\n    }\n  }]);\n\n  return PluralResolver;\n}();\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Interpolator = function () {\n  function Interpolator() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck__default['default'](this, Interpolator);\n\n    this.logger = baseLogger.create('interpolator');\n    this.options = options;\n\n    this.format = options.interpolation && options.interpolation.format || function (value) {\n      return value;\n    };\n\n    this.init(options);\n  }\n\n  _createClass__default['default'](Interpolator, [{\n    key: \"init\",\n    value: function init() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (!options.interpolation) options.interpolation = {\n        escapeValue: true\n      };\n      var iOpts = options.interpolation;\n      this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;\n      this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n      this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;\n      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';\n      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';\n      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n      this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';\n      this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';\n      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');\n      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');\n      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';\n      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;\n      this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;\n      this.resetRegExp();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.options) this.init(this.options);\n    }\n  }, {\n    key: \"resetRegExp\",\n    value: function resetRegExp() {\n      var regexpStr = \"\".concat(this.prefix, \"(.+?)\").concat(this.suffix);\n      this.regexp = new RegExp(regexpStr, 'g');\n      var regexpUnescapeStr = \"\".concat(this.prefix).concat(this.unescapePrefix, \"(.+?)\").concat(this.unescapeSuffix).concat(this.suffix);\n      this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');\n      var nestingRegexpStr = \"\".concat(this.nestingPrefix, \"(.+?)\").concat(this.nestingSuffix);\n      this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(str, data, lng, options) {\n      var _this = this;\n\n      var match;\n      var value;\n      var replaces;\n      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n\n      function regexSafe(val) {\n        return val.replace(/\\$/g, '$$$$');\n      }\n\n      var handleFormat = function handleFormat(key) {\n        if (key.indexOf(_this.formatSeparator) < 0) {\n          var path = getPathWithDefaults(data, defaultData, key);\n          return _this.alwaysFormat ? _this.format(path, undefined, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {\n            interpolationkey: key\n          })) : path;\n        }\n\n        var p = key.split(_this.formatSeparator);\n        var k = p.shift().trim();\n        var f = p.join(_this.formatSeparator).trim();\n        return _this.format(getPathWithDefaults(data, defaultData, k), f, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {\n          interpolationkey: k\n        }));\n      };\n\n      this.resetRegExp();\n      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n      var todos = [{\n        regex: this.regexpUnescape,\n        safeValue: function safeValue(val) {\n          return regexSafe(val);\n        }\n      }, {\n        regex: this.regexp,\n        safeValue: function safeValue(val) {\n          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);\n        }\n      }];\n      todos.forEach(function (todo) {\n        replaces = 0;\n\n        while (match = todo.regex.exec(str)) {\n          var matchedVar = match[1].trim();\n          value = handleFormat(matchedVar);\n\n          if (value === undefined) {\n            if (typeof missingInterpolationHandler === 'function') {\n              var temp = missingInterpolationHandler(str, match, options);\n              value = typeof temp === 'string' ? temp : '';\n            } else if (options && options.hasOwnProperty(matchedVar)) {\n              value = '';\n            } else if (skipOnVariables) {\n              value = match[0];\n              continue;\n            } else {\n              _this.logger.warn(\"missed to pass in variable \".concat(matchedVar, \" for interpolating \").concat(str));\n\n              value = '';\n            }\n          } else if (typeof value !== 'string' && !_this.useRawValueToEscape) {\n            value = makeString(value);\n          }\n\n          var safeValue = todo.safeValue(value);\n          str = str.replace(match[0], safeValue);\n\n          if (skipOnVariables) {\n            todo.regex.lastIndex += value.length;\n            todo.regex.lastIndex -= match[0].length;\n          } else {\n            todo.regex.lastIndex = 0;\n          }\n\n          replaces++;\n\n          if (replaces >= _this.maxReplaces) {\n            break;\n          }\n        }\n      });\n      return str;\n    }\n  }, {\n    key: \"nest\",\n    value: function nest(str, fc) {\n      var _this2 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var match;\n      var value;\n\n      var clonedOptions = _objectSpread$3({}, options);\n\n      clonedOptions.applyPostProcessor = false;\n      delete clonedOptions.defaultValue;\n\n      function handleHasOptions(key, inheritedOptions) {\n        var sep = this.nestingOptionsSeparator;\n        if (key.indexOf(sep) < 0) return key;\n        var c = key.split(new RegExp(\"\".concat(sep, \"[ ]*{\")));\n        var optionsString = \"{\".concat(c[1]);\n        key = c[0];\n        optionsString = this.interpolate(optionsString, clonedOptions);\n        var matchedSingleQuotes = optionsString.match(/'/g);\n        var matchedDoubleQuotes = optionsString.match(/\"/g);\n\n        if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n          optionsString = optionsString.replace(/'/g, '\"');\n        }\n\n        try {\n          clonedOptions = JSON.parse(optionsString);\n          if (inheritedOptions) clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);\n        } catch (e) {\n          this.logger.warn(\"failed parsing options string in nesting for key \".concat(key), e);\n          return \"\".concat(key).concat(sep).concat(optionsString);\n        }\n\n        delete clonedOptions.defaultValue;\n        return key;\n      }\n\n      while (match = this.nestingRegexp.exec(str)) {\n        var formatters = [];\n        var doReduce = false;\n\n        if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {\n          var r = match[1].split(this.formatSeparator).map(function (elem) {\n            return elem.trim();\n          });\n          match[1] = r.shift();\n          formatters = r;\n          doReduce = true;\n        }\n\n        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n        if (value && match[0] === str && typeof value !== 'string') return value;\n        if (typeof value !== 'string') value = makeString(value);\n\n        if (!value) {\n          this.logger.warn(\"missed to resolve \".concat(match[1], \" for nesting \").concat(str));\n          value = '';\n        }\n\n        if (doReduce) {\n          value = formatters.reduce(function (v, f) {\n            return _this2.format(v, f, options.lng, _objectSpread$3(_objectSpread$3({}, options), {}, {\n              interpolationkey: match[1].trim()\n            }));\n          }, value.trim());\n        }\n\n        str = str.replace(match[0], value);\n        this.regexp.lastIndex = 0;\n      }\n\n      return str;\n    }\n  }]);\n\n  return Interpolator;\n}();\n\nfunction ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction parseFormatStr(formatStr) {\n  var formatName = formatStr.toLowerCase().trim();\n  var formatOptions = {};\n\n  if (formatStr.indexOf('(') > -1) {\n    var p = formatStr.split('(');\n    formatName = p[0].toLowerCase().trim();\n    var optStr = p[1].substring(0, p[1].length - 1);\n\n    if (formatName === 'currency' && optStr.indexOf(':') < 0) {\n      if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n    } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {\n      if (!formatOptions.range) formatOptions.range = optStr.trim();\n    } else {\n      var opts = optStr.split(';');\n      opts.forEach(function (opt) {\n        if (!opt) return;\n\n        var _opt$split = opt.split(':'),\n            _opt$split2 = _toArray__default['default'](_opt$split),\n            key = _opt$split2[0],\n            rest = _opt$split2.slice(1);\n\n        var val = rest.join(':').trim().replace(/^'+|'+$/g, '');\n        if (!formatOptions[key.trim()]) formatOptions[key.trim()] = val;\n        if (val === 'false') formatOptions[key.trim()] = false;\n        if (val === 'true') formatOptions[key.trim()] = true;\n        if (!isNaN(val)) formatOptions[key.trim()] = parseInt(val, 10);\n      });\n    }\n  }\n\n  return {\n    formatName: formatName,\n    formatOptions: formatOptions\n  };\n}\n\nfunction createCachedFormatter(fn) {\n  var cache = {};\n  return function invokeFormatter(val, lng, options) {\n    var key = lng + JSON.stringify(options);\n    var formatter = cache[key];\n\n    if (!formatter) {\n      formatter = fn(lng, options);\n      cache[key] = formatter;\n    }\n\n    return formatter(val);\n  };\n}\n\nvar Formatter = function () {\n  function Formatter() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck__default['default'](this, Formatter);\n\n    this.logger = baseLogger.create('formatter');\n    this.options = options;\n    this.formats = {\n      number: createCachedFormatter(function (lng, options) {\n        var formatter = new Intl.NumberFormat(lng, options);\n        return function (val) {\n          return formatter.format(val);\n        };\n      }),\n      currency: createCachedFormatter(function (lng, options) {\n        var formatter = new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options), {}, {\n          style: 'currency'\n        }));\n        return function (val) {\n          return formatter.format(val);\n        };\n      }),\n      datetime: createCachedFormatter(function (lng, options) {\n        var formatter = new Intl.DateTimeFormat(lng, _objectSpread$4({}, options));\n        return function (val) {\n          return formatter.format(val);\n        };\n      }),\n      relativetime: createCachedFormatter(function (lng, options) {\n        var formatter = new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options));\n        return function (val) {\n          return formatter.format(val, options.range || 'day');\n        };\n      }),\n      list: createCachedFormatter(function (lng, options) {\n        var formatter = new Intl.ListFormat(lng, _objectSpread$4({}, options));\n        return function (val) {\n          return formatter.format(val);\n        };\n      })\n    };\n    this.init(options);\n  }\n\n  _createClass__default['default'](Formatter, [{\n    key: \"init\",\n    value: function init(services) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        interpolation: {}\n      };\n      var iOpts = options.interpolation;\n      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n    }\n  }, {\n    key: \"add\",\n    value: function add(name, fc) {\n      this.formats[name.toLowerCase().trim()] = fc;\n    }\n  }, {\n    key: \"addCached\",\n    value: function addCached(name, fc) {\n      this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n    }\n  }, {\n    key: \"format\",\n    value: function format(value, _format, lng, options) {\n      var _this = this;\n\n      var formats = _format.split(this.formatSeparator);\n\n      var result = formats.reduce(function (mem, f) {\n        var _parseFormatStr = parseFormatStr(f),\n            formatName = _parseFormatStr.formatName,\n            formatOptions = _parseFormatStr.formatOptions;\n\n        if (_this.formats[formatName]) {\n          var formatted = mem;\n\n          try {\n            var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};\n            var l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n            formatted = _this.formats[formatName](mem, l, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options), valOptions));\n          } catch (error) {\n            _this.logger.warn(error);\n          }\n\n          return formatted;\n        } else {\n          _this.logger.warn(\"there was no format function for \".concat(formatName));\n        }\n\n        return mem;\n      }, value);\n      return result;\n    }\n  }]);\n\n  return Formatter;\n}();\n\nfunction ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }\n\nfunction _isNativeReflectConstruct$2() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction removePending(q, name) {\n  if (q.pending[name] !== undefined) {\n    delete q.pending[name];\n    q.pendingCount--;\n  }\n}\n\nvar Connector = function (_EventEmitter) {\n  _inherits__default['default'](Connector, _EventEmitter);\n\n  var _super = _createSuper$2(Connector);\n\n  function Connector(backend, store, services) {\n    var _this;\n\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck__default['default'](this, Connector);\n\n    _this = _super.call(this);\n\n    if (isIE10) {\n      EventEmitter.call(_assertThisInitialized__default['default'](_this));\n    }\n\n    _this.backend = backend;\n    _this.store = store;\n    _this.services = services;\n    _this.languageUtils = services.languageUtils;\n    _this.options = options;\n    _this.logger = baseLogger.create('backendConnector');\n    _this.waitingReads = [];\n    _this.maxParallelReads = options.maxParallelReads || 10;\n    _this.readingCalls = 0;\n    _this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;\n    _this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;\n    _this.state = {};\n    _this.queue = [];\n\n    if (_this.backend && _this.backend.init) {\n      _this.backend.init(services, options.backend, options);\n    }\n\n    return _this;\n  }\n\n  _createClass__default['default'](Connector, [{\n    key: \"queueLoad\",\n    value: function queueLoad(languages, namespaces, options, callback) {\n      var _this2 = this;\n\n      var toLoad = {};\n      var pending = {};\n      var toLoadLanguages = {};\n      var toLoadNamespaces = {};\n      languages.forEach(function (lng) {\n        var hasAllNamespaces = true;\n        namespaces.forEach(function (ns) {\n          var name = \"\".concat(lng, \"|\").concat(ns);\n\n          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {\n            _this2.state[name] = 2;\n          } else if (_this2.state[name] < 0) ; else if (_this2.state[name] === 1) {\n            if (pending[name] === undefined) pending[name] = true;\n          } else {\n            _this2.state[name] = 1;\n            hasAllNamespaces = false;\n            if (pending[name] === undefined) pending[name] = true;\n            if (toLoad[name] === undefined) toLoad[name] = true;\n            if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n          }\n        });\n        if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n      });\n\n      if (Object.keys(toLoad).length || Object.keys(pending).length) {\n        this.queue.push({\n          pending: pending,\n          pendingCount: Object.keys(pending).length,\n          loaded: {},\n          errors: [],\n          callback: callback\n        });\n      }\n\n      return {\n        toLoad: Object.keys(toLoad),\n        pending: Object.keys(pending),\n        toLoadLanguages: Object.keys(toLoadLanguages),\n        toLoadNamespaces: Object.keys(toLoadNamespaces)\n      };\n    }\n  }, {\n    key: \"loaded\",\n    value: function loaded(name, err, data) {\n      var s = name.split('|');\n      var lng = s[0];\n      var ns = s[1];\n      if (err) this.emit('failedLoading', lng, ns, err);\n\n      if (data) {\n        this.store.addResourceBundle(lng, ns, data);\n      }\n\n      this.state[name] = err ? -1 : 2;\n      var loaded = {};\n      this.queue.forEach(function (q) {\n        pushPath(q.loaded, [lng], ns);\n        removePending(q, name);\n        if (err) q.errors.push(err);\n\n        if (q.pendingCount === 0 && !q.done) {\n          Object.keys(q.loaded).forEach(function (l) {\n            if (!loaded[l]) loaded[l] = {};\n            var loadedKeys = q.loaded[l];\n\n            if (loadedKeys.length) {\n              loadedKeys.forEach(function (ns) {\n                if (loaded[l][ns] === undefined) loaded[l][ns] = true;\n              });\n            }\n          });\n          q.done = true;\n\n          if (q.errors.length) {\n            q.callback(q.errors);\n          } else {\n            q.callback();\n          }\n        }\n      });\n      this.emit('loaded', loaded);\n      this.queue = this.queue.filter(function (q) {\n        return !q.done;\n      });\n    }\n  }, {\n    key: \"read\",\n    value: function read(lng, ns, fcName) {\n      var _this3 = this;\n\n      var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;\n      var callback = arguments.length > 5 ? arguments[5] : undefined;\n      if (!lng.length) return callback(null, {});\n\n      if (this.readingCalls >= this.maxParallelReads) {\n        this.waitingReads.push({\n          lng: lng,\n          ns: ns,\n          fcName: fcName,\n          tried: tried,\n          wait: wait,\n          callback: callback\n        });\n        return;\n      }\n\n      this.readingCalls++;\n      return this.backend[fcName](lng, ns, function (err, data) {\n        _this3.readingCalls--;\n\n        if (_this3.waitingReads.length > 0) {\n          var next = _this3.waitingReads.shift();\n\n          _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n        }\n\n        if (err && data && tried < _this3.maxRetries) {\n          setTimeout(function () {\n            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);\n          }, wait);\n          return;\n        }\n\n        callback(err, data);\n      });\n    }\n  }, {\n    key: \"prepareLoading\",\n    value: function prepareLoading(languages, namespaces) {\n      var _this4 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var callback = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (!this.backend) {\n        this.logger.warn('No backend was added via i18next.use. Will not load resources.');\n        return callback && callback();\n      }\n\n      if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);\n      if (typeof namespaces === 'string') namespaces = [namespaces];\n      var toLoad = this.queueLoad(languages, namespaces, options, callback);\n\n      if (!toLoad.toLoad.length) {\n        if (!toLoad.pending.length) callback();\n        return null;\n      }\n\n      toLoad.toLoad.forEach(function (name) {\n        _this4.loadOne(name);\n      });\n    }\n  }, {\n    key: \"load\",\n    value: function load(languages, namespaces, callback) {\n      this.prepareLoading(languages, namespaces, {}, callback);\n    }\n  }, {\n    key: \"reload\",\n    value: function reload(languages, namespaces, callback) {\n      this.prepareLoading(languages, namespaces, {\n        reload: true\n      }, callback);\n    }\n  }, {\n    key: \"loadOne\",\n    value: function loadOne(name) {\n      var _this5 = this;\n\n      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var s = name.split('|');\n      var lng = s[0];\n      var ns = s[1];\n      this.read(lng, ns, 'read', undefined, undefined, function (err, data) {\n        if (err) _this5.logger.warn(\"\".concat(prefix, \"loading namespace \").concat(ns, \" for language \").concat(lng, \" failed\"), err);\n        if (!err && data) _this5.logger.log(\"\".concat(prefix, \"loaded namespace \").concat(ns, \" for language \").concat(lng), data);\n\n        _this5.loaded(name, err, data);\n      });\n    }\n  }, {\n    key: \"saveMissing\",\n    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {\n      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {\n        this.logger.warn(\"did not save key \\\"\".concat(key, \"\\\" as the namespace \\\"\").concat(namespace, \"\\\" was not yet loaded\"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');\n        return;\n      }\n\n      if (key === undefined || key === null || key === '') return;\n\n      if (this.backend && this.backend.create) {\n        this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options), {}, {\n          isUpdate: isUpdate\n        }));\n      }\n\n      if (!languages || !languages[0]) return;\n      this.store.addResource(languages[0], namespace, key, fallbackValue);\n    }\n  }]);\n\n  return Connector;\n}(EventEmitter);\n\nfunction get() {\n  return {\n    debug: false,\n    initImmediate: true,\n    ns: ['translation'],\n    defaultNS: ['translation'],\n    fallbackLng: ['dev'],\n    fallbackNS: false,\n    supportedLngs: false,\n    nonExplicitSupportedLngs: false,\n    load: 'all',\n    preload: false,\n    simplifyPluralSuffix: true,\n    keySeparator: '.',\n    nsSeparator: ':',\n    pluralSeparator: '_',\n    contextSeparator: '_',\n    partialBundledLanguages: false,\n    saveMissing: false,\n    updateMissing: false,\n    saveMissingTo: 'fallback',\n    saveMissingPlurals: true,\n    missingKeyHandler: false,\n    missingInterpolationHandler: false,\n    postProcess: false,\n    postProcessPassResolved: false,\n    returnNull: true,\n    returnEmptyString: true,\n    returnObjects: false,\n    joinArrays: false,\n    returnedObjectHandler: false,\n    parseMissingKeyHandler: false,\n    appendNamespaceToMissingKey: false,\n    appendNamespaceToCIMode: false,\n    overloadTranslationOptionHandler: function handle(args) {\n      var ret = {};\n      if (_typeof__default['default'](args[1]) === 'object') ret = args[1];\n      if (typeof args[1] === 'string') ret.defaultValue = args[1];\n      if (typeof args[2] === 'string') ret.tDescription = args[2];\n\n      if (_typeof__default['default'](args[2]) === 'object' || _typeof__default['default'](args[3]) === 'object') {\n        var options = args[3] || args[2];\n        Object.keys(options).forEach(function (key) {\n          ret[key] = options[key];\n        });\n      }\n\n      return ret;\n    },\n    interpolation: {\n      escapeValue: true,\n      format: function format(value, _format, lng, options) {\n        return value;\n      },\n      prefix: '{{',\n      suffix: '}}',\n      formatSeparator: ',',\n      unescapePrefix: '-',\n      nestingPrefix: '$t(',\n      nestingSuffix: ')',\n      nestingOptionsSeparator: ',',\n      maxReplaces: 1000,\n      skipOnVariables: true\n    }\n  };\n}\nfunction transformOptions(options) {\n  if (typeof options.ns === 'string') options.ns = [options.ns];\n  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];\n  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];\n\n  if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {\n    options.supportedLngs = options.supportedLngs.concat(['cimode']);\n  }\n\n  return options;\n}\n\nfunction ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }\n\nfunction _isNativeReflectConstruct$3() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction noop() {}\n\nfunction bindMemberFunctions(inst) {\n  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n  mems.forEach(function (mem) {\n    if (typeof inst[mem] === 'function') {\n      inst[mem] = inst[mem].bind(inst);\n    }\n  });\n}\n\nvar I18n = function (_EventEmitter) {\n  _inherits__default['default'](I18n, _EventEmitter);\n\n  var _super = _createSuper$3(I18n);\n\n  function I18n() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var callback = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck__default['default'](this, I18n);\n\n    _this = _super.call(this);\n\n    if (isIE10) {\n      EventEmitter.call(_assertThisInitialized__default['default'](_this));\n    }\n\n    _this.options = transformOptions(options);\n    _this.services = {};\n    _this.logger = baseLogger;\n    _this.modules = {\n      external: []\n    };\n    bindMemberFunctions(_assertThisInitialized__default['default'](_this));\n\n    if (callback && !_this.isInitialized && !options.isClone) {\n      if (!_this.options.initImmediate) {\n        _this.init(options, callback);\n\n        return _possibleConstructorReturn__default['default'](_this, _assertThisInitialized__default['default'](_this));\n      }\n\n      setTimeout(function () {\n        _this.init(options, callback);\n      }, 0);\n    }\n\n    return _this;\n  }\n\n  _createClass__default['default'](I18n, [{\n    key: \"init\",\n    value: function init() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var callback = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      if (!options.defaultNS && options.defaultNS !== false && options.ns) {\n        if (typeof options.ns === 'string') {\n          options.defaultNS = options.ns;\n        } else if (options.ns.indexOf('translation') < 0) {\n          options.defaultNS = options.ns[0];\n        }\n      }\n\n      var defOpts = get();\n      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options));\n\n      if (this.options.compatibilityAPI !== 'v1') {\n        this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);\n      }\n\n      if (options.keySeparator !== undefined) {\n        this.options.userDefinedKeySeparator = options.keySeparator;\n      }\n\n      if (options.nsSeparator !== undefined) {\n        this.options.userDefinedNsSeparator = options.nsSeparator;\n      }\n\n      function createClassOnDemand(ClassOrObject) {\n        if (!ClassOrObject) return null;\n        if (typeof ClassOrObject === 'function') return new ClassOrObject();\n        return ClassOrObject;\n      }\n\n      if (!this.options.isClone) {\n        if (this.modules.logger) {\n          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n        } else {\n          baseLogger.init(null, this.options);\n        }\n\n        var formatter;\n\n        if (this.modules.formatter) {\n          formatter = this.modules.formatter;\n        } else if (typeof Intl !== 'undefined') {\n          formatter = Formatter;\n        }\n\n        var lu = new LanguageUtil(this.options);\n        this.store = new ResourceStore(this.options.resources, this.options);\n        var s = this.services;\n        s.logger = baseLogger;\n        s.resourceStore = this.store;\n        s.languageUtils = lu;\n        s.pluralResolver = new PluralResolver(lu, {\n          prepend: this.options.pluralSeparator,\n          compatibilityJSON: this.options.compatibilityJSON,\n          simplifyPluralSuffix: this.options.simplifyPluralSuffix\n        });\n\n        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n          s.formatter = createClassOnDemand(formatter);\n          s.formatter.init(s, this.options);\n          this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n        }\n\n        s.interpolator = new Interpolator(this.options);\n        s.utils = {\n          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n        };\n        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n        s.backendConnector.on('*', function (event) {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          _this2.emit.apply(_this2, [event].concat(args));\n        });\n\n        if (this.modules.languageDetector) {\n          s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n          s.languageDetector.init(s, this.options.detection, this.options);\n        }\n\n        if (this.modules.i18nFormat) {\n          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n          if (s.i18nFormat.init) s.i18nFormat.init(this);\n        }\n\n        this.translator = new Translator(this.services, this.options);\n        this.translator.on('*', function (event) {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          _this2.emit.apply(_this2, [event].concat(args));\n        });\n        this.modules.external.forEach(function (m) {\n          if (m.init) m.init(_this2);\n        });\n      }\n\n      this.format = this.options.interpolation.format;\n      if (!callback) callback = noop;\n\n      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n        if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];\n      }\n\n      if (!this.services.languageDetector && !this.options.lng) {\n        this.logger.warn('init: no languageDetector is used and no lng is defined');\n      }\n\n      var storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];\n      storeApi.forEach(function (fcName) {\n        _this2[fcName] = function () {\n          var _this2$store;\n\n          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);\n        };\n      });\n      var storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];\n      storeApiChained.forEach(function (fcName) {\n        _this2[fcName] = function () {\n          var _this2$store2;\n\n          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);\n\n          return _this2;\n        };\n      });\n      var deferred = defer();\n\n      var load = function load() {\n        var finish = function finish(err, t) {\n          if (_this2.isInitialized && !_this2.initializedStoreOnce) _this2.logger.warn('init: i18next is already initialized. You should call init just once!');\n          _this2.isInitialized = true;\n          if (!_this2.options.isClone) _this2.logger.log('initialized', _this2.options);\n\n          _this2.emit('initialized', _this2.options);\n\n          deferred.resolve(t);\n          callback(err, t);\n        };\n\n        if (_this2.languages && _this2.options.compatibilityAPI !== 'v1' && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));\n\n        _this2.changeLanguage(_this2.options.lng, finish);\n      };\n\n      if (this.options.resources || !this.options.initImmediate) {\n        load();\n      } else {\n        setTimeout(load, 0);\n      }\n\n      return deferred;\n    }\n  }, {\n    key: \"loadResources\",\n    value: function loadResources(language) {\n      var _this3 = this;\n\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n      var usedCallback = callback;\n      var usedLng = typeof language === 'string' ? language : this.language;\n      if (typeof language === 'function') usedCallback = language;\n\n      if (!this.options.resources || this.options.partialBundledLanguages) {\n        if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback();\n        var toLoad = [];\n\n        var append = function append(lng) {\n          if (!lng) return;\n\n          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);\n\n          lngs.forEach(function (l) {\n            if (toLoad.indexOf(l) < 0) toLoad.push(l);\n          });\n        };\n\n        if (!usedLng) {\n          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n          fallbacks.forEach(function (l) {\n            return append(l);\n          });\n        } else {\n          append(usedLng);\n        }\n\n        if (this.options.preload) {\n          this.options.preload.forEach(function (l) {\n            return append(l);\n          });\n        }\n\n        this.services.backendConnector.load(toLoad, this.options.ns, function (e) {\n          if (!e && !_this3.resolvedLanguage && _this3.language) _this3.setResolvedLanguage(_this3.language);\n          usedCallback(e);\n        });\n      } else {\n        usedCallback(null);\n      }\n    }\n  }, {\n    key: \"reloadResources\",\n    value: function reloadResources(lngs, ns, callback) {\n      var deferred = defer();\n      if (!lngs) lngs = this.languages;\n      if (!ns) ns = this.options.ns;\n      if (!callback) callback = noop;\n      this.services.backendConnector.reload(lngs, ns, function (err) {\n        deferred.resolve();\n        callback(err);\n      });\n      return deferred;\n    }\n  }, {\n    key: \"use\",\n    value: function use(module) {\n      if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');\n      if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');\n\n      if (module.type === 'backend') {\n        this.modules.backend = module;\n      }\n\n      if (module.type === 'logger' || module.log && module.warn && module.error) {\n        this.modules.logger = module;\n      }\n\n      if (module.type === 'languageDetector') {\n        this.modules.languageDetector = module;\n      }\n\n      if (module.type === 'i18nFormat') {\n        this.modules.i18nFormat = module;\n      }\n\n      if (module.type === 'postProcessor') {\n        postProcessor.addPostProcessor(module);\n      }\n\n      if (module.type === 'formatter') {\n        this.modules.formatter = module;\n      }\n\n      if (module.type === '3rdParty') {\n        this.modules.external.push(module);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setResolvedLanguage\",\n    value: function setResolvedLanguage(l) {\n      if (!l || !this.languages) return;\n      if (['cimode', 'dev'].indexOf(l) > -1) return;\n\n      for (var li = 0; li < this.languages.length; li++) {\n        var lngInLngs = this.languages[li];\n        if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;\n\n        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n          this.resolvedLanguage = lngInLngs;\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"changeLanguage\",\n    value: function changeLanguage(lng, callback) {\n      var _this4 = this;\n\n      this.isLanguageChangingTo = lng;\n      var deferred = defer();\n      this.emit('languageChanging', lng);\n\n      var setLngProps = function setLngProps(l) {\n        _this4.language = l;\n        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);\n        _this4.resolvedLanguage = undefined;\n\n        _this4.setResolvedLanguage(l);\n      };\n\n      var done = function done(err, l) {\n        if (l) {\n          setLngProps(l);\n\n          _this4.translator.changeLanguage(l);\n\n          _this4.isLanguageChangingTo = undefined;\n\n          _this4.emit('languageChanged', l);\n\n          _this4.logger.log('languageChanged', l);\n        } else {\n          _this4.isLanguageChangingTo = undefined;\n        }\n\n        deferred.resolve(function () {\n          return _this4.t.apply(_this4, arguments);\n        });\n        if (callback) callback(err, function () {\n          return _this4.t.apply(_this4, arguments);\n        });\n      };\n\n      var setLng = function setLng(lngs) {\n        if (!lng && !lngs && _this4.services.languageDetector) lngs = [];\n        var l = typeof lngs === 'string' ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);\n\n        if (l) {\n          if (!_this4.language) {\n            setLngProps(l);\n          }\n\n          if (!_this4.translator.language) _this4.translator.changeLanguage(l);\n          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);\n        }\n\n        _this4.loadResources(l, function (err) {\n          done(err, l);\n        });\n      };\n\n      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n        setLng(this.services.languageDetector.detect());\n      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n        this.services.languageDetector.detect(setLng);\n      } else {\n        setLng(lng);\n      }\n\n      return deferred;\n    }\n  }, {\n    key: \"getFixedT\",\n    value: function getFixedT(lng, ns, keyPrefix) {\n      var _this5 = this;\n\n      var fixedT = function fixedT(key, opts) {\n        var options;\n\n        if (_typeof__default['default'](opts) !== 'object') {\n          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n            rest[_key3 - 2] = arguments[_key3];\n          }\n\n          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));\n        } else {\n          options = _objectSpread$6({}, opts);\n        }\n\n        options.lng = options.lng || fixedT.lng;\n        options.lngs = options.lngs || fixedT.lngs;\n        options.ns = options.ns || fixedT.ns;\n        options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;\n        var keySeparator = _this5.options.keySeparator || '.';\n        var resultKey = options.keyPrefix ? \"\".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;\n        return _this5.t(resultKey, options);\n      };\n\n      if (typeof lng === 'string') {\n        fixedT.lng = lng;\n      } else {\n        fixedT.lngs = lng;\n      }\n\n      fixedT.ns = ns;\n      fixedT.keyPrefix = keyPrefix;\n      return fixedT;\n    }\n  }, {\n    key: \"t\",\n    value: function t() {\n      var _this$translator;\n\n      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);\n    }\n  }, {\n    key: \"exists\",\n    value: function exists() {\n      var _this$translator2;\n\n      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);\n    }\n  }, {\n    key: \"setDefaultNamespace\",\n    value: function setDefaultNamespace(ns) {\n      this.options.defaultNS = ns;\n    }\n  }, {\n    key: \"hasLoadedNamespace\",\n    value: function hasLoadedNamespace(ns) {\n      var _this6 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!this.isInitialized) {\n        this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);\n        return false;\n      }\n\n      if (!this.languages || !this.languages.length) {\n        this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);\n        return false;\n      }\n\n      var lng = this.resolvedLanguage || this.languages[0];\n      var fallbackLng = this.options ? this.options.fallbackLng : false;\n      var lastLng = this.languages[this.languages.length - 1];\n      if (lng.toLowerCase() === 'cimode') return true;\n\n      var loadNotPending = function loadNotPending(l, n) {\n        var loadState = _this6.services.backendConnector.state[\"\".concat(l, \"|\").concat(n)];\n\n        return loadState === -1 || loadState === 2;\n      };\n\n      if (options.precheck) {\n        var preResult = options.precheck(this, loadNotPending);\n        if (preResult !== undefined) return preResult;\n      }\n\n      if (this.hasResourceBundle(lng, ns)) return true;\n      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n      return false;\n    }\n  }, {\n    key: \"loadNamespaces\",\n    value: function loadNamespaces(ns, callback) {\n      var _this7 = this;\n\n      var deferred = defer();\n\n      if (!this.options.ns) {\n        callback && callback();\n        return Promise.resolve();\n      }\n\n      if (typeof ns === 'string') ns = [ns];\n      ns.forEach(function (n) {\n        if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);\n      });\n      this.loadResources(function (err) {\n        deferred.resolve();\n        if (callback) callback(err);\n      });\n      return deferred;\n    }\n  }, {\n    key: \"loadLanguages\",\n    value: function loadLanguages(lngs, callback) {\n      var deferred = defer();\n      if (typeof lngs === 'string') lngs = [lngs];\n      var preloaded = this.options.preload || [];\n      var newLngs = lngs.filter(function (lng) {\n        return preloaded.indexOf(lng) < 0;\n      });\n\n      if (!newLngs.length) {\n        if (callback) callback();\n        return Promise.resolve();\n      }\n\n      this.options.preload = preloaded.concat(newLngs);\n      this.loadResources(function (err) {\n        deferred.resolve();\n        if (callback) callback(err);\n      });\n      return deferred;\n    }\n  }, {\n    key: \"dir\",\n    value: function dir(lng) {\n      if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);\n      if (!lng) return 'rtl';\n      var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];\n      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';\n    }\n  }, {\n    key: \"cloneInstance\",\n    value: function cloneInstance() {\n      var _this8 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\n      var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options), {\n        isClone: true\n      });\n\n      var clone = new I18n(mergedOptions);\n\n      if (options.debug !== undefined || options.prefix !== undefined) {\n        clone.logger = clone.logger.clone(options);\n      }\n\n      var membersToCopy = ['store', 'services', 'language'];\n      membersToCopy.forEach(function (m) {\n        clone[m] = _this8[m];\n      });\n      clone.services = _objectSpread$6({}, this.services);\n      clone.services.utils = {\n        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n      };\n      clone.translator = new Translator(clone.services, clone.options);\n      clone.translator.on('*', function (event) {\n        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n          args[_key4 - 1] = arguments[_key4];\n        }\n\n        clone.emit.apply(clone, [event].concat(args));\n      });\n      clone.init(mergedOptions, callback);\n      clone.translator.options = clone.options;\n      clone.translator.backendConnector.services.utils = {\n        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n      };\n      return clone;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        options: this.options,\n        store: this.store,\n        language: this.language,\n        languages: this.languages,\n        resolvedLanguage: this.resolvedLanguage\n      };\n    }\n  }]);\n\n  return I18n;\n}(EventEmitter);\n\n_defineProperty__default['default'](I18n, \"createInstance\", function () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var callback = arguments.length > 1 ? arguments[1] : undefined;\n  return new I18n(options, callback);\n});\n\nvar instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\n\nmodule.exports = instance;\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/i18next/dist/cjs/i18next.js?");

/***/ }),

/***/ "./src/style.scss":
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://brackets-viewer/./src/style.scss?");

/***/ }),

/***/ "./node_modules/rfdc/index.js":
/*!************************************!*\
  !*** ./node_modules/rfdc/index.js ***!
  \************************************/
/***/ (function(module) {

"use strict";
eval("\nmodule.exports = rfdc\n\nfunction copyBuffer (cur) {\n  if (cur instanceof Buffer) {\n    return Buffer.from(cur)\n  }\n\n  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)\n}\n\nfunction rfdc (opts) {\n  opts = opts || {}\n\n  if (opts.circles) return rfdcCircles(opts)\n  return opts.proto ? cloneProto : clone\n\n  function cloneArray (a, fn) {\n    var keys = Object.keys(a)\n    var a2 = new Array(keys.length)\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i]\n      var cur = a[k]\n      if (typeof cur !== 'object' || cur === null) {\n        a2[k] = cur\n      } else if (cur instanceof Date) {\n        a2[k] = new Date(cur)\n      } else if (ArrayBuffer.isView(cur)) {\n        a2[k] = copyBuffer(cur)\n      } else {\n        a2[k] = fn(cur)\n      }\n    }\n    return a2\n  }\n\n  function clone (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, clone)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))\n    var o2 = {}\n    for (var k in o) {\n      if (Object.hasOwnProperty.call(o, k) === false) continue\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), clone))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), clone))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        o2[k] = clone(cur)\n      }\n    }\n    return o2\n  }\n\n  function cloneProto (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, cloneProto)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))\n    var o2 = {}\n    for (var k in o) {\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        o2[k] = cloneProto(cur)\n      }\n    }\n    return o2\n  }\n}\n\nfunction rfdcCircles (opts) {\n  var refs = []\n  var refsNew = []\n\n  return opts.proto ? cloneProto : clone\n\n  function cloneArray (a, fn) {\n    var keys = Object.keys(a)\n    var a2 = new Array(keys.length)\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i]\n      var cur = a[k]\n      if (typeof cur !== 'object' || cur === null) {\n        a2[k] = cur\n      } else if (cur instanceof Date) {\n        a2[k] = new Date(cur)\n      } else if (ArrayBuffer.isView(cur)) {\n        a2[k] = copyBuffer(cur)\n      } else {\n        var index = refs.indexOf(cur)\n        if (index !== -1) {\n          a2[k] = refsNew[index]\n        } else {\n          a2[k] = fn(cur)\n        }\n      }\n    }\n    return a2\n  }\n\n  function clone (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, clone)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))\n    var o2 = {}\n    refs.push(o)\n    refsNew.push(o2)\n    for (var k in o) {\n      if (Object.hasOwnProperty.call(o, k) === false) continue\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), clone))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), clone))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        var i = refs.indexOf(cur)\n        if (i !== -1) {\n          o2[k] = refsNew[i]\n        } else {\n          o2[k] = clone(cur)\n        }\n      }\n    }\n    refs.pop()\n    refsNew.pop()\n    return o2\n  }\n\n  function cloneProto (o) {\n    if (typeof o !== 'object' || o === null) return o\n    if (o instanceof Date) return new Date(o)\n    if (Array.isArray(o)) return cloneArray(o, cloneProto)\n    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))\n    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))\n    var o2 = {}\n    refs.push(o)\n    refsNew.push(o2)\n    for (var k in o) {\n      var cur = o[k]\n      if (typeof cur !== 'object' || cur === null) {\n        o2[k] = cur\n      } else if (cur instanceof Date) {\n        o2[k] = new Date(cur)\n      } else if (cur instanceof Map) {\n        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto))\n      } else if (cur instanceof Set) {\n        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto))\n      } else if (ArrayBuffer.isView(cur)) {\n        o2[k] = copyBuffer(cur)\n      } else {\n        var i = refs.indexOf(cur)\n        if (i !== -1) {\n          o2[k] = refsNew[i]\n        } else {\n          o2[k] = cloneProto(cur)\n        }\n      }\n    }\n    refs.pop()\n    refsNew.pop()\n    return o2\n  }\n}\n\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/rfdc/index.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"NIL\", ({\n  enumerable: true,\n  get: function get() {\n    return _nil.default;\n  }\n}));\nObject.defineProperty(exports, \"parse\", ({\n  enumerable: true,\n  get: function get() {\n    return _parse.default;\n  }\n}));\nObject.defineProperty(exports, \"stringify\", ({\n  enumerable: true,\n  get: function get() {\n    return _stringify.default;\n  }\n}));\nObject.defineProperty(exports, \"v1\", ({\n  enumerable: true,\n  get: function get() {\n    return _v.default;\n  }\n}));\nObject.defineProperty(exports, \"v3\", ({\n  enumerable: true,\n  get: function get() {\n    return _v2.default;\n  }\n}));\nObject.defineProperty(exports, \"v4\", ({\n  enumerable: true,\n  get: function get() {\n    return _v3.default;\n  }\n}));\nObject.defineProperty(exports, \"v5\", ({\n  enumerable: true,\n  get: function get() {\n    return _v4.default;\n  }\n}));\nObject.defineProperty(exports, \"validate\", ({\n  enumerable: true,\n  get: function get() {\n    return _validate.default;\n  }\n}));\nObject.defineProperty(exports, \"version\", ({\n  enumerable: true,\n  get: function get() {\n    return _version.default;\n  }\n}));\n\nvar _v = _interopRequireDefault(__webpack_require__(/*! ./v1.js */ \"./node_modules/uuid/dist/commonjs-browser/v1.js\"));\n\nvar _v2 = _interopRequireDefault(__webpack_require__(/*! ./v3.js */ \"./node_modules/uuid/dist/commonjs-browser/v3.js\"));\n\nvar _v3 = _interopRequireDefault(__webpack_require__(/*! ./v4.js */ \"./node_modules/uuid/dist/commonjs-browser/v4.js\"));\n\nvar _v4 = _interopRequireDefault(__webpack_require__(/*! ./v5.js */ \"./node_modules/uuid/dist/commonjs-browser/v5.js\"));\n\nvar _nil = _interopRequireDefault(__webpack_require__(/*! ./nil.js */ \"./node_modules/uuid/dist/commonjs-browser/nil.js\"));\n\nvar _version = _interopRequireDefault(__webpack_require__(/*! ./version.js */ \"./node_modules/uuid/dist/commonjs-browser/version.js\"));\n\nvar _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/commonjs-browser/validate.js\"));\n\nvar _stringify = _interopRequireDefault(__webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\"));\n\nvar _parse = _interopRequireDefault(__webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/commonjs-browser/parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/index.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/md5.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/md5.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\n/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  const output = [];\n  const length32 = input.length * 32;\n  const hexTab = '0123456789abcdef';\n\n  for (let i = 0; i < length32; i += 8) {\n    const x = input[i >> 5] >>> i % 32 & 0xff;\n    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  let a = 1732584193;\n  let b = -271733879;\n  let c = -1732584194;\n  let d = 271733878;\n\n  for (let i = 0; i < x.length; i += 16) {\n    const olda = a;\n    const oldb = b;\n    const oldc = c;\n    const oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  const length8 = input.length * 8;\n  const output = new Uint32Array(getOutputLength(length8));\n\n  for (let i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  const lsw = (x & 0xffff) + (y & 0xffff);\n  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nvar _default = md5;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/md5.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/native.js":
/*!***********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/native.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nvar _default = {\n  randomUUID\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/native.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/nil.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/nil.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _default = '00000000-0000-0000-0000-000000000000';\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/nil.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/parse.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/parse.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/commonjs-browser/validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parse(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nvar _default = parse;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/parse.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/regex.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/regex.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/regex.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/rng.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/rng.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = rng;\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\n\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/rng.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/sha1.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/sha1.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\n// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  const l = bytes.length / 4 + 2;\n  const N = Math.ceil(l / 16);\n  const M = new Array(N);\n\n  for (let i = 0; i < N; ++i) {\n    const arr = new Uint32Array(16);\n\n    for (let j = 0; j < 16; ++j) {\n      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n\n    M[i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (let i = 0; i < N; ++i) {\n    const W = new Uint32Array(80);\n\n    for (let t = 0; t < 16; ++t) {\n      W[t] = M[i][t];\n    }\n\n    for (let t = 16; t < 80; ++t) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    for (let t = 0; t < 80; ++t) {\n      const s = Math.floor(t / 20);\n      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nvar _default = sha1;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/sha1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/stringify.js":
/*!**************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/stringify.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nexports.unsafeStringify = unsafeStringify;\n\nvar _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/commonjs-browser/validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nvar _default = stringify;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/stringify.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v1.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v1.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/commonjs-browser/rng.js\"));\n\nvar _stringify = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng.default)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0, _stringify.unsafeStringify)(b);\n}\n\nvar _default = v1;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/v1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v3.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v3.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/commonjs-browser/v35.js\"));\n\nvar _md = _interopRequireDefault(__webpack_require__(/*! ./md5.js */ \"./node_modules/uuid/dist/commonjs-browser/md5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v3 = (0, _v.default)('v3', 0x30, _md.default);\nvar _default = v3;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/v3.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v35.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v35.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.URL = exports.DNS = void 0;\nexports[\"default\"] = v35;\n\nvar _stringify = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\");\n\nvar _parse = _interopRequireDefault(__webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/commonjs-browser/parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.DNS = DNS;\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = URL;\n\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0, _parse.default)(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0, _stringify.unsafeStringify)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/v35.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v4.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v4.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _native = _interopRequireDefault(__webpack_require__(/*! ./native.js */ \"./node_modules/uuid/dist/commonjs-browser/native.js\"));\n\nvar _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/commonjs-browser/rng.js\"));\n\nvar _stringify = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction v4(options, buf, offset) {\n  if (_native.default.randomUUID && !buf && !options) {\n    return _native.default.randomUUID();\n  }\n\n  options = options || {};\n\n  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0, _stringify.unsafeStringify)(rnds);\n}\n\nvar _default = v4;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/v4.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v5.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v5.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/commonjs-browser/v35.js\"));\n\nvar _sha = _interopRequireDefault(__webpack_require__(/*! ./sha1.js */ \"./node_modules/uuid/dist/commonjs-browser/sha1.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v5 = (0, _v.default)('v5', 0x50, _sha.default);\nvar _default = v5;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/v5.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/validate.js":
/*!*************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/validate.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _regex = _interopRequireDefault(__webpack_require__(/*! ./regex.js */ \"./node_modules/uuid/dist/commonjs-browser/regex.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex.default.test(uuid);\n}\n\nvar _default = validate;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/validate.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/version.js":
/*!************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/version.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/commonjs-browser/validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction version(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.slice(14, 15), 16);\n}\n\nvar _default = version;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/uuid/dist/commonjs-browser/version.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/***/ (function(module) {

eval("function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/arrayLikeToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/***/ (function(module) {

eval("function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/arrayWithHoles.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/***/ (function(module) {

eval("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nmodule.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/assertThisInitialized.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ (function(module) {

eval("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/classCallCheck.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/toPropertyKey.js\");\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/createClass.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/toPropertyKey.js\");\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/defineProperty.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module) {

eval("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _getPrototypeOf(o);\n}\nmodule.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/getPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\nmodule.exports = _inherits, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/inherits.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/***/ (function(module) {

eval("function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nmodule.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/iterableToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/***/ (function(module) {

eval("function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/nonIterableRest.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nvar assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return assertThisInitialized(self);\n}\nmodule.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module) {

eval("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _setPrototypeOf(o, p);\n}\nmodule.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/setPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toArray.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toArray.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles.js */ \"./node_modules/@babel/runtime/helpers/arrayWithHoles.js\");\nvar iterableToArray = __webpack_require__(/*! ./iterableToArray.js */ \"./node_modules/@babel/runtime/helpers/iterableToArray.js\");\nvar unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ \"./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js\");\nvar nonIterableRest = __webpack_require__(/*! ./nonIterableRest.js */ \"./node_modules/@babel/runtime/helpers/nonIterableRest.js\");\nfunction _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();\n}\nmodule.exports = _toArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/toArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPrimitive.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/toPrimitive.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPropertyKey.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nvar toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ \"./node_modules/@babel/runtime/helpers/toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : String(i);\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/toPropertyKey.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ (function(module) {

eval("function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/typeof.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ \"./node_modules/@babel/runtime/helpers/arrayLikeToArray.js\");\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n\n//# sourceURL=webpack://brackets-viewer/./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js?");

/***/ }),

/***/ "./src/i18n/en/translation.json":
/*!**************************************!*\
  !*** ./src/i18n/en/translation.json ***!
  \**************************************/
/***/ (function(module) {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"origin-hint\":{\"seed\":\"Seed {{position}}\",\"winner-bracket\":\"Loser of $t(abbreviations.winner-bracket) {{round}}.{{position}}\",\"winner-bracket-semi-final\":\"Loser of $t(abbreviations.winner-bracket) Semi {{position}}\",\"winner-bracket-final\":\"Loser of $t(abbreviations.winner-bracket) Final\",\"consolation-final\":\"Loser of Semi {{position}}\",\"grand-final\":\"Winner of $t(abbreviations.loser-bracket) Final\",\"double-elimination-consolation-final-opponent-1\":\"Loser of $t(abbreviations.loser-bracket) Semi 1\",\"double-elimination-consolation-final-opponent-2\":\"Loser of $t(abbreviations.loser-bracket) Final\"},\"match-label\":{\"default\":\"Match {{matchNumber}}\",\"winner-bracket\":\"$t(abbreviations.winner-bracket)\",\"loser-bracket\":\"$t(abbreviations.loser-bracket)\",\"standard-bracket\":\"$t(abbreviations.match)\",\"standard-bracket-semi-final\":\"Semi {{matchNumber}}\",\"standard-bracket-final\":\"Final\",\"double-elimination\":\"{{matchPrefix}} {{roundNumber}}.{{matchNumber}}\",\"double-elimination-semi-final\":\"{{matchPrefix}} Semi {{matchNumber}}\",\"double-elimination-final\":\"{{matchPrefix}} Final\",\"consolation-final\":\"Consolation Final\",\"grand-final-single\":\"Grand Final\",\"grand-final\":\"$t(abbreviations.grand-final) Round {{roundNumber}}\",\"match-game\":\"Game {{gameNumber}}\"},\"match-status\":{\"locked\":\"Locked\",\"waiting\":\"Waiting\",\"ready\":\"Ready\",\"running\":\"Running\",\"completed\":\"Completed\",\"archived\":\"Archived\"},\"abbreviations\":{\"win\":\"W\",\"loss\":\"L\",\"forfeit\":\"F\",\"position\":\"P\",\"seed\":\"#\",\"winner-bracket\":\"WB\",\"loser-bracket\":\"LB\",\"match\":\"M\",\"grand-final\":\"GF\"},\"ranking\":{\"rank\":{\"text\":\"#\",\"tooltip\":\"Rank\"},\"id\":{\"text\":\"Name\",\"tooltip\":\"Name\"},\"played\":{\"text\":\"P\",\"tooltip\":\"Played\"},\"wins\":{\"text\":\"$t(abbreviations.win)\",\"tooltip\":\"Wins\"},\"draws\":{\"text\":\"D\",\"tooltip\":\"Draws\"},\"losses\":{\"text\":\"$t(abbreviations.loss)\",\"tooltip\":\"Losses\"},\"forfeits\":{\"text\":\"$t(abbreviations.forfeit)\",\"tooltip\":\"Forfeits\"},\"scoreFor\":{\"text\":\"SF\",\"tooltip\":\"Score For\"},\"scoreAgainst\":{\"text\":\"SA\",\"tooltip\":\"Score Against\"},\"scoreDifference\":{\"text\":\"+/-\",\"tooltip\":\"Score Difference\"},\"points\":{\"text\":\"Pts\",\"tooltip\":\"Points\"}},\"common\":{\"bye\":\"BYE\",\"best-of-x\":\"Bo{{x}}\",\"consolation\":\"Consolation\",\"group-name\":\"Group {{groupNumber}}\",\"group-name-winner-bracket\":\"Winner Bracket\",\"group-name-loser-bracket\":\"Loser Bracket\",\"round-name\":\"Round {{roundNumber}}\",\"round-name-final\":\"Final Round\",\"round-name-winner-bracket\":\"$t(abbreviations.winner-bracket) Round {{roundNumber}}\",\"round-name-winner-bracket-final\":\"$t(abbreviations.winner-bracket) Final Round\",\"round-name-loser-bracket\":\"$t(abbreviations.loser-bracket) Round {{roundNumber}}\",\"round-name-loser-bracket-final\":\"$t(abbreviations.loser-bracket) Final Round\"},\"form-creator\":{\"stage-name-label\":\"Name your stage\",\"stage-name-placeholder\":\"Give a name for your stage\",\"stage-selector-label\":\"Select a stage\",\"team-label\":\"Name your teams\",\"team-label-placeholder\":\"Comma separated List of Team Names (must be 2^n)\",\"team-count\":\"Or a team count\",\"team-count-placeholder\":\"How many teams do you want?\",\"group-label\":\"How many groups?\",\"group-placeholder\":\"How many groups do you want?\",\"seed-order-label\":\"How would you like to order your seeds?\",\"double-elimination-seed-order-placeholder\":\"Seed order for double elimination comma separated\",\"round-robin-mode-label\":\"Which round robin mode do you like?\",\"consolation-final-label\":\"Consolation Final\",\"skip-first-round-label\":\"Skip first round\",\"grand-final-type-label\":\"Grand final type\",\"submit\":\"Create\"}}');\n\n//# sourceURL=webpack://brackets-viewer/./src/i18n/en/translation.json?");

/***/ }),

/***/ "./src/i18n/fr/translation.json":
/*!**************************************!*\
  !*** ./src/i18n/fr/translation.json ***!
  \**************************************/
/***/ (function(module) {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"origin-hint\":{\"seed\":\"Seed {{position}}\",\"winner-bracket\":\"Perdant $t(abbreviations.winner-bracket) {{round}}.{{position}}\",\"winner-bracket-semi-final\":\"Perdant $t(abbreviations.winner-bracket) Semi {{position}}\",\"winner-bracket-final\":\"Perdant Finale $t(abbreviations.winner-bracket)\",\"consolation-final\":\"Perdant Semi {{position}}\",\"grand-final\":\"Gagnant Finale $t(abbreviations.loser-bracket)\",\"double-elimination-consolation-final-opponent-1\":\"Perdant $t(abbreviations.loser-bracket) Semi 1\",\"double-elimination-consolation-final-opponent-2\":\"Perdant $t(abbreviations.loser-bracket) Final\"},\"match-label\":{\"default\":\"Match {{matchNumber}}\",\"winner-bracket\":\"$t(abbreviations.winner-bracket)\",\"loser-bracket\":\"$t(abbreviations.loser-bracket)\",\"standard-bracket\":\"$t(abbreviations.match)\",\"standard-bracket-semi-final\":\"Semi {{matchNumber}}\",\"standard-bracket-final\":\"Finale\",\"double-elimination\":\"{{matchPrefix}} {{roundNumber}}.{{matchNumber}}\",\"double-elimination-semi-final\":\"{{matchPrefix}} Semi {{matchNumber}}\",\"double-elimination-final\":\"Finale {{matchPrefix}}\",\"consolation-final\":\"Petite finale\",\"grand-final-single\":\"Grande finale\",\"grand-final\":\"$t(abbreviations.grand-final) Round {{roundNumber}}\",\"match-game\":\"Game {{gameNumber}}\"},\"match-status\":{\"locked\":\"Verrouillé\",\"waiting\":\"En attente\",\"ready\":\"Prêt\",\"running\":\"En cours\",\"completed\":\"Terminé\",\"archived\":\"Archivé\"},\"abbreviations\":{\"win\":\"V\",\"loss\":\"D\",\"forfeit\":\"F\",\"position\":\"P\",\"seed\":\"#\",\"winner-bracket\":\"WB\",\"loser-bracket\":\"LB\",\"match\":\"M\",\"grand-final\":\"GF\"},\"ranking\":{\"rank\":{\"text\":\"#\",\"tooltip\":\"Rang\"},\"id\":{\"text\":\"Name\",\"tooltip\":\"Nom\"},\"played\":{\"text\":\"J\",\"tooltip\":\"Joué\"},\"wins\":{\"text\":\"$t(abbreviations.win)\",\"tooltip\":\"Victoires\"},\"draws\":{\"text\":\"N\",\"tooltip\":\"Match nul\"},\"losses\":{\"text\":\"$t(abbreviations.loss)\",\"tooltip\":\"Défaites\"},\"forfeits\":{\"text\":\"$t(abbreviations.forfeit)\",\"tooltip\":\"Forfaits\"},\"scoreFor\":{\"text\":\"SF\",\"tooltip\":\"Score pour\"},\"scoreAgainst\":{\"text\":\"SA\",\"tooltip\":\"Score contre\"},\"scoreDifference\":{\"text\":\"+/-\",\"tooltip\":\"Différence de score\"},\"points\":{\"text\":\"Pts\",\"tooltip\":\"Points\"}},\"common\":{\"bye\":\"BYE\",\"best-of-x\":\"Bo{{x}}\",\"consolation\":\"Consolation\",\"group-name\":\"Groupe {{groupNumber}}\",\"group-name-winner-bracket\":\"Winner Bracket\",\"group-name-loser-bracket\":\"Loser Bracket\",\"round-name\":\"Round {{roundNumber}}\",\"round-name-final\":\"Round final\",\"round-name-winner-bracket\":\"$t(abbreviations.winner-bracket) Round {{roundNumber}}\",\"round-name-winner-bracket-final\":\"$t(abbreviations.winner-bracket) Round final\",\"round-name-loser-bracket\":\"$t(abbreviations.loser-bracket) Round {{roundNumber}}\",\"round-name-loser-bracket-final\":\"$t(abbreviations.loser-bracket) Round final\"},\"form-creator\":{\"stage-name-label\":\"Name your stage\",\"stage-name-placeholder\":\"Give a name for your stage\",\"stage-selector-label\":\"Select a stage\",\"team-label\":\"Name your teams\",\"team-placeholder\":\"Comma separated List of Team Names (must be 2^n)\",\"team-count\":\"Or a team count\",\"team-count-placeholder\":\"How many teams do you want?\",\"group-label\":\"How many groups?\",\"group-placeholder\":\"How many groups do you want?\",\"seed-order-label\":\"How would you like to order your seeds?\",\"double-elimination-seed-order-placeholder\":\"Seed order for double elimination comma separated\",\"round-robin-mode-label\":\"Which round robin mode do you like?\",\"consolation-final-label\":\"Consolation Final\",\"skip-first-round-label\":\"Skip first round\",\"grand-final-type-label\":\"Grand final type\",\"submit\":\"Create\"}}');\n\n//# sourceURL=webpack://brackets-viewer/./src/i18n/fr/translation.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;