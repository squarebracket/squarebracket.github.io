<html>

<head>
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/brackets-viewer@latest/dist/brackets-viewer.min.css" /> -->
  <link rel="stylesheet" href="brackets-viewer.min.css" />
  <!-- <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brackets-viewer@latest/dist/brackets-viewer.min.js"></script> -->
  <script type="text/javascript" src="brackets-viewer.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/public-google-sheets-parser?v=20230209"></script>
  <title>Better Battlefy</title>
  <link rel="stylesheet" href="dark.css" />

  <style type="text/css">
    .players {
      width: 100%;
      flex-wrap: wrap;
    }

    .player {
      width: 100%;
    }

    .streams {
      width: 100%;
    }

    h2 {
      display: none;
    }

    .player {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
    }

    .twitch-img img {
      width: 12px;
      height: 14px;
      margin-right: 5px;
    }

    .streams.top {
      margin-bottom: calc(var(--match-vertical-padding/2));
    }

    .streams.bottom {
      margin-top: var(--match-vertical-padding);
    }

    .streams:nth-of-type(2):has(.flex) {
      margin-top: var(--match-vertical-padding);
      /* border-top: 1px solid black; */
      border: 1px solid red;
    }

    .player .twitch-img,
    .streams .twitch-img {
      align-self: center;
    }

    .twitch:not(:is(.live)) img {
      filter: grayscale(100%) opacity(40%);
    }

    .player-name {
      text-overflow: ellipsis;
      width: 100%;
      overflow: hidden;
    }

    .players.top {
      border-bottom: 1px solid black;
      margin-bottom: var(--match-vertical-padding);
      padding-bottom: 2px;
    }

    .players.bottom {
      margin-top: var(--match-vertical-padding);
      border-top: 1px solid black;
      padding-top: 2px;
    }

    .navbar {
      display: block;
      position: sticky;
      top: 0px;
      left: 0px;
      z-index: 100;
      background-color: rgb(47, 51, 55);
      padding: 10px;
    }

    #links {
      display: flex;
      justify-content: space-evenly;
      flex-wrap: wrap;
    }

    .hidden {
      display: none;
    }

    .flex {
      display: flex;
    }

    .balancer {
      height: calc(12px + var(--match-vertical-padding));
      font-style: italic;
      margin-left: 17px;
      opacity: 0.5;
    }

    .elimination img {
      width: 12px;
      height: 12px;
    }

    button {
      color: white;
      background-color: rgb(220 38 38);
      border: 0 solid #e5e7eb;
      color-scheme: dark;
      padding-left: .5rem;
      padding: .5rem;
    }

    button:hover {
      color: white;
      background-color: rgb(220 38 38);
    }
  </style>

</head>

<body>
  <div class="navbar">
    <div class="controls">
      <!--<div class="search">
        <input type="text" placeholder="Search for a team or player">
      </div>-->
      <div class="buttons">
        <button id="all">show rosters</button>
        <button id="streams">show POV links</button>
        <button id="none">just matches</button>
        <button id="toggle_scores">hide scores</button>
      </div>
    </div>
    <div id="links">

    </div>
  </div>

  <h1 id="name"></h1>

  <div id="event-specific" class="hint">
      You can <a href="https://raidiant.link/GCKOOQ-MapVetoes">click here</a> to see the map vetoes.
  </div>

  <div id="live-matches">
    <h1>Currently Live Streams</h1>
    <div id="live-main"></div>
    <div id="live-pov"></div>
    <i>Please be respectful if you're watching an enemy's POV stream</i>
    <div id="live-community"></div>
  </div>

  <div id="stretch">
    <div class="hint">Note: clicking the little "Bo3" will show you map scores.</div>
    <div class="brackets-viewer"></div>

    <script type="text/javascript">

      const version = 41;

      let config = 'none';

      const gcPlayers = [
        'katsumi#fps',
        'K P#LOADZ',
        'V1 meL#ori',
      ]

      const all = () => {
        const players = document.getElementsByClassName('players');
        for (let i = 0; i < players.length; i++) {
          players[i].classList.replace('hidden', 'flex');
        }
        const streams = document.querySelectorAll('.streams');
        for (let i = 0; i < streams.length; i++) {
          streams[i].classList.replace('flex', 'hidden');
        }
        config = 'all';
      }

      const onlyStreams = () => {
        const players = document.getElementsByClassName('players');
        for (let i = 0; i < players.length; i++) {
          players[i].classList.replace('flex', 'hidden');
        }
        const streams = document.querySelectorAll('.streams');
        for (let i = 0; i < streams.length; i++) {
          streams[i].classList.replace('hidden', 'flex');
        }
        config = 'streams';
      }

      const none = () => {
        const els = document.getElementsByClassName('players');
        for (let i = 0; i < els.length; i++) {
          els[i].classList.replace('flex', 'hidden');
        }
        const streams = document.querySelectorAll('.streams');
        for (let i = 0; i < streams.length; i++) {
          streams[i].classList.replace('flex', 'hidden');
        }
        config = 'none';
      }

      let scoresShown = true;

      const toggleScores = () => {
        scoresShown = !scoresShown;
        const els = document.getElementsByClassName('result');
        for (let i = 0; i < els.length; i++) {
          if (scoresShown) {
            els[i].classList.remove('invis');
          } else {
            els[i].classList.add('invis');
          }
        }
        document.getElementById('toggle_scores').innerText = scoresShown ? 'hide scores' : 'show scores';
      }

      document.getElementById('all').addEventListener('click', all);
      document.getElementById('streams').addEventListener('click', onlyStreams);
      document.getElementById('none').addEventListener('click', none);
      document.getElementById('toggle_scores').addEventListener('click', toggleScores);


      let streamMaps = {};
      let commStreams = [];
      commStreamsExtraInfo = {};

      const mainStreams = {
        // '65c2841b53102246a56b36db': {
        // type: 'OBSERVER',
        // url: 'https://twitch.tv/raidiantgg',
        // },
      }

      // const URL = 'https://raw.githubusercontent.com/Drarig29/brackets-viewer.js/master/demo/db.json';

      // chal oq1
      // const URL = 'https://dtmwra1jsgyb0.cloudfront.net/tournaments/65b3f92d8e1b4c130d0e7307?extend%5Bstages%5D%5Bgroups%5D%5Bmatches%5D%5Btop.team%5D=true&extend%5Bstages%5D%5Bgroups%5D%5Bmatches%5D%5Bbottom.team%5D=true&extend%5Bstages%5D%5Bmatches%5D%5Btop.team%5D=true&extend%5Bstages%5D%5Bmatches%5D%5Bbottom.team%5D=true&extend%5Bstages%5D%5Bgroups%5D%5Bstandings%5D%5Bteam%5D=true&extend%5Bstages%5D%5Bstandings%5D%5Bteam%5D=true&extend%5Bstages%5D%5Bteams%5D=true';
      // const URL = 'data1.json';
      // const teamsUrl = 'https://dtmwra1jsgyb0.cloudfront.net/tournaments/65b3f92d8e1b4c130d0e7307/teams?page=1&limit=256';

      // gc1 oq1
      // const URL = 'https://dtmwra1jsgyb0.cloudfront.net/tournaments/659dd6c91f28d76ec3cc9d3d?extend%5Bstages%5D%5Bgroups%5D%5Bmatches%5D%5Btop.team%5D=true&extend%5Bstages%5D%5Bgroups%5D%5Bmatches%5D%5Bbottom.team%5D=true&extend%5Bstages%5D%5Bmatches%5D%5Btop.team%5D=true&extend%5Bstages%5D%5Bmatches%5D%5Bbottom.team%5D=true&extend%5Bstages%5D%5Bgroups%5D%5Bstandings%5D%5Bteam%5D=true&extend%5Bstages%5D%5Bstandings%5D%5Bteam%5D=true&extend%5Bstages%5D%5Bteams%5D=true';
      // const teamsUrl = 'https://dtmwra1jsgyb0.cloudfront.net/tournaments/659dd6c91f28d76ec3cc9d3d/teams?page=1&limit=256';

      // gc1 oq2
      // const URL = 'https://dtmwra1jsgyb0.cloudfront.net/tournaments/65bac6adbb579346b1d3147b?extend%5Bstages%5D%5Bgroups%5D%5Bmatches%5D%5Btop.team%5D=true&extend%5Bstages%5D%5Bgroups%5D%5Bmatches%5D%5Bbottom.team%5D=true&extend%5Bstages%5D%5Bmatches%5D%5Btop.team%5D=true&extend%5Bstages%5D%5Bmatches%5D%5Bbottom.team%5D=true&extend%5Bstages%5D%5Bgroups%5D%5Bstandings%5D%5Bteam%5D=true&extend%5Bstages%5D%5Bstandings%5D%5Bteam%5D=true&extend%5Bstages%5D%5Bteams%5D=true';
      // const teamsUrl = 'https://dtmwra1jsgyb0.cloudfront.net/tournaments/65bac6adbb579346b1d3147b/teams?page=1&limit=256';

      const startTimeMapper = (tourneyStart, stage, match, startTimeMapper, roundOffset) => {
        if (specificMatchStartTimeMapper[match._id]) {
          return new Date(specificMatchStartTimeMapper[match._id]).valueOf();
        }
        if (!startTimeMapper) {
          return new Date(stage.startTime);
        }
        const startDate = new Date(tourneyStart);
        startDate.setHours(startDate.getHours() - 1);
        const a = new Date(startTimeMapper[0]);
        const diff = startDate - a;
        let roundNum = match.roundNumber + roundOffset;
        if (stage.bracket.style === 'double' && match.matchType === 'loser') {
          roundNum++;
        }
        const b = new Date(startTimeMapper[roundNum - 1]);
        b.setMilliseconds(b.getMilliseconds() + diff);
        return b;
      }

      let matches = [];

      const processor = (obj, teams) => {
        const stages = [];
        matches = [];
        const rounds = [];
        const matchGames = [];
        const root = obj[0];
        let maxRoundNumThisStage = 0;
        let roundOffset = 0;
        root.stages.forEach((stage, index) => {
          // console.log(stage.name, stage._id);
          stage.bracket.series.forEach((round) => {
            rounds.push({
              stage_id: stage._id,
            })
          })
          let stageType;
          if (stage.bracket.type === 'elimination') {
            stageType = `${stage.bracket.style}_elimination`;
          } else if (stage.bracket.type === 'roundrobin') {
            stageType = 'round_robin';
          } else {
            console.error(`well i dunno wtf to do`);
          }
          const newStage = {
            id: stage._id,
            name: stage.name.replace(' - GSL', ''),
            type: stageType,
            groupCount: stage.bracket.groupsCount,
            number: index,
            settings: {
              size: stage.teamIDs.length,
              seedOrdering: [
                "natural",
                "natural",
                "reverse_half_shift",
                "reverse"
              ],
              // grandFinal: "double",
              matchesChildCount: 0,
            },
          };
          if (processorType === 'gsl-single' || processorType === 'gsl-double') {
            if (stage.bracket.style === 'double') {
              newStage.ends_in_qual = true;
            }
          }
          if (processorType === 'challengers1') {
            newStage.ends_in_qual = true;

          }
          if (processorType === 'challengers1') {
            newStage.ends_in_qual = true;

          }
          // if (root._id === '659dd6c91f28d76ec3cc9d3d') {
          //   if (stage.bracket.style === 'double') {
          //     newStage.ends_in_qual = true;
          //   }
          // }
          // if (root._id === '65bac6adbb579346b1d3147b') {
          //   if (stage.bracket.style === 'double') {
          //     newStage.ends_in_qual = true;
          //   }
          // }
          // if (root._id === '65b3f92d8e1b4c130d0e7307') {
          //   newStage.ends_in_qual = true;
          // }
          // if (root._id === '65c8dd5a98c0e16f5b8e45d8') {
          //   newStage.ends_in_qual = true;
          // }
          // console.log(newStage);
          stages.push(newStage);

          const bestOf = stage.bracket.series.map(s => s.numGames).reduce((acc, cur) => acc === cur ? acc : null);

          if (stageType === 'round_robin') {
            stage.groups.forEach((group) => {
              group.matches.forEach((match) => {
                maxRoundNumThisStage = Math.max(maxRoundNumThisStage, match.roundNumber);
                if (match.isBye) {
                  return;
                }
                let team1 = /BYE [A-Z]/.test(match.top.team.name) ? null : { id: null };
                if (match.top.team && !/BYE [A-Z]/.test(match.top.team.name)) {
                  team1 = {
                    id: match.top.team._id,
                    score: match.top.score,
                    result: match.isComplete ? (match.top.winner ? 'win' : 'loss') : undefined,
                    // position: match.top.seedNumber,
                  };
                }
                // console.log(match);
                let team2 = /BYE [A-Z]/.test(match.bottom.team.name) ? null : { id: null };
                if (match.bottom.team && match.bottom.team._id !== '65c28130c18d2b70ff587452' && match.bottom.team._id !== '65c2a2f00e8e805be622c0aa' && !/BYE [A-Z]/.test(match.bottom.team.name)) {
                  team2 = {
                    id: match.bottom.team._id,
                    score: match.bottom.score,
                    result: match.isComplete ? (match.bottom.winner ? 'win' : 'loss') : undefined,
                    // position: match.bottom.seedNumber,
                  };
                }
                let status = match.isComplete ? 4 : 2;
                if (match.roundNumber > 1) {
                  const lastMatch = matches.find(m => m.group_id === group.name && m.round_id === match.roundNumber - 1);
                  console.log(lastMatch);
                  if (lastMatch && lastMatch.status === 2) {
                    status = 1;
                  }
                }

                const newMatch = {
                  id: match._id,
                  stage_id: stage._id,
                  group_id: group.name,
                  round_id: match.roundNumber,
                  number: match.matchNumber,
                  status: status,
                  child_count: bestOf ?? 3,
                  opponent1: team1,
                  opponent2: team2,
                  // time: battlefyStartTimeMapper[stage._id] ? (new Date(battlefyStartTimeMapper[stage._id][match.roundNumber - 1]).valueOf()) : stage.startTime,
                };
                newMatch.time = startTimeMapper(root.startTime, stage, match, startTimeMapperType, roundOffset);
                if (newMatch.time.toString() === 'Invalid Date') {
                  console.log(newMatch);
                  return;
                }
                // console.log(newMatch);
                // TODO: remove
                // if (match._id === '65aef3864ee3d66f2a7ec064' || match._id === '65aef5198c3b6c12fcecfd47' || match._id === '65aef3864ee3d66f2a7ec066') {
                // newMatch.status = 2;
                // if (match._id === '65aef3864ee3d66f2a7ec066') {
                // newMatch.opponent2 = {id: null}
                // }
                // }

                if (mainStreams[match._id]) {
                  newMatch.stream = mainStreams[match._id];
                  console.log('found main stream game');
                }

                if (match.stats) {
                  match.stats.map((game) => {
                    return {
                      id: game._id,
                      stage_id: stage._id,
                      parent_id: match._id,
                      number: game.gameNumber,
                      status: game.stats.isComplete ? 4 : 0,
                      opponent1: {
                        id: team1.id,
                        score: game.stats.top.score,
                        result: game.stats.top.winner ? 'win' : 'loss',
                      },
                      opponent2: {
                        id: team2.id,
                        score: game.stats.bottom.score,
                        result: game.stats.bottom.winner ? 'win' : 'loss',
                      },
                    };
                  }).forEach((game) => matchGames.push(game));
                }

                matches.push(newMatch);
              })
            })
          roundOffset = roundOffset + maxRoundNumThisStage;
          } else {
            stage.matches.forEach((match) => {
              maxRoundNumThisStage = Math.max(maxRoundNumThisStage, match.roundNumber);
              if (processorType === 'challengers1') {
                if ((stage.bracket.style === 'single' && match.roundNumber > 3) || (stage.bracket.style === 'double' && match.matchType === 'winner' && match.roundNumber > 4) || (stage.bracket.style === 'double' && match.matchType === 'loser' && match.roundNumber > 6)) {
                  return;
                }
              }
              if (processorType === 'challengers2') {
                if ((stage.bracket.style === 'single' && match.roundNumber > 3) || (stage.bracket.style === 'double' && match.matchType === 'winner' && match.roundNumber > 5) || (stage.bracket.style === 'double' && match.matchType === 'loser' && match.roundNumber > 8)) {
                  return;
                }
              }
              if ((processorType === 'gsl-single' || processorType === 'gsl-double') && stage.bracket.style === 'double') {
                // stop at top 2
                if (match.roundNumber > 2) {
                  return;
                }
                if (match.matchType === 'loser' && !/group/i.test(stage.name)) {
                  match.roundNumber = match.roundNumber + 1;
                }
              }
              if (processorType === 'gsl-single' && stage.bracket.style === 'single') {
                roundOffset = 3;
              }
              if (processorType === 'gsl-double' && stage.bracket.style === 'double' && !/group/i.test(stage.name)) {
                roundOffset = 3;
              }
              // if (!match.top.team && !match.bottom.team) {
              // return;
              // }
              // if (root._id === '65b3f92d8e1b4c130d0e7307' && stage.bracket.style === 'single' && match.roundNumber > 3) {
              //   return;
              // }
              // if (root._id === '65b3f92d8e1b4c130d0e7307' && stage.bracket.style === 'double' && match.matchType === 'winner' && match.roundNumber > 4) {
              //   return;
              // }
              // if (root._id === '65b3f92d8e1b4c130d0e7307' && stage.bracket.style === 'double' && match.matchType === 'loser' && match.roundNumber > 6) {
              //   return;
              // }
              // if (root._id === '65c8dd5a98c0e16f5b8e45d8' && stage.bracket.style === 'single' && match.roundNumber > 3) {
              //   return;
              // }
              // if (root._id === '65c8dd5a98c0e16f5b8e45d8' && stage.bracket.style === 'double' && match.matchType === 'winner' && match.roundNumber > 5) {
              //   return;
              // }
              // if (root._id === '65c8dd5a98c0e16f5b8e45d8' && stage.bracket.style === 'double' && match.matchType === 'loser' && match.roundNumber > 8) {
              //   return;
              // }
              // if (root._id === '659dd6c91f28d76ec3cc9d3d' && stage.bracket.style === 'double' && match.roundNumber > 2) {
              //   return;
              // }
              // if (root._id === '65bac6adbb579346b1d3147b' && stage.bracket.style === 'double' && match.roundNumber > 2) {
              //   return;
              // }
              // if (root._id === '65f91291f9fbe42090326fa5' && stage.bracket.style === 'double' && match.roundNumber > 2) {
              //   return;
              // }
              // console.log({
              //   id: match._id,
              //   stage: stage._id === '65b3f93d8c9f89131f26c78f' ? 'single' : 'double',
              //   group_id: match.matchType,
              //   round_id: match.roundNumber,
              //   teamA: match.top.team && match.top.team.name,
              //   teamB: match.bottom.team && match.bottom.team.name,
              // });
              let team1 = { id: null };
              if (match.top.team) {
                team1 = {
                  id: match.top.team._id,
                  score: match.top.score,
                  result: match.isComplete ? (match.top.winner ? 'win' : 'loss') : undefined,
                  // position: match.top.seedNumber,
                };
              }
              // console.log(match);
              let team2 = (match.isBye || (match.bottom.team && /BYE [A-Z]/.test(match.bottom.team.name))) ? null : { id: null };
              if (match.bottom.team && !/BYE [A-Z]/.test(match.bottom.team.name) && match.bottom.team._id !== '65c28130c18d2b70ff587452' && match.bottom.team._id !== '65c2a2f00e8e805be622c0aa') {
                team2 = {
                  id: match.bottom.team._id,
                  score: match.bottom.score,
                  result: match.isComplete ? (match.bottom.winner ? 'win' : 'loss') : undefined,
                  // position: match.bottom.seedNumber,
                };
              }



              const newMatch = {
                id: match._id,
                stage_id: stage._id,
                group_id: match.matchType,
                round_id: match.roundNumber,
                number: match.matchNumber,
                status: match.isComplete ? 4 : 2,
                child_count: bestOf ?? 3,
                opponent1: team1,
                opponent2: team2,
                // time: battlefyStartTimeMapper[stage._id] ? (new Date(battlefyStartTimeMapper[stage._id][match.roundNumber - 1]).valueOf()) : stage.startTime,
              };
              newMatch.time = startTimeMapper(root.startTime, stage, match, startTimeMapperType, roundOffset);
              if (newMatch.time.toString() === 'Invalid Date') {
                console.log(newMatch);
                return;
              }
              // console.log(newMatch);
              // TODO: remove
              // if (match._id === '65aef3864ee3d66f2a7ec064' || match._id === '65aef5198c3b6c12fcecfd47' || match._id === '65aef3864ee3d66f2a7ec066') {
              // newMatch.status = 2;
              // if (match._id === '65aef3864ee3d66f2a7ec066') {
              // newMatch.opponent2 = {id: null}
              // }
              // }

              if (mainStreams[match._id]) {
                newMatch.stream = mainStreams[match._id];
                console.log('found main stream game');
              }

              if (match.stats) {
                match.stats.map((game) => {
                  return {
                    id: game._id,
                    stage_id: stage._id,
                    parent_id: match._id,
                    number: game.gameNumber,
                    status: game.stats.isComplete ? 4 : 0,
                    opponent1: {
                      id: team1.id,
                      score: game.stats.top.score,
                      result: game.stats.top.winner ? 'win' : 'loss',
                    },
                    opponent2: {
                      id: team2.id,
                      score: game.stats.bottom.score,
                      result: game.stats.bottom.winner ? 'win' : 'loss',
                    },
                  };
                }).forEach((game) => matchGames.push(game));
              }

              matches.push(newMatch);

            })
          }
        });
        return {
          stages,
          matches,
          matchGames,
        }
      };

      const teamsMap = {};
      let maxPlayers = 0;
      const teamImages = [];

      const doRender = (update) => {
        console.log('starting');
        fetch(teamsUrl).then((res) => res.json()).then(teams => {
          // teams = teams.filter(team => team.persistentTeam !== undefined).map(team => {
          teams = teams.filter(team => !/BYE [A-Z]/.test(team.name)).map(team => {
            if (team.persistentTeam) {
              teamImages.push({
                participantId: team._id,
                imageUrl: team.persistentTeam.logoUrl,
              });
            }
            return {
              id: team._id,
              name: team.name,
              tournament_id: 0,
              players: team.players.map(player => {
                return {
                  id: player._id,
                  name: player.inGameName,
                  twitch: streamMaps[player.inGameName] ? streamMaps[player.inGameName].name : undefined,
                };
              }),
            };
          });
          teams.forEach((team) => {
            teamsMap[team.id] = team
            maxPlayers = Math.max(maxPlayers, team.players.length);
          });
          fetch(URL).then((res) => res.json()).then(data => {
            tourneyName = data[0].name;
            document.querySelector('#name').innerHTML = tourneyName;
            document.title = tourneyName;
            // console.log(data);
            data = processor(data, teams);
            // console.log(data);
            const config = {
              clear: true,
              separatedChildCountLabel: true,
              // showRankingTable: false,
              // customRoundName: (info, t) => {
                // if (info.groupType === "single-bracket" && info.roundNumber === 1) {
                //   return 'RO256';
                // } else if (info.groupType === "single-bracket" && info.roundNumber === 2) {
                //   return 'RO128';
                // } else if (info.groupType === "single-bracket" && info.roundNumber === 3) {
                //   return 'RO64';
                // }
                // if (info.groupType === 'loser-bracket' && info.roundNumber === 1) {
                //   return 'Elimination';
                // } else if (info.groupType === 'loser-bracket' && info.roundNumber === 2) {
                //   return 'Decider';
                // } else if (info.groupType === 'winner-bracket' && info.roundNumber === 1) {
                //   return 'Opening';
                // } else if (info.groupType === 'winner-bracket' && info.roundNumber === 2) {
                //   return "Winner's";
                // }
              // },
              // showPopoverOnMatchLabelClick: true,
              // showSlotsOrigin: false,
              // participantOriginPlacement: 'before',
              // highlightParticipantOnHover: false,
            }
            // if (update) {
            //   data.matches.forEach((match) => {
            //     window.bracketsViewer.update()
            //   })
            // }
            window.bracketsViewer.setParticipantImages(teamImages);
            window.bracketsViewer.render({ participants: teams, ...data }, config).then(() => {
              console.log('rendering finished');
              addStreams();
              addPlayers();
              getCurrentlyLiveMatches();
              createLinks();
              if (anchor) {
                console.log(`trying to scroll to ${anchor}`)
                document.querySelector(anchor).scrollIntoView();
              }
            });
            // window.bracketsViewer.render({ stages: data.stage, matches: data.match, matchGames: data.match_game, participants: data.participant, });
          });
        });
      }

      function createLinks() {
        console.log('creating links');
        const container = document.querySelector('#links');
        container.innerHTML = '';
        const h1s = document.querySelectorAll('.brackets-viewer h1, #live-matches:has(#live-main:not(:empty), #live-pov:not(:empty), #live-community:not(:empty)) h1');
        h1s.forEach(h1 => {
          // const stageLinkContainer = document.createElement('div');
          // stageLinkContainer.classList.add('flex');
          const link = document.createElement('a');
          link.classList.add('stages');
          link.setAttribute('href', '#' + h1.id);
          link.innerText = h1.innerText;
          container.append(link);
        });
        console.log('created links');
      }

      /**
       * Creates a container which contains the players for a participant.
       *
       * @param participantId ID of the participant.
       */
      function createPlayers(teamId, players, top) {
        const playersContainer = document.createElement('div');
        playersContainer.classList.add('players');
        if (config === 'streams' || config === 'none') {
          playersContainer.classList.add('hidden');
        } else {
          playersContainer.classList.add('flex');
        }

        if (top) {
          playersContainer.classList.add('top');
        } else {
          playersContainer.classList.add('bottom');
        }

        if (teamId !== null && teamId !== undefined)
          playersContainer.setAttribute('data-participant-id', teamId.toString());
        // else
        // return playersContainer;

        for (let i = 0; i < players.length; i++) {
          const player = players[i];
          // console.log(`executing for ${i}:`, player);

          const playerContainer = document.createElement('div');
          playerContainer.classList.add('player');
          playerContainer.classList.add('flex');

          playerContainer.setAttribute('data-player-username', player.name);

          const playerName = document.createElement('div');
          playerName.classList.add('player-name');
          playerName.innerText = player.name;

          playerContainer.append(playerName);

          if (streamMaps[player.name]) {
            const twitchUsername = streamMaps[player.name].twitch;
            playerContainer.classList.add('twitch');
            playerContainer.setAttribute('data-player-twitch', twitchUsername);
            if (streamMaps[player.name].online) {
              playerContainer.classList.add('live');
            }

            const playerTwitch = document.createElement('div');
            playerTwitch.classList.add('twitch-img');

            const twitchLink = document.createElement('a');
            twitchLink.setAttribute('href', `https://twitch.tv/${twitchUsername}`);
            twitchLink.setAttribute('target', `_blank`);

            const twitchImg = document.createElement('img');
            twitchImg.setAttribute('src', 'TwitchGlitchPurple.png');
            twitchImg.setAttribute('alt', 'Twitch channel');

            twitchLink.appendChild(twitchImg);

            playerTwitch.append(twitchLink);

            playerContainer.prepend(playerTwitch);
          }

          playersContainer.append(playerContainer);

        }

        return playersContainer;
      }

      function addPlayers() {
        console.log('adding players');
        const els = document.querySelectorAll('.brackets-viewer .opponents');
        for (let i = 0; i < els.length; i++) {
          const [topEl, bottomEl] = els[i].querySelectorAll('.participant');

          if (!topEl || !bottomEl) {
            continue;
          }

          const topTeamId = topEl ? topEl.getAttribute('data-participant-id') : null;
          const bottomTeamId = bottomEl ? bottomEl.getAttribute('data-participant-id') : null;

          const top = topTeamId ? teamsMap[topTeamId] : { id: null, players: [] };
          const bottom = bottomTeamId ? teamsMap[bottomTeamId] : { id: null, players: [] };
          // console.log('top', top, 'bottom', bottom);

          // try {
          // if (top) {
          const topTeamPlayers = createPlayers(top.id, top.players, true);
          topEl.prepend(topTeamPlayers);
          // }

          // if (bottom) {
          const bottomTeamPlayers = createPlayers(bottom.id, bottom.players);
          bottomEl.append(bottomTeamPlayers);
          // }
          // } catch {}
        }
        console.log('added players');
      }

      /**
       * Creates a container which contains the players for a participant.
       *
       * @param participantId ID of the participant.
       */
      function createStreams(teamId, players) {
        const streamsContainer = document.createElement('div');
        streamsContainer.classList.add('streams');
        if (config === 'all' || config === 'none') {
          streamsContainer.classList.add('hidden');
        } else {
          streamsContainer.classList.add('flex');
        }

        if (teamId !== null && teamId !== undefined)
          streamsContainer.setAttribute('data-participant-id', teamId.toString());
        // else
        // return playersContainer;

        for (let i = 0; i < players.length; i++) {
          const player = players[i];
          if (!streamMaps[player.name]) {
            continue;
          }
          const streamContainer = document.createElement('div');
          streamContainer.classList.add('stream');
          streamContainer.setAttribute('data-player-username', player.name);

          const twitchUsername = streamMaps[player.name].twitch;
          streamContainer.classList.add('twitch');
          streamContainer.classList.add('twitch-img');
          streamContainer.setAttribute('data-player-twitch', twitchUsername);
          if (streamMaps[player.name].online) {
            streamContainer.classList.add('live');
          }

          const twitchLink = document.createElement('a');
          twitchLink.setAttribute('href', `https://twitch.tv/${twitchUsername}`);
          twitchLink.setAttribute('target', `_blank`);

          const twitchImg = document.createElement('img');
          twitchImg.setAttribute('src', 'TwitchGlitchPurple.png');
          twitchImg.setAttribute('alt', 'Twitch channel');

          twitchLink.appendChild(twitchImg);

          streamContainer.append(twitchLink);

          streamsContainer.append(streamContainer);

        }

        if (!streamsContainer.firstChild) {
          const balancer = document.createElement('div');
          balancer.innerHTML = '';
          balancer.classList.add('balancer');
          streamsContainer.append(balancer);
        }

        return streamsContainer;
      }

      function addStreams() {
        console.log('adding streams');
        const els = document.querySelectorAll('.brackets-viewer .opponents');
        for (let i = 0; i < els.length; i++) {
          const [topEl, bottomEl] = els[i].querySelectorAll('.participant');

          if (!topEl || !bottomEl) {
            continue;
          }

          const topTeamId = topEl ? topEl.getAttribute('data-participant-id') : null;
          const bottomTeamId = bottomEl ? bottomEl.getAttribute('data-participant-id') : null;

          const top = topTeamId ? teamsMap[topTeamId] : { id: null, players: [] };
          const bottom = bottomTeamId ? teamsMap[bottomTeamId] : { id: null, players: [] };
          // console.log('top', top, 'bottom', bottom);

          const topPlayersLength = top ? top.players.length : 0;
          const bottomPlayersLength = bottom ? bottom.players.length : 0;

          // try {
          // if (top) {
          const topTeamStreams = createStreams(top.id, top.players);
          topTeamStreams.classList.add('top');
          topEl.prepend(topTeamStreams);
          // }

          // if (bottom) {
          const bottomTeamStreams = createStreams(bottom.id, bottom.players);
          bottomTeamStreams.classList.add('bottom');
          bottomEl.append(bottomTeamStreams);
          // }
          // } catch {}
        }
        console.log('added streams');

      }


      // gc oqs
      // const battlefyStartTimeMapper = {
      //     "65c280f819f84b4165e5d0c2": [
      //       "2024-02-06T22:00:00.000Z",
      //       "2024-02-06T23:30:00.000Z",
      //       "2024-02-07T22:00:00.000Z"
      //     ],
      //     "65c282e52a48a17077509e55": [
      //       "2024-02-06T22:00:00.000Z",
      //       "2024-02-06T23:30:00.000Z",
      //       "2024-02-07T22:00:00.000Z"
      //     ],
      //     "65c283af7a99b36ebb92ec1a": [
      //       "2024-02-06T22:00:00.000Z",
      //       "2024-02-06T23:30:00.000Z",
      //       "2024-02-07T22:00:00.000Z"
      //     ],
      //     "65c283ebbb579346b1d32191": [
      //       "2024-02-06T22:00:00.000Z",
      //       "2024-02-06T23:30:00.000Z",
      //       "2024-02-07T22:00:00.000Z"
      //     ],
      //     "65c284298c3b6c12fced133b": [
      //       "2024-02-06T22:00:00.000Z",
      //       "2024-02-06T23:30:00.000Z",
      //       "2024-02-07T22:00:00.000Z"
      //     ],
      //     "65c284631585ab131e7645a1": [
      //       "2024-02-06T22:00:00.000Z",
      //       "2024-02-06T23:30:00.000Z",
      //       "2024-02-07T22:00:00.000Z"
      //     ],
      //     "65c284e95bb3ee66513f019e": [
      //       "2024-02-06T22:00:00.000Z",
      //       "2024-02-06T23:30:00.000Z",
      //       "2024-02-07T22:00:00.000Z"
      //     ],
      //     "65c2850efbc92571d1927b4a": [
      //       "2024-02-06T22:00:00.000Z",
      //       "2024-02-06T23:30:00.000Z",
      //       "2024-02-07T22:00:00.000Z"
      //     ],
      //     "65c285410e8e805be622c080": [
      //       "2024-02-06T22:00:00.000Z",
      //       "2024-02-06T23:30:00.000Z",
      //       "2024-02-07T22:00:00.000Z"
      //     ],
      //     "65c285660e8e805be622c088": [
      //       "2024-02-06T22:00:00.000Z",
      //       "2024-02-06T23:30:00.000Z",
      //       "2024-02-07T22:00:00.000Z"
      //     ],
      //     "65c2858a1f28d76ec3cccbae": [
      //       "2024-02-06T22:00:00.000Z",
      //       "2024-02-06T23:30:00.000Z",
      //       "2024-02-07T22:00:00.000Z"
      //     ],
      //     "65c285af5bb3ee66513f01a6": [
      //       "2024-02-06T22:00:00.000Z",
      //       "2024-02-06T23:30:00.000Z",
      //       "2024-02-07T22:00:00.000Z"
      //     ],
      //     "65c42cfca19d2063eaee85d8": [
      //       '2024-02-07T23:30:00.000Z',
      //       '2024-02-09T22:00:00.000Z',
      //       '2024-02-09T23:30:00.000Z',
      //       '2024-02-10T22:00:00.000Z',
      //       '2024-02-11T00:00:00.000Z',
      //     ],
      // };

      // const battlefyStartTimeMapper = {};
      const battlefyStartTimeMapper = {
        '65c8dd73287012640b4f1f6c': [
          '2024-02-12T22:00:00.000Z',
          '2024-02-12T23:00:00.000Z',
          '2024-02-13T02:00:00.000Z',
        ],
        '65c8dd9665baba5fcd1166a8': [
          '2024-02-13T22:00:00.000Z',
          '2024-02-14T00:00:00.000Z',
          '2024-02-14T02:00:00.000Z',
          '2024-02-14T22:00:00.000Z',
          '2024-02-15T00:00:00.000Z',
          '2024-02-15T02:00:00.000Z',
          '2024-02-15T22:00:00.000Z',
          '2024-02-16T00:00:00.000Z',
          '2024-02-16T02:00:00.000Z',
        ],
      };
      const specificMatchStartTimeMapper = {
        '65c8dd9665baba5fcd1166c6': '2024-02-15T00:00:00.000Z',
        '65c8dd9665baba5fcd1166c7': '2024-02-15T02:00:00.000Z',
      }
      const timeMappers = {
        'gca': [
          '2024-11-09T21:00:00.000Z',
          '2024-11-09T21:45:00.000Z',
          '2024-11-09T22:30:00.000Z',
          '2024-11-09T23:30:00.000Z',
          '2024-11-10T01:45:00.000Z',
          '2024-11-10T21:00:00.000Z',
          '2024-11-10T23:30:00.000Z',
        ],
        'gc-quals': [
          '2024-03-22T21:00:00.000Z',
          '2024-03-22T22:30:00.000Z',
          '2024-03-23T21:00:00.000Z',
          '2024-03-23T23:00:00.000Z',
          '2024-03-25T21:00:00.000Z',
          '2024-03-25T23:00:00.000Z',
          '2024-03-26T21:00:00.000Z',
          '2024-03-26T23:30:00.000Z',
        ],
        'mfh': [
          '2024-09-20T22:00:00.000Z',
          '2024-09-21T00:00:00.000Z',
          '2024-09-21T02:00:00.000Z',
          '2024-09-21T17:00:00.000Z',
          '2024-09-21T19:00:00.000Z',
          '2024-09-21T21:00:00.000Z',
          '2024-09-22T20:00:00.000Z',
          '2024-09-22T22:00:00.000Z',
          '2024-09-23T00:00:00.000Z',
        ]
      }

      function getTwitchStatus() {
        console.log('getting twitch live status for pov streams');
        const twitchStreams = [];
        const players = Object.keys(streamMaps);
        for (let i = 0; i < players.length; i++) {
          twitchStreams.push(streamMaps[players[i]].twitch);
        }
        if (!twitchStreams.length) {
          console.log('no streams to check');
          return Promise.resolve();
        }
        const qs = twitchStreams.map((stream) => `user_login=${stream}`).join('&');
        return new Promise((resolve, reject) => {
          fetch(`https://api.twitch.tv/helix/streams?${qs}&type=live&first=100`, {
            headers: {
              Authorization: `Bearer nhme5vg4979f35qwxm3ebl4m74972k`,
              'Client-Id': 'fvt86l1gr691ynogv3kz1gd2djv7qn',
            },
          })
            .then(res => res.json())
            .then((obj) => {
              const onlineStreams = obj.data.map(broadcaster => broadcaster.user_login);
              const playersWithTwitch = document.querySelectorAll('.player .twitch');
              playersWithTwitch.forEach(el => !el.classList.contains('live') && el.classList.remove('live'));

              players.forEach((username) => {
                const stream = streamMaps[username].twitch;
                if (!onlineStreams.includes(stream.toLowerCase())) {
                  // console.log(`${stream} is offline`);
                  return;
                }
                // console.log(`${stream} is online`);
                streamMaps[username].online = true;
                const el = document.querySelector(`.player[data-player-twitch='${stream}']`);
                if (el) {
                  if (!el.classList.contains('live')) {
                    el.classList.add('live');
                  }
                }
              });
              // streamMaps['kim#618'].online = true;
            }).then(() => {
              console.log('finished getting twitch live status for pov streams');
              resolve(Promise.resolve());
            });
        });
      }

      let tester = false;
      setTimeout(() => {
        tester = true;
      }, 30000);

      function getTwitchCommStatus() {
        console.log('getting twitch live status for community streams');
        const users = Object.keys(commStreams);
        if (!users.length) {
          console.log('no streams to check');
          return Promise.resolve();
        }
        const qs = users.map((stream) => `user_login=${stream}`).join('&');
        return new Promise((resolve, reject) => {
          return fetch(`https://api.twitch.tv/helix/streams?${qs}&type=live&first=100`, {
            headers: {
              Authorization: `Bearer nhme5vg4979f35qwxm3ebl4m74972k`,
              'Client-Id': 'fvt86l1gr691ynogv3kz1gd2djv7qn',
            },
          })
            .then(res => res.json())
            .then((obj) => {
              users.forEach(user => {
                commStreams[user] = false;
              });
              obj.data.forEach(twitchInfo => {
                console.log(twitchInfo);
                if (twitchInfo.game_name !== 'VALORANT') {
                  return;
                }
                // if (/GameChangers/i.test(twitchInfo.title) || /game changers/i.test(twitchInfo.title) || /gc/i.test(twitchInfo.title)) {
                commStreams[twitchInfo.user_login] = twitchInfo.title;
                // }
              });
              // TODO: remove
              // if (tester) {
              // commStreams['zhobiii'] = 'Watching GC';
              // }
            }).then(() => {
              console.log('finished getting twitch live status for community streams');
              resolve(Promise.resolve());
            });
        });
      }

      async function getStreamMapper() {
        console.log('getting pov twitch mapping data');
        const spreadsheetId = '1zjETtDxTaUEugmHPKWJxZ4ArUylcKC7kcchvAWeUJsc';
        const sheetId = 0;
        const sheetName = tournament;
        const sheetInfo = { sheetId, sheetName }
        let parser = new PublicGoogleSheetsParser(spreadsheetId, sheetInfo);
        await (parser.parse().then((items) => {
          streamMaps = {};
          for (let i = 0; i < items.length; i++) {
            const row = items[i];
            if (!streamMaps[row['riot id']]) {
              streamMaps[row['riot id']] = {
                twitch: row['twitch username'],
                online: false,
              };
            }
          }
          console.log('finished getting pov twitch mapping data');
          return Promise.resolve();
        }));
        console.log('getting community stream data');
        sheetInfo.sheetId = null;
        sheetInfo.sheetName = `${tournament}_comm`;
        parser = new PublicGoogleSheetsParser(spreadsheetId, sheetInfo);
        await (parser.parse().then((items) => {
          commStreams = {};
          items.forEach(row => {
            commStreams[row['stream']] = false;
            if (row['extra info']) {
              commStreamsExtraInfo[row['stream']] = row['extra info'];
            }
          })
        }));
        console.log('finished getting community stream data');
        await getTwitchStatus();
        await getTwitchCommStatus();
        await doRender();
      }

      function createLiveEntry(team1, team2, urls) {
        const m = document.createElement('div');
        m.classList.add('live-match');
        const words = document.createElement('div');
        if (team1 && team2) {
          words.innerHTML = `<span class="team">${team1}</span> vs <span class="team">${team2}</span>`;
        } else {
          words.innerHTML = team1;
        }
        m.append(words);
        if (!Array.isArray(urls)) {
          urls = [urls];
        }
        urls.forEach(url => {
          const twitchDiv = document.createElement('div');
          const link = document.createElement('a');
          link.href = `https://twitch.tv/${url}`;
          link.alt = `twitch stream for ${url}`;
          link.target = '_blank';
          twitchDiv.classList.add('twitch-img');
          const img = document.createElement('img');
          img.src = 'TwitchGlitchPurple.png';
          link.append(img);
          twitchDiv.append(link);
          m.append(twitchDiv);
        });
        return m;
      }

      const mainChannelMapper = {
        'nagc': ['raidiantgg', 'raidiant_beam',],
        'knights': ['valorant_northamerica', 'knightsarena', 'knightsarena_a', 'knightsarena_b'],
        'mrfh': ['mrfunhaver', 'funhaverinvitational'],
        '65c8dd5a98c0e16f5b8e45d8': ['valorant_northamerica', 'knightsarena', 'knightsarena_a', 'knightsarena_b'],
        '659dd6c91f28d76ec3cc9d3d': ['raidiantgg', 'raidiant_beam',],
        '6609a38e86dc730b9efd91d7': ['raidiantgg', 'raidiant_beam',],
        '662436e173911d2090ddeac1': ['raidiantgg', 'raidiant_beam',],
        '65bac6adbb579346b1d3147b': ['raidiantgg', 'raidiant_beam',],
        '65f91291f9fbe42090326fa5': ['mrfunhaver', 'funhaverinvitational'],
        'bell': ['bellcanada', 'torontoserenity'],
      };

      const splitters = {
        'nagc': '|',
        'knights': '-',
        'mrfh': '|',
        '65c8dd5a98c0e16f5b8e45d8': '-',
        '659dd6c91f28d76ec3cc9d3d': '|',
        '6609a38e86dc730b9efd91d7': '|',
        '65f91291f9fbe42090326fa5': '|',
        '65bac6adbb579346b1d3147b': '|',
        '662436e173911d2090ddeac1': '|',
      }

      function getCurrentlyLiveMatches() {
        console.log('constructing currently live matches');
        const liveMains = document.querySelector('#live-main');
        const qs = mainChannels.map((stream) => `user_login=${stream}`).join('&');
        fetch(`https://api.twitch.tv/helix/streams?${qs}&type=all&first=100`, {
          headers: {
            Authorization: `Bearer nhme5vg4979f35qwxm3ebl4m74972k`,
            'Client-Id': 'fvt86l1gr691ynogv3kz1gd2djv7qn',
          },
        })
          .then(res => res.json())
          .then((obj) => {
            // TODO: remove
            // if (tester) {
            //   obj.data = [{
            //     user_login: 'raidiantgg',
            //     title: 'Verizon VCT Game Changers | Series 1 OQ 1 | Day 3 | :3 VS BERZERKERS',
            //   }, {
            //     user_login: 'raidiant_beam',
            //     title: `Verizon VCT Game Changers | Series 1 OQ 1 | Day 4 | Series 1 + 2`,
            //   }];
            //     obj.data = [{
            //       user_login: 'valorant_northamerica',
            //       title: 'VCT Challengers NA 2024 Open Qualifier #1 Day 4 - Ambrosia vs Thinking Men (OBS ONLY)',
            //     }, {
            //       user_login: 'knightsarena',
            //       title: `VCT Challengers NA 2024 Open Qualifier #1 Day 3 - 1337 vs Shopify Rebellion (OBS ONLY)`,
            //     }];
            // }
            liveMains.innerHTML = '';
            obj.data.forEach((twitchInfo) => {
              if (twitchInfo.game_name !== 'VALORANT') {
                return;
              }
              splits = twitchInfo.title.split(splitter);
              let team1;
              let team2;
              splits.forEach((chunk => {
                if (/ vs.? /i.test(chunk)) {
                  [team1, team2] = chunk.split(/ vs.? /i);
                }
              }));
              if (!team1 || !team2) {
                team1 = twitchInfo.title.trim();
              }
              const entry = createLiveEntry(team1, team2 && team2.trim(), twitchInfo.user_login);
              liveMains.append(entry);
            })
          });

        const livePOVs = [];
        matches.forEach((match) => {
          // console.log(Date.now() < match.time - 3600000, Date.now(), match.time.valueOf());
          if (Date.now() < match.time || match.status === 4 || (match.opponent1 && match.opponent1.id === null) || (match.opponent2 && match.opponent2.id === null) || match.status === 1) {
            return;
          }
          let povs = [];
          if (match.opponent1) {
            const team1Povs = teamsMap[match.opponent1.id].players
              .filter(player => streamMaps[player.name] && streamMaps[player.name].online)
              .map(player => streamMaps[player.name].twitch);
            povs = povs.concat(team1Povs);
          }
          if (match.opponent2) {
            const team2Povs = teamsMap[match.opponent2.id].players
              .filter(player => streamMaps[player.name] && streamMaps[player.name].online)
              .map(player => streamMaps[player.name].twitch);
            povs = povs.concat(team2Povs);
          }
          if (povs.length) {
            livePOVs.push({
              opponent1: match.opponent1,
              opponent2: match.opponent2,
              povs: povs,
            });
          }
        });
        const povsContainer = document.querySelector('#live-pov');
        povsContainer.innerHTML = '';
        livePOVs.forEach(match => {
          try {
            const entry = createLiveEntry(teamsMap[match.opponent1.id].name, teamsMap[match.opponent2.id].name, match.povs);
            povsContainer.append(entry);
          } catch {
            console.log(match);
          }
        });
        const commContainer = document.querySelector('#live-community');
        commContainer.innerHTML = '';
        const comms = Object.keys(commStreams);
        // do we have matches that are actually happening?
        const filteredMatches = matches.filter(match => match.time < Date.now() && match.status < 4);
        if (filteredMatches.length > 0) {
          for (let i = 0; i < comms.length; i++) {
            let user = comms[i];
            if (commStreams[user] !== false) {
              if (commStreamsExtraInfo[user]) {
                const entry = createLiveEntry(`${user} (${commStreamsExtraInfo[user]})`, undefined, user);
                commContainer.append(entry);
              } else {
                const entry = createLiveEntry(user, undefined, user);
                commContainer.append(entry);
              }
            }
          }
        }
        console.log('finished constructing currently live matches');
      }

      const params = new URLSearchParams(window.location.search);
      const tournament = params.get('tournament') || '67955537ddc8370228222708';
      const processorType = params.get('processor') || 'gsl-double';
      const startTimeMapperType = timeMappers[params.get('timeMapper') || 'gc-quals'];
      const mainChannels = mainChannelMapper[params.get('mainStreams') || 'nagc'];
      const splitter = splitters[params.get('mainStreams') || 'nagc'];
      const anchor = window.location.hash;

      const URL = `https://dtmwra1jsgyb0.cloudfront.net/tournaments/${tournament}?extend%5Bstages%5D%5Bgroups%5D%5Bmatches%5D%5Btop.team%5D=true&extend%5Bstages%5D%5Bgroups%5D%5Bmatches%5D%5Bbottom.team%5D=true&extend%5Bstages%5D%5Bmatches%5D%5Btop.team%5D=true&extend%5Bstages%5D%5Bmatches%5D%5Bbottom.team%5D=true&extend%5Bstages%5D%5Bgroups%5D%5Bstandings%5D%5Bteam%5D=true&extend%5Bstages%5D%5Bstandings%5D%5Bteam%5D=true&extend%5Bstages%5D%5Bteams%5D=true`;
      const teamsUrl = `https://dtmwra1jsgyb0.cloudfront.net/tournaments/${tournament}/teams?page=1&limit=256`;

      getStreamMapper();
      setInterval(getStreamMapper, 60000);

      function updater() {
        const options = {
          headers: {
            origin: window.location.origin,
          }
        }
        fetch('https://squarebracket.github.io/version.json', options).then(res => res.json()).then((obj) => {
          console.log(version, obj.version);
          if (version < obj.version) {
            document.querySelector('#updater').classList.remove('hidden');
            let countdownEl = document.querySelector('#countdown');
            let countdown = 30;
            setInterval(() => {
              countdown--;
              countdownEl.innerText = countdown;
              if (countdown <= 0) {
                try {
                  window.location.reload();
                } catch { }
              }
            }, 1000);
          }
        });
      }

      setInterval(updater, 600000);

    </script>
  </div>
  <div id="updater" class="hidden">New version available. Reloading page in... <span id="countdown">30</span></div>
  <div id="footer">
    <div>Brought to you by squarebracket and <a href="https://twitter.com/zhobiiiii">@zhobiii</a></div>
  </div>
</body>

</html>